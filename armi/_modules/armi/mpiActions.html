

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>armi.mpiActions &mdash; ARMI 0.2.5 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_fixes.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/armiicon_16x16.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="../../_static/assets/jsonview.bundle.js"></script>
        <script src="../../_static/assets/jsonview_loader.js"></script>
        <script src="../../_static/sphinx-needs/libs/html/datatables.min.js"></script>
        <script src="../../_static/sphinx-needs/libs/html/datatables_loader.js"></script>
        <script src="../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >
          

          
            <a href="../../index.html" class="icon icon-home"> ARMI
          

          
            
            <img src="../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../requirements/index.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../.apidocs/modules.html">API Docs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ARMI</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../armi.html">armi</a> &raquo;</li>
        
      <li>armi.mpiActions</li>
    
    
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for armi.mpiActions</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides an abstract class to be used to implement &quot;MPI actions.&quot;</span>

<span class="sd">MPI actions are tasks, activities, or work that can be executed on the worker nodes. The standard</span>
<span class="sd">workflow is essentially that the primary node creates an :py:class:`~armi.mpiActions.MpiAction`,</span>
<span class="sd">sends it to the workers, and then both the primary and the workers</span>
<span class="sd">:py:meth:`invoke() &lt;armi.mpiActions.MpiAction.invoke&gt;` together. For example:</span>

<span class="sd">.. list-table:: Sample MPI Action Workflow</span>
<span class="sd">   :widths: 5 60 35</span>
<span class="sd">   :header-rows: 1</span>

<span class="sd">   * - Step</span>
<span class="sd">     - Code</span>
<span class="sd">     - Notes</span>
<span class="sd">   * - 1</span>
<span class="sd">     - **primary**: :py:class:`distributeState = DistributeStateAction() &lt;armi.mpiActions.MpiAction&gt;`</span>

<span class="sd">       **worker**: :code:`action = context.MPI_COMM.bcast(None, root=0)`</span>
<span class="sd">     - **primary**: Initializing a distribute state action.</span>

<span class="sd">       **worker**: Waiting for something to do, as determined by the primary, this happens within the</span>
<span class="sd">       worker&#39;s :py:meth:`~armi.operators.MpiOperator.workerOperate`.</span>
<span class="sd">   * - 2</span>
<span class="sd">     - **primary**: :code:`context.MPI_COMM.bcast(distributeState, root=0)`</span>

<span class="sd">       **worker**: :code:`action = context.MPI_COMM.bcast(None, root=0)`</span>
<span class="sd">     - **primary**: Broadcasts a distribute state action to all the worker nodes</span>

<span class="sd">       **worker**: Receives the action from the primary, which is a</span>
<span class="sd">       :py:class:`~armi.mpiActions.DistributeStateAction`.</span>
<span class="sd">   * - 3</span>
<span class="sd">     - **primary**: :code:`distributeState.invoke(self.o, self.r, self.cs)`</span>

<span class="sd">       **worker**: :code:`action.invoke(self.o, self.r, self.cs)`</span>
<span class="sd">     - Both invoke the action, and are in sync. Any broadcast or receive within the action should</span>
<span class="sd">       also be synced up.</span>

<span class="sd">In order to create a new, custom MPI Action, inherit from :py:class:`~armi.mpiActions.MpiAction`,</span>
<span class="sd">and override the :py:meth:`~armi.mpiActions.MpiAction.invokeHook` method.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">timeit</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="n">cPickle</span>
<span class="kn">import</span> <span class="nn">tabulate</span>

<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">context</span>
<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">interfaces</span>
<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">runLog</span>
<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">settings</span>
<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">reactors</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">assemblies</span>
<span class="kn">from</span> <span class="nn">armi.reactor.parameters</span> <span class="kn">import</span> <span class="n">parameterDefinitions</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">iterables</span>


<div class="viewcode-block" id="MpiAction"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.MpiAction">[docs]</a><span class="k">class</span> <span class="nc">MpiAction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base of all MPI actions.</span>

<span class="sd">    MPI Actions are tasks that can be executed without needing lots of other</span>
<span class="sd">    information. When a worker node sits in it&#39;s main loop, and receives an MPI Action, it will</span>
<span class="sd">    simply call :py:meth:`~armi.mpiActions.MpiAction.invoke`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">o</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serial</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">serial</span>

<div class="viewcode-block" id="MpiAction.invokeAsMaster"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.MpiAction.invokeAsMaster">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">invokeAsMaster</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simplified method to call from the primary process.</span>

<span class="sd">        This can be used in place of:</span>

<span class="sd">            someInstance = MpiAction()</span>
<span class="sd">            someInstance = COMM_WORLD.bcast(someInstance, root=0)</span>
<span class="sd">            someInstance.invoke(o, r, cs)</span>

<span class="sd">        Interestingly, the code above can be used in two ways:</span>

<span class="sd">        1. Both the primary and worker can call the above code at the same time, or</span>
<span class="sd">        2. the primary can run the above code, which will be handled by the worker&#39;s main loop.</span>

<span class="sd">        Option number 2 is the most common usage.</span>

<span class="sd">        .. warning:: This method will not work if the constructor (i.e. :code:`__init__`) requires</span>
<span class="sd">            additional arguments. Since the method body is so simple, it is strong discouraged to</span>
<span class="sd">            add a :code:`*args` or :code:`**kwargs` arguments to this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        o : :py:class:`armi.operators.Operator`</span>
<span class="sd">            If an operator is not necessary, supply :code:`None`.</span>
<span class="sd">        r : :py:class:`armi.operators.Reactor`</span>
<span class="sd">            If a reactor is not necessary, supply :code:`None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">broadcast</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_mpiOperationHelper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">mpiFunction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Strips off the operator, reactor, cs from the mpiAction before</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># prevent sending o, r, and cs, they should be handled appropriately by the other nodes</span>
            <span class="c1"># reattach with finally</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">o</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mpiFunction</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">cPickle</span><span class="o">.</span><span class="n">PicklingError</span><span class="p">)</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failed to </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mpiFunction</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">o</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cs</span>

<div class="viewcode-block" id="MpiAction.broadcast"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.MpiAction.broadcast">[docs]</a>    <span class="k">def</span> <span class="nf">broadcast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A wrapper around ``bcast``, on the primary node can be run with an equals sign, so that it</span>
<span class="sd">        can be consistent within both primary and worker nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj :</span>
<span class="sd">            This is any object that can be broadcast, if it is None, then it will broadcast itself,</span>
<span class="sd">            which triggers it to run on the workers (assuming the workers are in the worker main loop.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.operators.operator.OperatorMPI.workerOperate : receives this on the workers and calls ``invoke``</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The standard ``bcast`` method creates a new instance even for the root process. Consequently,</span>
<span class="sd">        when passing an object, references can be broken to the original object. Therefore, this</span>
<span class="sd">        method, returns the original object when called by the primary node, or the broadcasted</span>
<span class="sd">        object when called on the worker nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">serial</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_SIZE</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mpiOperationHelper</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_COMM</span><span class="o">.</span><span class="n">bcast</span><span class="p">)</span>
        <span class="c1"># the following if-branch prevents the creation of duplicate objects on the primary node</span>
        <span class="c1"># if the object is large with lots of links, it is prudent to call gc.collect()</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="MpiAction.gather"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.MpiAction.gather">[docs]</a>    <span class="k">def</span> <span class="nf">gather</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A wrapper around ``MPI_COMM.gather``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj :</span>
<span class="sd">            This is any object that can be gathered, if it is None, then it will gather itself.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned list will contain a reference to the original gathered object, without making a copy of it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">serial</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">obj</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_SIZE</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mpiOperationHelper</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_COMM</span><span class="o">.</span><span class="n">gather</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># this cannot be result[0] = obj or self, because 0.0, 0, [] all eval to False</span>
                <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="MpiAction.invoke"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.MpiAction.invoke">[docs]</a>    <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called by worker nodes, and passed the worker node&#39;s operator, reactor and</span>
<span class="sd">        settings file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        o : :py:class:`armi.operators.operator.Operator`</span>
<span class="sd">            the operator for this process</span>
<span class="sd">        r : :py:class:`armi.reactor.reactors.Reactor`</span>
<span class="sd">            the reactor represented in this process</span>
<span class="sd">        cs : :py:class:`armi.settings.caseSettings.Settings`</span>
<span class="sd">            the case settings</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : object</span>
<span class="sd">            result from invokeHook</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">o</span> <span class="o">=</span> <span class="n">o</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">invokeHook</span><span class="p">()</span></div>

<div class="viewcode-block" id="MpiAction.mpiFlatten"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.MpiAction.mpiFlatten">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">mpiFlatten</span><span class="p">(</span><span class="n">allCPUResults</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flatten results to the same order they were in before making a list of mpiIter results.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mpiIter : used for distributing objects/tasks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">iterables</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">allCPUResults</span><span class="p">)</span></div>

<div class="viewcode-block" id="MpiAction.mpiIter"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.MpiAction.mpiIter">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">mpiIter</span><span class="p">(</span><span class="n">objectsForAllCoresToIter</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the subset of objects one node is responsible for in MPI.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Each CPU will get similar number of objects. E.G. if there are 12 objects and 5</span>
<span class="sd">        CPUs, the first 2 CPUs will get 3 objects and the last 3 CPUS will get 2.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        objectsForAllCoresToIter: list</span>
<span class="sd">            List of all objects that need to have an MPI calculation performed on.</span>
<span class="sd">            Note, that since len() is needed this method cannot accept a generator.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mpiFlatten : used for collecting results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ntasks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">objectsForAllCoresToIter</span><span class="p">)</span>
        <span class="n">numLocalObjects</span><span class="p">,</span> <span class="n">deficit</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">ntasks</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_SIZE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">&lt;</span> <span class="n">deficit</span><span class="p">:</span>
            <span class="n">numLocalObjects</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">*</span> <span class="n">numLocalObjects</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">*</span> <span class="n">numLocalObjects</span> <span class="o">+</span> <span class="n">deficit</span>

        <span class="k">for</span> <span class="n">objIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">first</span> <span class="o">+</span> <span class="n">numLocalObjects</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">objectsForAllCoresToIter</span><span class="p">[</span><span class="n">objIndex</span><span class="p">]</span></div>

<div class="viewcode-block" id="MpiAction.invokeHook"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.MpiAction.invokeHook">[docs]</a>    <span class="k">def</span> <span class="nf">invokeHook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method must be overridden in sub-clases.</span>

<span class="sd">        This method is called by worker nodes, and has access to the worker node&#39;s operator,</span>
<span class="sd">        reactor, and settings (through :code:`self.o`, :code:`self.r`, and :code:`self.cs`).</span>
<span class="sd">        It must return a boolean value of :code:`True` or :code:`False`, otherwise the worker node</span>
<span class="sd">        will raise an exception and terminate execution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : object</span>
<span class="sd">            Dependent on implementation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="runActions"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.runActions">[docs]</a><span class="k">def</span> <span class="nf">runActions</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">numPerNode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">serial</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run a series of MpiActions in parallel, or in series if :code:`serial=True`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The number of actions DOES NOT need to match :code:`context.MPI_SIZE`.</span>

<span class="sd">    Calling this method may invoke MPI Split which will change the MPI_SIZE during the action. This allows someone to</span>
<span class="sd">    call MPI operations without being blocked by tasks which are not doing the same thing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_DISTRIBUTABLE</span> <span class="ow">or</span> <span class="n">serial</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">runActionsInSerial</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">actions</span><span class="p">)</span>

    <span class="n">useForComputation</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_SIZE</span>
    <span class="k">if</span> <span class="n">numPerNode</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">numPerNode</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;numPerNode must be &gt;= 1&quot;</span><span class="p">)</span>
        <span class="n">numThisNode</span> <span class="o">=</span> <span class="p">{</span><span class="n">nodeName</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">nodeName</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_NODENAMES</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">rank</span><span class="p">,</span> <span class="n">nodeName</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">MPI_NODENAMES</span><span class="p">):</span>
            <span class="n">useForComputation</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span> <span class="o">=</span> <span class="n">numThisNode</span><span class="p">[</span><span class="n">nodeName</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">numPerNode</span>
            <span class="n">numThisNode</span><span class="p">[</span><span class="n">nodeName</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">numBatches</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
        <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">actions</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">([</span><span class="n">rank</span> <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">useForComputation</span> <span class="k">if</span> <span class="n">rank</span><span class="p">]))</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
        <span class="s2">&quot;Running </span><span class="si">{}</span><span class="s2"> MPI actions in parallel over </span><span class="si">{}</span><span class="s2"> batches&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">actions</span><span class="p">),</span> <span class="n">numBatches</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">actions</span><span class="p">)</span>  <span class="c1"># create a new list.. we will use as a queue</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">batchNum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">actionsThisRound</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">useRank</span> <span class="ow">in</span> <span class="n">useForComputation</span><span class="p">:</span>
            <span class="n">actionsThisRound</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">useRank</span> <span class="ow">and</span> <span class="n">queue</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">realActions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">MPI_NODENAMES</span><span class="p">[</span><span class="n">rank</span><span class="p">],</span> <span class="n">rank</span><span class="p">,</span> <span class="n">act</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">rank</span><span class="p">,</span> <span class="n">act</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">actionsThisRound</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">act</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="n">batchNum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
            <span class="s2">&quot;Distributing </span><span class="si">{}</span><span class="s2"> MPI actions for parallel processing (batch </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2">):</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">realActions</span><span class="p">),</span>
                <span class="n">batchNum</span><span class="p">,</span>
                <span class="n">numBatches</span><span class="p">,</span>
                <span class="n">tabulate</span><span class="o">.</span><span class="n">tabulate</span><span class="p">(</span><span class="n">realActions</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Nodename&quot;</span><span class="p">,</span> <span class="s2">&quot;Rank&quot;</span><span class="p">,</span> <span class="s2">&quot;Action&quot;</span><span class="p">]),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">distrib</span> <span class="o">=</span> <span class="n">DistributionAction</span><span class="p">(</span><span class="n">actionsThisRound</span><span class="p">)</span>
        <span class="n">distrib</span><span class="o">.</span><span class="n">broadcast</span><span class="p">()</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distrib</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cs</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="runActionsInSerial"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.runActionsInSerial">[docs]</a><span class="k">def</span> <span class="nf">runActionsInSerial</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">actions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run a series of MpiActions in serial.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This will set the `MpiAction.serial` attribute to :code:`True`, and the `MpiAction.broadcast` and `MpiAction.gather`</span>
<span class="sd">    methods will basically just return the value being supplied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Running </span><span class="si">{}</span><span class="s2"> MPI actions in serial&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actions</span><span class="p">)))</span>
    <span class="n">numActions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">actions</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">aa</span><span class="p">,</span> <span class="n">action</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">actions</span><span class="p">):</span>
        <span class="n">canDistribute</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_DISTRIBUTABLE</span>
        <span class="n">action</span><span class="o">.</span><span class="n">serial</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">context</span><span class="o">.</span><span class="n">MPI_DISTRIBUTABLE</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Running action </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aa</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">numActions</span><span class="p">,</span> <span class="n">action</span><span class="p">))</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">action</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cs</span><span class="p">))</span>
        <span class="n">action</span><span class="o">.</span><span class="n">serial</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># return to original state</span>
        <span class="n">context</span><span class="o">.</span><span class="n">MPI_DISTRIBUTABLE</span> <span class="o">=</span> <span class="n">canDistribute</span>
    <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="DistributionAction"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.DistributionAction">[docs]</a><span class="k">class</span> <span class="nc">DistributionAction</span><span class="p">(</span><span class="n">MpiAction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This MpiAction scatters the workload of multiple actions to available resources.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This currently only works from the root (of COMM_WORLD). Eventually, it would be nice to make</span>
<span class="sd">    it possible for sub-tasks to manage their own communicators and spawn their own work within some</span>
<span class="sd">    sub-communicator.</span>

<span class="sd">    This performs an MPI Split operation and takes over the context.MPI_COMM and associated varaibles.</span>
<span class="sd">    For this reason, it is possible that when someone thinks they have distributed information to all</span>
<span class="sd">    nodes, it may only be a subset that was necessary to perform the number of actions needed by this</span>
<span class="sd">    DsitributionAction.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">actions</span><span class="p">):</span>
        <span class="n">MpiAction</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_actions</span> <span class="o">=</span> <span class="n">actions</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reduce prevents from unnecessary actions to others, after all we only want to scatter.</span>

<span class="sd">        Consequently, the worker nodes _actions will be None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DistributionAction</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>

<div class="viewcode-block" id="DistributionAction.invokeHook"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.DistributionAction.invokeHook">[docs]</a>    <span class="k">def</span> <span class="nf">invokeHook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides invokeHook to distribute work amongst available resources as requested.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>
<span class="sd">        Two things about this method make it non-recursive</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">canDistribute</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_DISTRIBUTABLE</span>
        <span class="n">mpiComm</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_COMM</span>
        <span class="n">mpiRank</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span>
        <span class="n">mpiSize</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_SIZE</span>
        <span class="n">mpiNodeNames</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_NODENAMES</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;verbosity&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;debug&quot;</span> <span class="ow">and</span> <span class="n">mpiRank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Printing diagnostics for MPI actions!&quot;</span><span class="p">)</span>
            <span class="n">objectCountDict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">debugAction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actions</span><span class="p">:</span>
                <span class="n">utils</span><span class="o">.</span><span class="n">classesInHierarchy</span><span class="p">(</span><span class="n">debugAction</span><span class="p">,</span> <span class="n">objectCountDict</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">objekt</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">objectCountDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;There are </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> in MPI action </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">count</span><span class="p">,</span> <span class="n">objekt</span><span class="p">,</span> <span class="n">debugAction</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="n">actionResult</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">mpiComm</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_actions</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># create a new communicator that only has these specific dudes running</span>
            <span class="n">hasAction</span> <span class="o">=</span> <span class="n">action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">context</span><span class="o">.</span><span class="n">MPI_COMM</span> <span class="o">=</span> <span class="n">mpiComm</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">hasAction</span><span class="p">))</span>
            <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_COMM</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
            <span class="n">context</span><span class="o">.</span><span class="n">MPI_SIZE</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_COMM</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
            <span class="n">context</span><span class="o">.</span><span class="n">MPI_DISTRIBUTABLE</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_SIZE</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="n">context</span><span class="o">.</span><span class="n">MPI_NODENAMES</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_COMM</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">MPI_NODENAME</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hasAction</span><span class="p">:</span>
                <span class="n">actionResult</span> <span class="o">=</span> <span class="n">action</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># restore the global variables</span>
            <span class="n">context</span><span class="o">.</span><span class="n">MPI_DISTRIBUTABLE</span> <span class="o">=</span> <span class="n">canDistribute</span>
            <span class="n">context</span><span class="o">.</span><span class="n">MPI_COMM</span> <span class="o">=</span> <span class="n">mpiComm</span>
            <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">=</span> <span class="n">mpiRank</span>
            <span class="n">context</span><span class="o">.</span><span class="n">MPI_SIZE</span> <span class="o">=</span> <span class="n">mpiSize</span>
            <span class="n">context</span><span class="o">.</span><span class="n">MPI_NODENAMES</span> <span class="o">=</span> <span class="n">mpiNodeNames</span>

        <span class="k">return</span> <span class="n">actionResult</span></div></div>


<div class="viewcode-block" id="MpiActionError"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.MpiActionError">[docs]</a><span class="k">class</span> <span class="nc">MpiActionError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Exception class raised when error conditions occur during an MpiAction.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="DistributeStateAction"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.DistributeStateAction">[docs]</a><span class="k">class</span> <span class="nc">DistributeStateAction</span><span class="p">(</span><span class="n">MpiAction</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skipInterfaces</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">MpiAction</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skipInterfaces</span> <span class="o">=</span> <span class="n">skipInterfaces</span>

<div class="viewcode-block" id="DistributeStateAction.invokeHook"><a class="viewcode-back" href="../../.apidocs/armi.mpiActions.html#armi.mpiActions.DistributeStateAction.invokeHook">[docs]</a>    <span class="k">def</span> <span class="nf">invokeHook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Sync up all nodes with the reactor, the cs, and the interfaces.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is run by all workers and the primary any time the code needs to sync all processors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_SIZE</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Not distributing state because there is only one processor&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Detach phase:</span>
        <span class="c1"># The Reactor and the interfaces have links to the Operator, which contains Un-MPI-able objects</span>
        <span class="c1"># like the MPI Comm and the SQL database connections.</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Distributing State&quot;</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distributeSettings</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_distributeReactor</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
            <span class="n">DistributeStateAction</span><span class="o">.</span><span class="n">_distributeParamAssignments</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipInterfaces</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">reattach</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>  <span class="c1"># may be redundant?</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_distributeInterfaces</span><span class="p">()</span>

            <span class="c1"># lastly, make sure the reactor knows it is up to date</span>
            <span class="c1"># the operator/interface attachment may invalidate some of the cache, but since</span>
            <span class="c1"># all the underlying data is the same, ultimately all state should be (initially) the</span>
            <span class="c1"># same.</span>
            <span class="c1"># XXX: this is an indication we need to revamp either how the operator attachment works</span>
            <span class="c1"># or how the interfaces are distributed.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">_markSynchronized</span><span class="p">()</span>  <span class="c1"># pylint: disable=protected-access</span>

        <span class="k">except</span> <span class="p">(</span><span class="n">cPickle</span><span class="o">.</span><span class="n">PicklingError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failed to transmit on distribute state root MPI bcast&quot;</span><span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
            <span class="c1"># workers are still waiting for a reactor object</span>
            <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">_diagnosePickleError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="p">)</span>
                <span class="n">context</span><span class="o">.</span><span class="n">MPI_COMM</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="s2">&quot;quit&quot;</span><span class="p">)</span>  <span class="c1"># try to get the workers to quit.</span>

            <span class="k">raise</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">regenAssemblyLists</span><span class="p">()</span>  <span class="c1"># pylint: disable=no-member</span>

        <span class="c1"># check to make sure that everything has been properly reattached</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getFirstBlock</span><span class="p">()</span><span class="o">.</span><span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">:</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Block.r is not self.r. Reattach the blocks!&quot;</span><span class="p">)</span>

        <span class="n">beforeCollection</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>

        <span class="c1"># force collection; we&#39;ve just created a bunch of objects that don&#39;t need to be used again.</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Forcing garbage collection.&quot;</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="n">stop</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
            <span class="s2">&quot;Distributed state in </span><span class="si">{}</span><span class="s2">s, garbage collection took </span><span class="si">{}</span><span class="s2">s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">beforeCollection</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">beforeCollection</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_distributeSettings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sending the settings object&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">cs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">Settings</span><span class="p">):</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">setVerbosity</span><span class="p">(</span>
                <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;verbosity&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;branchVerbosity&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Received settings object&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to transmit settings, received: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">settings</span><span class="o">.</span><span class="n">setMasterCs</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span>
        <span class="k">return</span> <span class="n">cs</span>

    <span class="k">def</span> <span class="nf">_distributeReactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sending the Reactor object&quot;</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">reactors</span><span class="o">.</span><span class="n">Reactor</span><span class="p">):</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Received reactor&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to transmit reactor, received: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># on the primary node this unfortunately created a __deepcopy__ of the reactor, delete it</span>
            <span class="k">del</span> <span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># maintain original reactor object on primary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;The reactor has </span><span class="si">{}</span><span class="s2"> assemblies&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">()))</span>
        <span class="p">)</span>
        <span class="n">numAssemblies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">assemblies</span><span class="o">.</span><span class="n">getAssemNum</span><span class="p">())</span>
        <span class="n">assemblies</span><span class="o">.</span><span class="n">setAssemNumCounter</span><span class="p">(</span><span class="n">numAssemblies</span><span class="p">)</span>
        <span class="c1"># attach here so any interface actions use a properly-setup reactor.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">reattach</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>  <span class="c1"># sets r and cs</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_distributeParamAssignments</span><span class="p">():</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">(</span><span class="n">pName</span><span class="p">,</span> <span class="n">pdType</span><span class="o">.</span><span class="vm">__name__</span><span class="p">):</span> <span class="n">pDef</span><span class="o">.</span><span class="n">assigned</span>
                <span class="k">for</span> <span class="p">(</span>
                    <span class="n">pName</span><span class="p">,</span>
                    <span class="n">pdType</span><span class="p">,</span>
                <span class="p">),</span> <span class="n">pDef</span> <span class="ow">in</span> <span class="n">parameterDefinitions</span><span class="o">.</span><span class="n">ALL_DEFINITIONS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_COMM</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">pName</span><span class="p">,</span> <span class="n">pdType</span><span class="p">),</span> <span class="n">pDef</span> <span class="ow">in</span> <span class="n">parameterDefinitions</span><span class="o">.</span><span class="n">ALL_DEFINITIONS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">pDef</span><span class="o">.</span><span class="n">assigned</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pName</span><span class="p">,</span> <span class="n">pdType</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_distributeInterfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Distribute the interfaces to all MPI nodes.</span>

<span class="sd">        Interface copy description</span>
<span class="sd">        Since interfaces store information that can influence a calculation, it is important</span>
<span class="sd">        in branch searches to make sure that no information is carried forward from these</span>
<span class="sd">        runs on either the primary node or the workers.  However, there are interfaces that</span>
<span class="sd">        cannot be distributed, making this a challenge.  To solve this problem, any interface</span>
<span class="sd">        that cannot be distributed is simply re-initialized.  If any information needs to be</span>
<span class="sd">        given to the worker nodes on a non-distributable interface, additional function definitions</span>
<span class="sd">        (and likely soul searching as to why needed distributable information is on a</span>
<span class="sd">        non-distributable interface) are required to pass the information around.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.interfaces.Interface.preDistributeState : runs on primary before DS</span>
<span class="sd">        armi.interfaces.Interface.postDistributeState : runs on primary after DS</span>
<span class="sd">        armi.interfaces.Interface.interactDistributeState : runs on workers after DS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">MPI_RANK</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># These run on the primary node. (Worker nodes run sychronized code below)</span>
            <span class="n">toRestore</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">getInterfaces</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">distributable</span><span class="p">()</span> <span class="o">==</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">Interface</span><span class="o">.</span><span class="n">Distribute</span><span class="o">.</span><span class="n">DUPLICATE</span><span class="p">:</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;detaching interface </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                    <span class="n">i</span><span class="o">.</span><span class="n">detachReactor</span><span class="p">()</span>
                    <span class="n">toRestore</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">preDistributeState</span><span class="p">()</span>

            <span class="c1"># Verify that the interface stacks are identical.</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sending the interface names and flags&quot;</span><span class="p">)</span>
            <span class="n">_dumIList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">distributable</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">getInterfaces</span><span class="p">()]</span>
            <span class="p">)</span>

            <span class="c1"># transmit interfaces</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">getInterfaces</span><span class="p">():</span>
                <span class="c1"># avoid sending things that don&#39;t pickle, like the database.</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">distributable</span><span class="p">()</span> <span class="o">==</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">Interface</span><span class="o">.</span><span class="n">Distribute</span><span class="o">.</span><span class="n">DUPLICATE</span><span class="p">:</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sending the interface </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                    <span class="n">_idum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># don&#39;t send the reactor or operator</span>
                    <span class="n">i</span><span class="o">.</span><span class="n">postDistributeState</span><span class="p">(</span><span class="n">toRestore</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">i</span><span class="o">.</span><span class="n">attachReactor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># These run on the worker nodes.</span>
            <span class="c1"># verify identical interface stack</span>
            <span class="c1"># This list is (interfaceName, distributable) tuples)</span>
            <span class="n">interfaceList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">iName</span><span class="p">,</span> <span class="n">distributable</span> <span class="ow">in</span> <span class="n">interfaceList</span><span class="p">:</span>
                <span class="n">iOld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">getInterface</span><span class="p">(</span><span class="n">iName</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">distributable</span> <span class="o">==</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">Interface</span><span class="o">.</span><span class="n">Distribute</span><span class="o">.</span><span class="n">DUPLICATE</span><span class="p">:</span>
                    <span class="c1"># expect a transmission of the interface as a whole.</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Receiving new </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iName</span><span class="p">))</span>
                    <span class="n">iNew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Received </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iNew</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">iNew</span> <span class="o">==</span> <span class="s2">&quot;quit&quot;</span><span class="p">:</span>
                        <span class="k">return</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">removeInterface</span><span class="p">(</span><span class="n">iOld</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">addInterface</span><span class="p">(</span><span class="n">iNew</span><span class="p">)</span>
                    <span class="n">iNew</span><span class="o">.</span><span class="n">interactDistributeState</span><span class="p">()</span>  <span class="c1"># pylint: disable=no-member</span>
                <span class="k">elif</span> <span class="n">distributable</span> <span class="o">==</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">Interface</span><span class="o">.</span><span class="n">Distribute</span><span class="o">.</span><span class="n">NEW</span><span class="p">:</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Initializing new interface </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iName</span><span class="p">))</span>
                    <span class="c1"># make a fresh instance of the non-transmittable interface.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">removeInterface</span><span class="p">(</span><span class="n">iOld</span><span class="p">)</span>
                    <span class="n">iNew</span> <span class="o">=</span> <span class="n">iOld</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">iNew</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">getInterfaces</span><span class="p">():</span>
                            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                            <span class="s2">&quot;Non-distributable interface </span><span class="si">{0}</span><span class="s2"> exists on the primary MPI process &quot;</span>
                            <span class="s2">&quot;but not on the workers. &quot;</span>
                            <span class="s2">&quot;Cannot distribute state.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iName</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">addInterface</span><span class="p">(</span><span class="n">iNew</span><span class="p">)</span>
                    <span class="n">iNew</span><span class="o">.</span><span class="n">interactInit</span><span class="p">()</span>
                    <span class="n">iNew</span><span class="o">.</span><span class="n">interactBOL</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Skipping broadcast of interface </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iName</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">iOld</span><span class="p">:</span>
                        <span class="n">iOld</span><span class="o">.</span><span class="n">interactDistributeState</span><span class="p">()</span></div>


<span class="k">def</span> <span class="nf">_diagnosePickleError</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scans through various parts of the reactor to identify which part cannot be pickled.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    So, you&#39;re having a pickle error and you don&#39;t know why. This method will help you</span>
<span class="sd">    find the problem. It doesn&#39;t always catch everything, but it does help.</span>

<span class="sd">    We also find that modifying the Python library as documented here tells us which</span>
<span class="sd">    object can&#39;t be pickled by printing it out.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">checker</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">tryPickleOnAllContents3</span>
    <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;-------- Pickle Error Detection -------&quot;</span><span class="p">)</span>
    <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;For reference, the operator is </span><span class="si">{0}</span><span class="s2"> and the reactor is </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;Watch for other reactors or operators, and think about where they came from.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">o</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">r</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Scanning the Reactor for pickle errors&quot;</span><span class="p">)</span>
    <span class="n">checker</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>

    <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Scanning all assemblies for pickle errors&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">includeAll</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># pylint: disable=no-member</span>
        <span class="n">checker</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Scanning all blocks for pickle errors&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">includeAll</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># pylint: disable=no-member</span>
        <span class="n">checker</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Scanning blocks by name for pickle errors&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_bName</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">blocksByName</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># pylint: disable=no-member</span>
        <span class="n">checker</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Scanning the ISOTXS library for pickle errors&quot;</span><span class="p">)</span>
    <span class="n">checker</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>

    <span class="k">for</span> <span class="n">interface</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">getInterfaces</span><span class="p">():</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Scanning </span><span class="si">{}</span><span class="s2"> for pickle errors&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">interface</span><span class="p">))</span>
        <span class="n">checker</span><span class="p">(</span><span class="n">interface</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2009-2023, TerraPower, LLC.
      <span class="lastupdated">
        Last updated on 2023-01-19.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
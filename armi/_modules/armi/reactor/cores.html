

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>armi.reactor.cores &mdash; ARMI 0.6.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme_fixes.css?v=2b77b304" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=e5fbc548" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-data-viewer/jsonview.bundle.css?v=f6ef2277" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/libs/html/datatables.min.css?v=4b4fd840" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/common_css/need_core.css?v=f5b60a78" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/common_css/need_links.css?v=2150a916" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/common_css/need_toggle.css?v=5c6620df" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/common_css/need_style.css?v=678fb11e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/common_css/needstable.css?v=5e1b6797" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/modern.css?v=803738c0" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-test-results/common.css?v=9ec2c1d5" />

  
    <link rel="shortcut icon" href="../../../_static/armiicon_16x16.ico"/>
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=1c28bd9a"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="../../../_static/sphinx-data-viewer/jsonview.bundle.js?v=18cd53c5"></script>
      <script src="../../../_static/sphinx-data-viewer/jsonview_loader.js?v=f7ff7e7d"></script>
      <script src="../../../_static/sphinx-needs/libs/html/datatables.min.js?v=8a4aee21"></script>
      <script src="../../../_static/sphinx-needs/libs/html/datatables_loader.js?v=a2cae175"></script>
      <script src="../../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js?v=dca66431"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ARMI
              <img src="../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../qa_docs/index.html">QA Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../.apidocs/modules.html">API Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #233C5B" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ARMI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../armi.html">armi</a></li>
          <li class="breadcrumb-item"><a href="../reactor.html">armi.reactor</a></li>
      <li class="breadcrumb-item active">armi.reactor.cores</li>
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for armi.reactor.cores</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2024 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Core is a high-level object in the data model in ARMI.</span>

<span class="sd">A Core frequently contain assemblies which in turn contain more refinement in representing the</span>
<span class="sd">physical reactor.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ruamel.yaml</span><span class="w"> </span><span class="kn">import</span> <span class="n">YAML</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">armi</span><span class="w"> </span><span class="kn">import</span> <span class="n">getPluginManagerOrFail</span><span class="p">,</span> <span class="n">nuclearDataIO</span><span class="p">,</span> <span class="n">runLog</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.nuclearDataIO</span><span class="w"> </span><span class="kn">import</span> <span class="n">xsLibraries</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">assemblies</span><span class="p">,</span>
    <span class="n">blocks</span><span class="p">,</span>
    <span class="n">composites</span><span class="p">,</span>
    <span class="n">flags</span><span class="p">,</span>
    <span class="n">geometry</span><span class="p">,</span>
    <span class="n">grids</span><span class="p">,</span>
    <span class="n">parameters</span><span class="p">,</span>
    <span class="n">reactorParameters</span><span class="p">,</span>
    <span class="n">zones</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.flags</span><span class="w"> </span><span class="kn">import</span> <span class="n">Flags</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.zones</span><span class="w"> </span><span class="kn">import</span> <span class="n">Zone</span><span class="p">,</span> <span class="n">Zones</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.settings.fwSettings.globalSettings</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">CONF_CIRCULAR_RING_PITCH</span><span class="p">,</span>
    <span class="n">CONF_DETAILED_AXIAL_EXPANSION</span><span class="p">,</span>
    <span class="n">CONF_FRESH_FEED_TYPE</span><span class="p">,</span>
    <span class="n">CONF_MIN_MESH_SIZE_RATIO</span><span class="p">,</span>
    <span class="n">CONF_NON_UNIFORM_ASSEM_FLAGS</span><span class="p">,</span>
    <span class="n">CONF_STATIONARY_BLOCK_FLAGS</span><span class="p">,</span>
    <span class="n">CONF_TRACK_ASSEMS</span><span class="p">,</span>
    <span class="n">CONF_ZONE_DEFINITIONS</span><span class="p">,</span>
    <span class="n">CONF_ZONES_FILE</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">createFormattedStrWithDelimiter</span><span class="p">,</span> <span class="n">tabulate</span><span class="p">,</span> <span class="n">units</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.utils.iterables</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.utils.mathematics</span><span class="w"> </span><span class="kn">import</span> <span class="n">average1DWithinTolerance</span>


<div class="viewcode-block" id="Core">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Core</span><span class="p">(</span><span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reactor structure made up of assemblies. Could be a Core, spent fuel pool, reactor head, etc.</span>

<span class="sd">    This has the bulk of the data management operations.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    params : dict</span>
<span class="sd">        Core-level parameters are scalar values that have time dependence. Examples are keff,</span>
<span class="sd">        maxPercentBu, etc.</span>
<span class="sd">    assemblies : list</span>
<span class="sd">        List of assembly objects that are currently in the core</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pDefs</span> <span class="o">=</span> <span class="n">reactorParameters</span><span class="o">.</span><span class="n">defineCoreParameters</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the reactor object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of the object. Flags will inherit from this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circularRingList</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># lookup tables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numRings</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xsIndex</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">numMoves</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># placeholder for ISOTXS object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locParams</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># location-based parameters</span>
        <span class="c1"># overridden in case.py to include pre-reactor time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeOfStart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zones</span> <span class="o">=</span> <span class="n">zones</span><span class="o">.</span><span class="n">Zones</span><span class="p">()</span>  <span class="c1"># initialize with empty Zones object</span>
        <span class="c1"># initialize the list that holds all shuffles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moves</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalarVals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeList</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of block types to convert name - to -number.</span>

        <span class="c1"># leftover default &quot;settings&quot; that are intended to eventually be elsewhere.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freshFeedType</span> <span class="o">=</span> <span class="s2">&quot;feed fuel&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trackAssems</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circularRingMode</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circularRingPitch</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minMeshSizeRatio</span> <span class="o">=</span> <span class="mf">0.15</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_detailedAxialExpansion</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Core.setOptionsFromCs">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.setOptionsFromCs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setOptionsFromCs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">armi.physics.fuelCycle.settings</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
            <span class="n">CONF_CIRCULAR_RING_MODE</span><span class="p">,</span>
            <span class="n">CONF_JUMP_RING_NUM</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># these are really &quot;user modifiable modeling constants&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">jumpRing</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">CONF_JUMP_RING_NUM</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freshFeedType</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">CONF_FRESH_FEED_TYPE</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trackAssems</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">CONF_TRACK_ASSEMS</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circularRingMode</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">CONF_CIRCULAR_RING_MODE</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circularRingPitch</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">CONF_CIRCULAR_RING_PITCH</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minMeshSizeRatio</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">CONF_MIN_MESH_SIZE_RATIO</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_detailedAxialExpansion</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">CONF_DETAILED_AXIAL_EXPANSION</span><span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies a settings and parent to the core and components.&quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regenAssemblyLists</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">newC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">newC</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(),</span> <span class="n">memo</span><span class="p">))</span>
        <span class="n">newC</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;-copy&quot;</span>
        <span class="k">return</span> <span class="n">newC</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2"> id:</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Override the base Composite __iter__ to produce stable sort order.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.reactors</span><span class="w"> </span><span class="kn">import</span> <span class="n">Reactor</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">Reactor</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">geometry</span><span class="o">.</span><span class="n">SymmetryType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Getter for symmetry type.</span>

<span class="sd">        .. impl:: Get core symmetry.</span>
<span class="sd">            :id: I_ARMI_R_SYMM</span>
<span class="sd">            :implements: R_ARMI_R_SYMM</span>

<span class="sd">            This property getter returns the symmetry attribute of the spatialGrid instance</span>
<span class="sd">            attribute. The spatialGrid is an instance of a child of the abstract base class</span>
<span class="sd">            :py:class:`Grid &lt;armi.reactor.grids.grid.Grid&gt;` type. The symmetry attribute is an</span>
<span class="sd">            instance of the :py:class:`SymmetryType &lt;armi.reactor.geometry.SymmetryType&gt;` class,</span>
<span class="sd">            which is a wrapper around the :py:class:`DomainType &lt;armi.reactor.geometry.DomainType&gt;`</span>
<span class="sd">            and :py:class:`BoundaryType &lt;armi.reactor.geometry.BoundaryType&gt;` enumerations used to</span>
<span class="sd">            classify the domain (e.g., 1/3 core, quarter core, full core) and symmetry boundary</span>
<span class="sd">            conditions (e.g., periodic, reflective, none) of a reactor, respectively.</span>

<span class="sd">            Only specific combinations of :py:class:`Grid &lt;armi.reactor.grids.grid.Grid&gt;` type,</span>
<span class="sd">            :py:class:`DomainType &lt;armi.reactor.geometry.DomainType&gt;`, and :py:class:`BoundaryType</span>
<span class="sd">            &lt;armi.reactor.geometry.BoundaryType&gt;` are valid. The validity of a user-specified</span>
<span class="sd">            geometry and symmetry is verified by a settings :py:class:`Inspector</span>
<span class="sd">            &lt;armi.settings.settingsValidation.Inspector`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot access symmetry before a spatialGrid is attached.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">symmetry</span>

    <span class="nd">@symmetry</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Setter for symmetry type.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">geomType</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot access geomType before a spatialGrid is attached.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">geomType</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">powerMultiplier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Symmetry factor for this model. 1 for full core, 3 for 1/3 core, etc.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This should not be a state variable because it just reflects the current geometry.</span>
<span class="sd">        It changes automatically if the symmetry changes (e.g. from a geometry conversion).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">symmetryFactor</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lib</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xsLibraries</span><span class="o">.</span><span class="n">IsotxsLibrary</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the microscopic cross section library, if one exists.</span>

<span class="sd">        - If there is a library currently associated with the Core, it will be returned</span>
<span class="sd">        - Otherwise, an ``ISOTXS`` file will be searched for in the working directory, opened as ``ISOTXS`` object and</span>
<span class="sd">          returned. If possible, it will find the correct file for the current cycle and timeNode.</span>
<span class="sd">        - Finally, if no ``ISOTXS`` file exists in the working directory, a None value will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># determine the current cycle and timeNode</span>
        <span class="n">cycle</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cycle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cycle</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">timeNode</span>

        <span class="c1"># if self._lib is None, try to find a local file</span>
        <span class="n">isotxsFileName</span> <span class="o">=</span> <span class="n">nuclearDataIO</span><span class="o">.</span><span class="n">getExpectedISOTXSFileName</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">isotxsFileName</span><span class="p">):</span>
            <span class="c1"># try to find the file for this specific cycle/node</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading microscopic cross section library `</span><span class="si">{</span><span class="n">isotxsFileName</span><span class="si">}</span><span class="s2">` at </span><span class="si">{</span><span class="n">cycle</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="o">=</span> <span class="n">nuclearDataIO</span><span class="o">.</span><span class="n">isotxs</span><span class="o">.</span><span class="n">readBinary</span><span class="p">(</span><span class="n">isotxsFileName</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># try to find any local file, not labeled by cycle/node</span>
            <span class="n">isotxsFileName</span> <span class="o">=</span> <span class="n">nuclearDataIO</span><span class="o">.</span><span class="n">getExpectedISOTXSFileName</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">isotxsFileName</span><span class="p">):</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading microscopic cross section library `</span><span class="si">{</span><span class="n">isotxsFileName</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="o">=</span> <span class="n">nuclearDataIO</span><span class="o">.</span><span class="n">isotxs</span><span class="o">.</span><span class="n">readBinary</span><span class="p">(</span><span class="n">isotxsFileName</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span>

    <span class="nd">@lib</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lib</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the microscopic cross section library.&quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Updating cross section library on </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">Initial: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_lib</span><span class="si">}</span><span class="se">\n</span><span class="s2">Updated: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="Core.hasLib">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.hasLib">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">hasLib</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the microscopic cross section library is set.</span>

<span class="sd">        Since the property ``lib`` will attempt to auto-load from a given ISOTXS file</span>
<span class="sd">        in the working directory, checking ``r.core.lib is not None`` may result in unexpected</span>
<span class="sd">        behavior. Use this instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">isFullCore</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if reactor is full core, otherwise False.&quot;&quot;&quot;</span>
        <span class="c1"># Avoid using `not core.isFullCore` to check if third core geometry</span>
        <span class="c1"># use `core.symmetry.domain == geometry.DomainType.THIRD_CORE</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">FULL_CORE</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">refAssem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the &quot;reference&quot; assembly for this Core.</span>

<span class="sd">        The reference assembly is defined as the center-most assembly with a FUEL flag, if any are</span>
<span class="sd">        present, or the center-most of any assembly otherwise.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        The convenience of this property should be weighed against it&#39;s somewhat arbitrary nature</span>
<span class="sd">        for any particular client. The center-most fueled assembly is not particularly</span>
<span class="sd">        representative of the state of the core as a whole.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()</span>
        <span class="n">assems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span> <span class="n">sortKey</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">assems</span><span class="p">:</span>
            <span class="n">assems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">sortKey</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">assems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Core.sortAssemsByRing">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.sortAssemsByRing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sortAssemsByRing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sorts the reactor assemblies by ring and position.&quot;&quot;&quot;</span>
        <span class="n">sortKey</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_children</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sortKey</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.summarizeReactorStats">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.summarizeReactorStats">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summarizeReactorStats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes a summary of the reactor to check the mass and volume of all of the blocks.&quot;&quot;&quot;</span>
        <span class="n">totalMass</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">fissileMass</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">heavyMetalMass</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">totalVolume</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">numBlocks</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterBlocks</span><span class="p">():</span>
            <span class="n">totalMass</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">getMass</span><span class="p">()</span>
            <span class="n">fissileMass</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">getFissileMass</span><span class="p">()</span>
            <span class="n">heavyMetalMass</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">getHMMass</span><span class="p">()</span>
            <span class="n">totalVolume</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>
            <span class="n">numBlocks</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">totalMass</span> <span class="o">=</span> <span class="n">totalMass</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="n">fissileMass</span> <span class="o">=</span> <span class="n">fissileMass</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="n">heavyMetalMass</span> <span class="o">=</span> <span class="n">heavyMetalMass</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="n">totalVolume</span> <span class="o">=</span> <span class="n">totalVolume</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">powerMultiplier</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
            <span class="s2">&quot;Summary of </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">tabulate</span><span class="o">.</span><span class="n">tabulate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="s2">&quot;Number of Blocks&quot;</span><span class="p">,</span> <span class="n">numBlocks</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;Total Volume (cc)&quot;</span><span class="p">,</span> <span class="n">totalVolume</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;Total Mass (kg)&quot;</span><span class="p">,</span> <span class="n">totalMass</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;Fissile Mass (kg)&quot;</span><span class="p">,</span> <span class="n">fissileMass</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;Heavy Metal Mass (kg)&quot;</span><span class="p">,</span> <span class="n">heavyMetalMass</span><span class="p">),</span>
                <span class="p">],</span>
                <span class="n">tableFmt</span><span class="o">=</span><span class="s2">&quot;armi&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Core.setPowerFromDensity">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.setPowerFromDensity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setPowerFromDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the power from the powerDensity.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">powerDensity</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHMMass</span><span class="p">()</span></div>


<div class="viewcode-block" id="Core.setPowerIfNecessary">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.setPowerIfNecessary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setPowerIfNecessary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the core power, from the power density.</span>

<span class="sd">        If the power density is set, but the power isn&#39;t, calculate the total heavy metal mass of</span>
<span class="sd">        the reactor, and set the total power. Which will then be the real source of truth again.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">powerDensity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setPowerFromDensity</span><span class="p">()</span></div>


<div class="viewcode-block" id="Core.setBlockMassParams">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.setBlockMassParams">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setBlockMassParams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the parameters kgHM and kgFis for each block and calculate Pu fraction.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterBlocks</span><span class="p">():</span>
            <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">kgHM</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getHMMass</span><span class="p">()</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">G_PER_KG</span>
            <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">kgFis</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getFissileMass</span><span class="p">()</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">G_PER_KG</span>
            <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">puFrac</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getPuMoles</span><span class="p">()</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOL</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOL</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="Core.getScalarEvolution">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getScalarEvolution">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getScalarEvolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalarVals</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Core.locateAllAssemblies">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.locateAllAssemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">locateAllAssemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the current location of all assemblies.</span>

<span class="sd">        This is required for shuffle printouts, repeat shuffling, and MCNP shuffling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">includeAll</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">a</span><span class="o">.</span><span class="n">lastLocationLabel</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span></div>


<div class="viewcode-block" id="Core.removeAssembly">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.removeAssembly">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">removeAssembly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">discharge</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">addToSFP</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes an assembly and puts it out of core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a1 : assembly</span>
<span class="sd">            The assembly to remove</span>
<span class="sd">        discharge : bool, optional</span>
<span class="sd">            Discharge the assembly, including adding it to the SFP. Default: True</span>
<span class="sd">        addToSFP : bool, optional</span>
<span class="sd">            Store the discharged assembly in the SFP regardless of the</span>
<span class="sd">            ``trackAssems`` setting. Default: False</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Please expect this method will delete your assembly (instead of moving it into a Spent Fuel</span>
<span class="sd">        Pool) unless you set ``trackAssems`` to True or ``addToSFP`` is set to True.</span>

<span class="sd">        Originally, this held onto all assemblies in the Spend Fuel Pool. However, they use memory.</span>
<span class="sd">        And it is possible to have the history interface record only the parameters you need.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.reactors</span><span class="w"> </span><span class="kn">import</span> <span class="n">Reactor</span>

        <span class="n">paramDefs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">ALL_DEFINITIONS</span><span class="p">)</span>
        <span class="n">paramDefs</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">forType</span><span class="p">(</span><span class="n">Core</span><span class="p">)))</span>
        <span class="n">paramDefs</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">forType</span><span class="p">(</span><span class="n">Reactor</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">paramDef</span> <span class="ow">in</span> <span class="n">paramDefs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">paramDef</span><span class="o">.</span><span class="n">assigned</span> <span class="o">&amp;</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span><span class="p">:</span>
                <span class="n">paramDef</span><span class="o">.</span><span class="n">assigned</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span>

        <span class="k">if</span> <span class="n">discharge</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removing </span><span class="si">{</span><span class="n">a1</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Purging  </span><span class="si">{</span><span class="n">a1</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
        <span class="n">a1</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">dischargeTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">discharge</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trackAssems</span> <span class="ow">or</span> <span class="n">addToSFP</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">excore</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sfp&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">excore</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No Spent Fuel Pool is found, can&#39;t track assemblies.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_removeListFromAuxiliaries</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.removeAssembliesInRing">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.removeAssembliesInRing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">removeAssembliesInRing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ringNum</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">overrideCircularRingMode</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all of the assemblies in a given ring.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ringNum : int</span>
<span class="sd">            The ring to remove</span>
<span class="sd">        cs: Settings</span>
<span class="sd">            A relevant settings object</span>
<span class="sd">        overrideCircularRingMode : bool, optional</span>
<span class="sd">            False ~ default: use circular/square/hex rings, just as the reactor defines them</span>
<span class="sd">            True ~ Turn off circular ring mode, and instead use square or hex.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getAssembliesInRing : definition of a ring</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssembliesInRing</span><span class="p">(</span><span class="n">ringNum</span><span class="p">,</span> <span class="n">overrideCircularRingMode</span><span class="o">=</span><span class="n">overrideCircularRingMode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">removeAssembly</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">processLoading</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_removeListFromAuxiliaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assembly</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove an assembly from all auxiliary reference tables and lists.</span>

<span class="sd">        Otherwise it will get added back into assembliesByName, etc.</span>

<span class="sd">        History will fail if it tries to summarize an assembly that has been purged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span><span class="p">[</span><span class="n">assembly</span><span class="o">.</span><span class="n">getName</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">getName</span><span class="p">()]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot delete block </span><span class="si">{0}</span><span class="s2">. It is not in the Core.blocksByName structure&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">),</span>
                    <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;cannot dereference: lost block&quot;</span><span class="p">,</span>
                <span class="p">)</span>

<div class="viewcode-block" id="Core.normalizeNames">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.normalizeNames">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">normalizeNames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startIndex</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renumber and rename all the Assemblies and Blocks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        startIndex : int, optional</span>
<span class="sd">            The default is to start counting at zero. But if you are renumbering assemblies across</span>
<span class="sd">            the entire Reactor, you may want to start at a different number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The new max Assembly number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">startIndex</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">oldName</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
            <span class="n">newName</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">makeNameFromAssemNum</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">oldName</span> <span class="o">==</span> <span class="n">newName</span><span class="p">:</span>
                <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span> <span class="o">=</span> <span class="n">ind</span>
            <span class="n">a</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="n">newName</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                <span class="n">axialIndex</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">b</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">makeName</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">axialIndex</span><span class="p">)</span>

            <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">normalizeInternalBookeeping</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ind</span></div>


<div class="viewcode-block" id="Core.normalizeInternalBookeeping">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.normalizeInternalBookeeping">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">normalizeInternalBookeeping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update some bookkeeping dictionaries of assembly and block names in this Core.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">assem</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span><span class="p">[</span><span class="n">assem</span><span class="o">.</span><span class="n">getName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">assem</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">assem</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">getName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">b</span></div>


<div class="viewcode-block" id="Core.add">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">spatialLocator</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an assembly to the reactor.</span>

<span class="sd">        An object must be added before it is placed in a particular cell in the reactor&#39;s</span>
<span class="sd">        spatialGrid. When an object is added to a Reactor it get placed in a generic location at the</span>
<span class="sd">        center of the Reactor unless a spatialLocator is passed in as well.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : ArmiObject</span>
<span class="sd">            The object to add to the reactor</span>
<span class="sd">        spatialLocator : SpatialLocator object, optional</span>
<span class="sd">            The location in the reactor to add the new object to. Must be unoccupied.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        removeAssembly : removes an assembly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.reactors</span><span class="w"> </span><span class="kn">import</span> <span class="n">Reactor</span>

        <span class="c1"># Negative assembly IDs are placeholders, and we need to renumber the assembly</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">renumber</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">incrementAssemNum</span><span class="p">())</span>

        <span class="c1"># resetting .assigned forces database to be rewritten for shuffled core</span>
        <span class="n">paramDefs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">ALL_DEFINITIONS</span><span class="p">)</span>
        <span class="n">paramDefs</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">forType</span><span class="p">(</span><span class="n">Core</span><span class="p">)))</span>
        <span class="n">paramDefs</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">forType</span><span class="p">(</span><span class="n">Reactor</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">paramDef</span> <span class="ow">in</span> <span class="n">paramDefs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">paramDef</span><span class="o">.</span><span class="n">assigned</span> <span class="o">&amp;</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span><span class="p">:</span>
                <span class="n">paramDef</span><span class="o">.</span><span class="n">assigned</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span>

        <span class="c1"># could speed up output by passing format args as an arg and only process if verb good.</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding   </span><span class="si">{0}</span><span class="s2"> to </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">aName</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>

        <span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">spatialLocator</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span>

        <span class="k">if</span> <span class="n">spatialLocator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">spatialLocator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot add </span><span class="si">{}</span><span class="s2"> because location </span><span class="si">{}</span><span class="s2"> is already filled by </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">aName</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">spatialLocator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># transfer spatialLocator to Core one</span>
            <span class="n">spatialLocator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">indices</span><span class="p">)]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">locatorInDomain</span><span class="p">(</span><span class="n">spatialLocator</span><span class="p">,</span> <span class="n">symmetryOverlap</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span>
                    <span class="s2">&quot;Location `</span><span class="si">{}</span><span class="s2">` outside of the represented domain: `</span><span class="si">{}</span><span class="s2">`&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">spatialLocator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">spatialLocator</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="p">[</span><span class="n">spatialLocator</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="c1"># build a lookup table for history tracking.</span>
        <span class="k">if</span> <span class="n">aName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span><span class="p">[</span><span class="n">aName</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">:</span>
            <span class="c1"># try to keep assem numbering correct</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;The assembly </span><span class="si">{1}</span><span class="s2"> in the reactor already has the name </span><span class="si">{0}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">Cannot add </span><span class="si">{2}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Current assemNum is </span><span class="si">{3}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aName</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span><span class="p">[</span><span class="n">aName</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">maxAssemNum</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Core already contains an assembly with the same name.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span><span class="p">[</span><span class="n">aName</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">getName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">b</span>

        <span class="n">a</span><span class="o">.</span><span class="n">orientBlocks</span><span class="p">(</span><span class="n">parentSpatialGrid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geomType</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="o">.</span><span class="n">HEX</span><span class="p">:</span>
            <span class="n">ring</span><span class="p">,</span> <span class="n">_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">ring</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">numRings</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">numRings</span> <span class="o">=</span> <span class="n">ring</span>

        <span class="c1"># track the highest assem Num so when we load from a DB the future assemNums remain constant</span>
        <span class="n">aNum</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span>
        <span class="k">if</span> <span class="n">aNum</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">maxAssemNum</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">maxAssemNum</span> <span class="o">=</span> <span class="n">aNum</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">lastLocationLabel</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">DATABASE</span><span class="p">:</span>
            <span class="c1"># time the assembly enters the core in days</span>
            <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">chargeTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">time</span>
            <span class="c1"># cycle that the assembly enters the core</span>
            <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">chargeCycle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cycle</span>
            <span class="c1"># convert to kg</span>
            <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">chargeFis</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">getFissileMass</span><span class="p">()</span> <span class="o">/</span> <span class="mf">1000.0</span>
            <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">chargeBu</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">getMaxParam</span><span class="p">(</span><span class="s2">&quot;percentBu&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.genAssembliesAddedThisCycle">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.genAssembliesAddedThisCycle">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">genAssembliesAddedThisCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yield the assemblies that have been added in the current cycle.</span>

<span class="sd">        This uses the reactor&#39;s cycle parameter and the assemblies&#39; chargeCycle parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">chargeCycle</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cycle</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">a</span></div>


<div class="viewcode-block" id="Core.getNumRings">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getNumRings">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getNumRings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexBased</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of rings in this reactor. Based on location, so indexing will start at 1.</span>

<span class="sd">        Circular ring shuffling changes the interpretation of this result.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        If you loop through range(maxRing) then ring+1 is the one you want!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexBased : bool, optional</span>
<span class="sd">            If true, will force location-index interpretation, even if &quot;circular shuffling&quot; is enabled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">circularRingList</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">indexBased</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circularRingList</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumHexRings</span><span class="p">()</span></div>


<div class="viewcode-block" id="Core.getNumHexRings">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getNumHexRings">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getNumHexRings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of hex rings in the core. Based on location so indexing starts at 1.&quot;&quot;&quot;</span>
        <span class="n">maxRing</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">ring</span><span class="p">,</span> <span class="n">_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
            <span class="n">maxRing</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxRing</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">maxRing</span></div>


<div class="viewcode-block" id="Core.getNumAssembliesWithAllRingsFilledOut">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getNumAssembliesWithAllRingsFilledOut">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getNumAssembliesWithAllRingsFilledOut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nRings</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns nAssmWithBlanks (see description immediately below).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nRings : int</span>
<span class="sd">            The number of hex assembly rings in this core, including non-ful) rings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nAssmWithBlanks: int</span>
<span class="sd">            The number of assemblies that WOULD exist in this core if all outer assembly hex rings</span>
<span class="sd">            were &quot;filled out&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">nRings</span> <span class="o">*</span> <span class="p">(</span><span class="n">nRings</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nRings</span> <span class="o">*</span> <span class="p">(</span><span class="n">nRings</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nRings</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="Core.getNumEnergyGroups">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getNumEnergyGroups">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getNumEnergyGroups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of energy groups used in the problem.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.nuclearDataIO.ISOTXS.read1D : reads the number of energy groups off the ISOTXS library.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">numGroups</span></div>


<div class="viewcode-block" id="Core.countBlocksWithFlags">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.countBlocksWithFlags">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">countBlocksWithFlags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blockTypeSpec</span><span class="p">,</span> <span class="n">assemTypeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total number of blocks in an assembly in the reactor that</span>
<span class="sd">        meets the specified type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        blockTypeSpec : Flags or list of Flags</span>
<span class="sd">            The types of blocks to be counted in a single assembly</span>
<span class="sd">        assemTypeSpec : Flags or list of Flags</span>
<span class="sd">            The types of assemblies that are to be examine for the blockTypes of interest. None is</span>
<span class="sd">            every assembly.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        maxBlocks : int</span>
<span class="sd">            The maximum number of blocks of the specified types in a single assembly in the core.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">assems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">typeSpec</span><span class="o">=</span><span class="n">assemTypeSpec</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">blockTypeSpec</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assems</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># In case assems is empty</span>
            <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Core.countFuelAxialBlocks">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.countFuelAxialBlocks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">countFuelAxialBlocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the maximum number of fuel type blocks in any assembly in the core.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getFirstFuelBlockAxialNode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fuelblocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">includeBolAssems</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fuel</span><span class="p">)</span> <span class="k">for</span> <span class="n">fuel</span> <span class="ow">in</span> <span class="n">fuelblocks</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># thrown when iterator is empty</span>
            <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Core.getFirstFuelBlockAxialNode">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getFirstFuelBlockAxialNode">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getFirstFuelBlockAxialNode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the offset of the fuel from the grid plate in the assembly with the lowest fuel</span>
<span class="sd">        block.</span>

<span class="sd">        This assembly will dictate at what block level the SASSYS reactivity coefficients will start</span>
<span class="sd">        to be generated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">i</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">includeBolAssems</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># ValueError is thrown if min is called on an empty sequence.</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.getAssembliesInRing">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getAssembliesInRing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getAssembliesInRing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ring</span><span class="p">,</span>
        <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exactType</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">exclusions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overrideCircularRingMode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">assemblies</span><span class="o">.</span><span class="n">Assembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the assemblies in a specified ring. Definitions of rings can change</span>
<span class="sd">        with problem parameters.</span>

<span class="sd">        This function acts as a switch between two separate functions that define what a</span>
<span class="sd">        ring is based on a cs setting &#39;circularRingMode&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ring : int</span>
<span class="sd">            The ring number</span>

<span class="sd">        typeSpec : str, list</span>
<span class="sd">            a string or list of assembly types of interest</span>

<span class="sd">        exactType : bool</span>
<span class="sd">            flag to match the assembly type exactly</span>

<span class="sd">        exclusions : list of assemblies</span>
<span class="sd">            list of assemblies that are not to be considered</span>

<span class="sd">        overrideCircularRingMode : bool, optional</span>
<span class="sd">            False ~ default: use circular/square/hex rings, just as the reactor defines them</span>
<span class="sd">            True ~ If you know you don&#39;t want to use the circular ring mode, and instead want square or hex.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        aList : list of assemblies</span>
<span class="sd">            A list of assemblies that match the criteria within the ring</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circularRingMode</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overrideCircularRingMode</span><span class="p">:</span>
            <span class="n">getter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssembliesInCircularRing</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">getter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssembliesInSquareOrHexRing</span>

        <span class="k">return</span> <span class="n">getter</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exactType</span><span class="o">=</span><span class="n">exactType</span><span class="p">,</span> <span class="n">exclusions</span><span class="o">=</span><span class="n">exclusions</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.getMaxAssembliesInHexRing">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getMaxAssembliesInHexRing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getMaxAssembliesInHexRing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">fullCore</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the maximum number of assemblies possible for a given Hexagonal ring.</span>

<span class="sd">        ring - The ring of interest to calculate the maximum number of assemblies.</span>
<span class="sd">        numEdgeAssems - The number of edge assemblies in the reactor model (1/3 core).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Assumes that odd rings do not have an edge assembly in third core geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numAssemsUpToOuterRing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumAssembliesWithAllRingsFilledOut</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="n">numAssemsUpToInnerRing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumAssembliesWithAllRingsFilledOut</span><span class="p">(</span><span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">maxAssemsInRing</span> <span class="o">=</span> <span class="n">numAssemsUpToOuterRing</span> <span class="o">-</span> <span class="n">numAssemsUpToInnerRing</span>

        <span class="c1"># See note*</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fullCore</span><span class="p">:</span>
            <span class="n">ringMod</span> <span class="o">=</span> <span class="n">ring</span> <span class="o">%</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">ringMod</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">maxAssemsInRing</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">maxAssemsInRing</span></div>


<div class="viewcode-block" id="Core.getAssembliesInSquareOrHexRing">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getAssembliesInSquareOrHexRing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getAssembliesInSquareOrHexRing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exactType</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclusions</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">assemblies</span><span class="o">.</span><span class="n">Assembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the assemblies in a specified ring. Definitions of rings can change with problem</span>
<span class="sd">        parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ring : int</span>
<span class="sd">            The ring number</span>

<span class="sd">        typeSpec : Flags or [Flags], optional</span>
<span class="sd">            a Flags instance or list of Flags with assembly types of interest</span>

<span class="sd">        exactType : bool</span>
<span class="sd">            flag to match the assembly type exactly</span>

<span class="sd">        exclusions : list of assemblies</span>
<span class="sd">            list of assemblies that are not to be considered</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        assems : list of assemblies</span>
<span class="sd">            A list of assemblies that match the criteria within the ring</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">assems</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclusions</span><span class="p">:</span>
            <span class="n">exclusions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclusions</span><span class="p">)</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">exclusions</span><span class="p">)</span>

        <span class="c1"># filter based on geomType</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geomType</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="o">.</span><span class="n">CARTESIAN</span><span class="p">:</span>  <span class="c1"># a ring in cartesian is basically a square.</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span><span class="n">xy</span> <span class="o">==</span> <span class="n">ring</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">indices</span><span class="p">[:</span><span class="mi">2</span><span class="p">])))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ring</span><span class="p">))</span>

        <span class="c1"># filter based on typeSpec</span>
        <span class="k">if</span> <span class="n">typeSpec</span><span class="p">:</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exactType</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">assems</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.getAssembliesInCircularRing">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getAssembliesInCircularRing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getAssembliesInCircularRing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exactType</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclusions</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">assemblies</span><span class="o">.</span><span class="n">Assembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets an assemblies within a circular range of the center of the core. This function allows</span>
<span class="sd">        for more circular styled assembly shuffling instead of the current hex approach.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ring : int</span>
<span class="sd">            The ring number</span>

<span class="sd">        typeSpec : Flags or list of Flags</span>
<span class="sd">            a Flags instance or list of Flags with assembly types of interest</span>

<span class="sd">        exactType : bool</span>
<span class="sd">            flag to match the assembly type exactly</span>

<span class="sd">        exclusions : list of assemblies</span>
<span class="sd">            list of assemblies that are not to be considered</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        assems : list of assemblies</span>
<span class="sd">            A list of assemblies that match the criteria within the ring</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geomType</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="o">.</span><span class="n">CARTESIAN</span><span class="p">:</span>
            <span class="c1"># a ring in cartesian is basically a square.</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;A circular ring in cartesian coordinates has not been defined yet.&quot;</span><span class="p">)</span>

        <span class="c1"># determine if the circularRingList has been generated</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">circularRingList</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">circularRingList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buildCircularRingDictionary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_circularRingPitch</span><span class="p">)</span>

        <span class="n">assems</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Remove exclusions</span>
        <span class="k">if</span> <span class="n">exclusions</span><span class="p">:</span>
            <span class="n">exclusions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclusions</span><span class="p">)</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">exclusions</span><span class="p">)</span>

        <span class="c1"># get assemblies at locations</span>
        <span class="n">locSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">circularRingList</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span>
        <span class="n">assems</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="ow">in</span> <span class="n">locSet</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">typeSpec</span><span class="p">:</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exactType</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">assems</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.buildCircularRingDictionary">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.buildCircularRingDictionary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">buildCircularRingDictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ringPitch</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a dictionary of all circular rings in the core. This is required information for</span>
<span class="sd">        getAssembliesInCircularRing.</span>

<span class="sd">        The purpose of this function is to allow for more circular core shuffling in the hex design.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ringPitch : float, optional</span>
<span class="sd">            The relative pitch that should be used to define the spacing between each ring.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Building a circular ring dictionary with ring pitch </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ringPitch</span><span class="p">))</span>
        <span class="n">referenceAssembly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="n">refLocation</span> <span class="o">=</span> <span class="n">referenceAssembly</span><span class="o">.</span><span class="n">spatialLocator</span>
        <span class="n">pitchFactor</span> <span class="o">=</span> <span class="n">ringPitch</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">pitch</span>

        <span class="n">circularRingDict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">distanceTo</span><span class="p">(</span><span class="n">refLocation</span><span class="p">)</span>
            <span class="c1"># To reduce numerical sensitivity, round distance to 6 decimal places</span>
            <span class="c1"># before truncating.</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">dist</span> <span class="o">*</span> <span class="n">pitchFactor</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span> <span class="ow">or</span> <span class="mi">1</span>  <span class="c1"># 1 is the smallest ring.</span>
            <span class="n">circularRingDict</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">circularRingDict</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_getAssembliesByName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the assembly name-to-assembly object map is deleted or out of date, then this will</span>
<span class="sd">        regenerate it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Generating assemblies-by-name map.&quot;</span><span class="p">)</span>

        <span class="c1"># NOTE: eliminated unnecessary repeated lookups in self for self.assembliesByName</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span> <span class="o">=</span> <span class="n">assymap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># don&#39;t includeAll b/c detailed ones are not ready yet</span>
        <span class="k">for</span> <span class="n">assem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">includeBolAssems</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includeSFP</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">aName</span> <span class="o">=</span> <span class="n">assem</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">aName</span> <span class="ow">in</span> <span class="n">assymap</span> <span class="ow">and</span> <span class="n">assymap</span><span class="p">[</span><span class="n">aName</span><span class="p">]</span> <span class="o">!=</span> <span class="n">assem</span><span class="p">:</span>
                <span class="c1"># dangerous situation that can occur in restart runs where the global assemNum isn&#39;t</span>
                <span class="c1"># updated. !=assem clause added because sometimes an assem is in one of the</span>
                <span class="c1"># includeAll lists that is also in the core and that&#39;s ok.</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;Two (or more) assemblies in the reactor (and associated lists) have the name &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">including </span><span class="si">{1}</span><span class="s2"> and </span><span class="si">{2}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aName</span><span class="p">,</span> <span class="n">assem</span><span class="p">,</span> <span class="n">assymap</span><span class="p">[</span><span class="n">aName</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Assembly name collision.&quot;</span><span class="p">)</span>

            <span class="n">assymap</span><span class="p">[</span><span class="n">aName</span><span class="p">]</span> <span class="o">=</span> <span class="n">assem</span>

<div class="viewcode-block" id="Core.getAssemblyByName">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getAssemblyByName">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getAssemblyByName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">assemblies</span><span class="o">.</span><span class="n">Assembly</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the assembly that has this name.</span>

<span class="sd">        .. impl:: Get assembly by name.</span>
<span class="sd">            :id: I_ARMI_R_GET_ASSEM0</span>
<span class="sd">            :implements: R_ARMI_R_GET_ASSEM</span>

<span class="sd">            This method returns the :py:class:`assembly &lt;armi.reactor.core.assemblies.Assembly&gt;`</span>
<span class="sd">            with a name matching the value provided as an input parameter to this function. The</span>
<span class="sd">            ``name`` of an assembly is based on the ``assemNum`` parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            the assembly name e.g. &#39;A0001&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Assembly</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getAssembly : more general version of this method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


<div class="viewcode-block" id="Core.getAssemblies">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getAssemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getAssemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sortKey</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">includeBolAssems</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">includeSFP</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">includeAll</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">zones</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">assemblies</span><span class="o">.</span><span class="n">Assembly</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of all the assemblies in the reactor.</span>

<span class="sd">        Assemblies from the Core are sorted based on the location-based Assembly comparison</span>
<span class="sd">        operators. This is done so that two reactors with physically identical properties are</span>
<span class="sd">        more likely to behave similarly when their assemblies may have been added in different</span>
<span class="sd">        orders.</span>

<span class="sd">        (In the future this will likely be replaced by sorting the _children list itself internally,</span>
<span class="sd">        as there is still opportunity for inconsistencies.)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or iterable of Flags, optional</span>
<span class="sd">            List of assembly types that will be returned</span>

<span class="sd">        sortKey : callable, optional</span>
<span class="sd">            Sort predicate to use when sorting the assemblies.</span>

<span class="sd">        includeBolAssems : bool, optional</span>
<span class="sd">            Include the BOL assemblies as well as the ones that are in the core.</span>
<span class="sd">            Default: False</span>

<span class="sd">        includeSFP : bool, optional</span>
<span class="sd">            Include assemblies in the SFP</span>

<span class="sd">        includeAll : bool, optional</span>
<span class="sd">            Will include ALL assemblies.</span>

<span class="sd">        zones : iterable, optional</span>
<span class="sd">            Only include assemblies that are in this these zones</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">includeAll</span><span class="p">:</span>
            <span class="n">includeBolAssems</span> <span class="o">=</span> <span class="n">includeSFP</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">assems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">includeBolAssems</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">blueprints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">blueprints</span><span class="o">.</span><span class="n">assemblies</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">assems</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sortKey</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">includeSFP</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">excore</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sfp&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">excore</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">getChildren</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">typeSpec</span><span class="p">:</span>
            <span class="n">assems</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assems</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exact</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">zones</span><span class="p">:</span>
            <span class="n">zoneLocs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zones</span><span class="o">.</span><span class="n">getZoneLocations</span><span class="p">(</span><span class="n">zones</span><span class="p">)</span>
            <span class="n">assems</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assems</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="ow">in</span> <span class="n">zoneLocs</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">assems</span></div>


<div class="viewcode-block" id="Core.getNozzleTypes">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getNozzleTypes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getNozzleTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a dictionary of all of the assembly ``nozzleType``\ s in the core.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nozzles : dict</span>
<span class="sd">            A dictionary of ``{nozzleType: nozzleID}`` pairs, where the nozzleIDs are</span>
<span class="sd">            numbers corresponding to the alphabetical order of the ``nozzleType`` names.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Getting the ``nozzleID`` by alphabetical order could cause a problem if a new</span>
<span class="sd">        ``nozzleType`` is added during a run. This problem should not occur with the</span>
<span class="sd">        ``includeBolAssems=True`` argument provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nozzleList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">nozzleType</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">includeBolAssems</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">nozzleType</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nozzleType</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">nozzleList</span><span class="p">))}</span></div>


<div class="viewcode-block" id="Core.getBlockByName">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getBlockByName">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getBlockByName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">blocks</span><span class="o">.</span><span class="n">Block</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds a block based on its name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Block name e.g. A0001A</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Block : the block with the name</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The blocksByName structure must be up to date for this to work properly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_genBlocksByName</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


<div class="viewcode-block" id="Core.getBlocksByIndices">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getBlocksByIndices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getBlocksByIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">blocks</span><span class="o">.</span><span class="n">Block</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get blocks in assemblies by block indices.&quot;&quot;&quot;</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">assem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assem</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">blocks</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_genBlocksByName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If self.blocksByName is deleted, then this will regenerate it.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span> <span class="o">=</span> <span class="p">{</span><span class="n">block</span><span class="o">.</span><span class="n">getName</span><span class="p">():</span> <span class="n">block</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">includeAll</span><span class="o">=</span><span class="kc">True</span><span class="p">)}</span>

    <span class="c1"># This will likely fail, but it will help diagnose why property approach wasn&#39;t working</span>
    <span class="c1"># correctly</span>
<div class="viewcode-block" id="Core.genBlocksByLocName">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.genBlocksByLocName">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">genBlocksByLocName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If self.blocksByLocName is deleted, then this will regenerate it or update it if things change.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocksByLocName</span> <span class="o">=</span> <span class="p">{</span><span class="n">block</span><span class="o">.</span><span class="n">getLocation</span><span class="p">():</span> <span class="n">block</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">includeAll</span><span class="o">=</span><span class="kc">True</span><span class="p">)}</span></div>


<div class="viewcode-block" id="Core.getBlocks">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getBlocks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getBlocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">blocks</span><span class="o">.</span><span class="n">Block</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all blocks in the reactor in order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bType : list or Flags, optional</span>
<span class="sd">            Restrict results to a specific block type such as Flags.FUEL, Flags.SHIELD, etc.</span>

<span class="sd">        includeBolAssems : bool, optional</span>
<span class="sd">            Include the BOL-Assembly blocks as well. These blocks are created at BOL</span>
<span class="sd">            and used to create new assemblies, etc. If true, the blocks in these</span>
<span class="sd">            assemblies will be returned as well as the ones in the reactor.</span>

<span class="sd">        kwargs : dict</span>
<span class="sd">            Any keyword argument from :meth:`getAssemblies`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        blocks : iterator</span>
<span class="sd">            all blocks in the reactor (or of type requested)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        * :meth:`iterBlocks`: iterator over blocks with limited filtering.</span>
<span class="sd">        * :meth:`getAssemblies` : locates the assemblies in the search</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bType</span><span class="p">:</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">blocks</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">bType</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">blocks</span></div>


<div class="viewcode-block" id="Core.getFirstBlock">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getFirstBlock">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getFirstBlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blockType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">blocks</span><span class="o">.</span><span class="n">Block</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first block of the requested type in the reactor, or return first block.</span>
<span class="sd">        exact=True will only match fuel, not testfuel, for example.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        blockType : Flags, optional</span>
<span class="sd">            The type of block to return</span>

<span class="sd">        exact : bool, optional</span>
<span class="sd">            Requires an exact match on blockType</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        b : Block object (or None if no such block exists)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">blockType</span><span class="p">,</span> <span class="n">exact</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">b</span>

        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Core.getFirstAssembly">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getFirstAssembly">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getFirstAssembly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">assemblies</span><span class="o">.</span><span class="n">Assembly</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the first assembly in the reactor.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        This function should be used with great care. There are **very** few</span>
<span class="sd">        circumstances in which one wants the &quot;first&quot; of a given sort of assembly,</span>
<span class="sd">        `whichever that may happen to be`. Precisely which assembly is returned is</span>
<span class="sd">        sensitive to all sorts of implementation details in Grids, etc., which make the</span>
<span class="sd">        concept of &quot;first&quot; rather slippery. Prefer using some sort of precise logic to</span>
<span class="sd">        pick a specific assembly from the Core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or iterable of Flags, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">typeSpec</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No assem of type </span><span class="si">{0}</span><span class="s2"> in reactor&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Assumes at least one assembly in `self`</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>


<div class="viewcode-block" id="Core.regenAssemblyLists">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.regenAssemblyLists">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">regenAssemblyLists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the attribute lists which contain assemblies are deleted (such as by reactors.detachAllAssemblies),</span>
<span class="sd">        then this function will call the other functions to regrow them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_getAssembliesByName</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_genBlocksByName</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_genChildByLocationLookupTable</span><span class="p">()</span></div>


<div class="viewcode-block" id="Core.getAllXsSuffixes">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getAllXsSuffixes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getAllXsSuffixes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return all XS suffices (e.g. AA, AB, etc.) in the core.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterBlocks</span><span class="p">()))</span></div>


<div class="viewcode-block" id="Core.getNuclideCategories">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getNuclideCategories">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getNuclideCategories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Categorize nuclides as coolant, fuel and structure.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is used to categorize nuclides for Doppler broadening. Control nuclides are treated as structure.</span>

<span class="sd">        The categories are defined in the following way:</span>

<span class="sd">        1. Add nuclides from coolant components to coolantNuclides</span>
<span class="sd">        2. Add nuclides from fuel components to fuelNuclides (this may be incomplete, e.g.</span>
<span class="sd">           at BOL there are no fission products)</span>
<span class="sd">        3. Add nuclides from all other components to structureNuclides</span>
<span class="sd">        4. Since fuelNuclides may be incomplete, add anything else the user wants to model</span>
<span class="sd">           that isn&#39;t already listed in coolantNuclides or structureNuclides.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coolantNuclides : set</span>
<span class="sd">            set of nuclide names</span>

<span class="sd">        fuelNuclides : set</span>
<span class="sd">            set of nuclide names</span>

<span class="sd">        structureNuclides : set</span>
<span class="sd">            set of nuclide names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">:</span>
            <span class="n">coolantNuclides</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">fuelNuclides</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">structureNuclides</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">():</span>
                <span class="n">compNuclides</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># get only nuclides with non-zero number density</span>
                <span class="c1"># nuclides could be present at 0.0 density just for XS generation</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">numberDensities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">nuc</span><span class="p">,</span> <span class="n">dens</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">nuclides</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">numberDensities</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">dens</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">compNuclides</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nuc</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;coolant&quot;</span><span class="p">:</span>
                    <span class="n">coolantNuclides</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">compNuclides</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s2">&quot;fuel&quot;</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">getName</span><span class="p">():</span>
                    <span class="n">fuelNuclides</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">compNuclides</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">structureNuclides</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">compNuclides</span><span class="p">)</span>
            <span class="n">structureNuclides</span> <span class="o">-=</span> <span class="n">coolantNuclides</span>
            <span class="n">structureNuclides</span> <span class="o">-=</span> <span class="n">fuelNuclides</span>
            <span class="n">remainingNuclides</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">blueprints</span><span class="o">.</span><span class="n">allNuclidesInProblem</span><span class="p">)</span> <span class="o">-</span> <span class="n">structureNuclides</span> <span class="o">-</span> <span class="n">coolantNuclides</span>
            <span class="n">fuelNuclides</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">remainingNuclides</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;coolant&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coolantNuclides</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;fuel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fuelNuclides</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">structureNuclides</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summarizeNuclideCategories</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;coolant&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;fuel&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">],</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Core.summarizeNuclideCategories">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.summarizeNuclideCategories">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summarizeNuclideCategories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write summary table of the various nuclide categories within the reactor.&quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Nuclide categorization for cross section temperature assignments:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="n">tabulate</span><span class="o">.</span><span class="n">tabulate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;Fuel&quot;</span><span class="p">,</span>
                        <span class="n">createFormattedStrWithDelimiter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;fuel&quot;</span><span class="p">]),</span>
                    <span class="p">),</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;Coolant&quot;</span><span class="p">,</span>
                        <span class="n">createFormattedStrWithDelimiter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;coolant&quot;</span><span class="p">]),</span>
                    <span class="p">),</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;Structure&quot;</span><span class="p">,</span>
                        <span class="n">createFormattedStrWithDelimiter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">]),</span>
                    <span class="p">),</span>
                <span class="p">],</span>
                <span class="n">headers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Nuclide Category&quot;</span><span class="p">,</span> <span class="s2">&quot;Nuclides&quot;</span><span class="p">],</span>
                <span class="n">tableFmt</span><span class="o">=</span><span class="s2">&quot;armi&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Core.getLocationContents">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getLocationContents">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getLocationContents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locs</span><span class="p">,</span> <span class="n">assemblyLevel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">locContents</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of locations, this goes through and finds the blocks or assemblies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        locs : list of location objects or strings</span>
<span class="sd">            The locations you&#39;d like to find assemblies in</span>
<span class="sd">        assemblyLevel : bool, optional</span>
<span class="sd">            If True, will find assemblies rather than blocks</span>
<span class="sd">        locContents : dict, optional</span>
<span class="sd">            A lookup table with location string keys and block/assembly values</span>
<span class="sd">            useful if you want to call this function many times and would like a speedup.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        blockList : iterable</span>
<span class="sd">            List of blocks or assemblies that correspond to the locations passed in</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Useful in reading the db.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        makeLocationLookup : allows caching to speed this up if you call it a lot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Why isn&#39;t locContents an attribute of reactor? It could be another</span>
        <span class="c1"># property that is generated on demand</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">locContents</span><span class="p">:</span>
            <span class="n">locContents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">makeLocationLookup</span><span class="p">(</span><span class="n">assemblyLevel</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># now look &#39;em up</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">locContents</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">loc</span><span class="p">)]</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">locs</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;There is nothing in core location </span><span class="si">{0}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span></div>


<div class="viewcode-block" id="Core.makeLocationLookup">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.makeLocationLookup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">makeLocationLookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemblyLevel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a location-keyed lookup table to figure out which block (or</span>
<span class="sd">        assembly, if assemblyLevel=True) is in which location. Used within</span>
<span class="sd">        getLocationContents, but can also be used to pre-build a cache for that</span>
<span class="sd">        function, speeding the lookup with a cache.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getLocationContents : can use this lookup table to go faster.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># build a lookup table one time.</span>
        <span class="k">if</span> <span class="n">assemblyLevel</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">():</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">b</span><span class="o">.</span><span class="n">getLocation</span><span class="p">():</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">}</span></div>


<div class="viewcode-block" id="Core.getFluxVector">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getFluxVector">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getFluxVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">energyOrder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">extSrc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">volumeIntegrated</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the multigroup real or adjoint flux of the entire reactor as a vector.</span>

<span class="sd">        Order of meshes is based on getBlocks</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        energyOrder : int, optional</span>
<span class="sd">            A value of 0 implies that the flux will have all energy groups for the first mesh point,</span>
<span class="sd">            and then all energy groups for the next mesh point, etc.</span>

<span class="sd">            A value of 1 implies that the flux will have values for all mesh points of the first</span>
<span class="sd">            energy group first, followed by all mesh points for the second energy group, etc.</span>

<span class="sd">        adjoint : bool, optional</span>
<span class="sd">            If True, will return adjoint flux instead of real flux.</span>

<span class="sd">        extSrc : bool, optional</span>
<span class="sd">            If True, will return external source instead of real flux.</span>

<span class="sd">        volumeIntegrated : bool, optional</span>
<span class="sd">            If true (default), flux units will be #-cm/s. If false, they will be #-cm^2/s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vals : list</span>
<span class="sd">            The values you requested. length is NxG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">numGroups</span><span class="p">)</span>

        <span class="c1"># build in order 0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterBlocks</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">adjoint</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">adjMgFlux</span>
            <span class="k">elif</span> <span class="n">extSrc</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">extSrc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">volumeIntegrated</span><span class="p">:</span>
                <span class="n">vol</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="o">/</span> <span class="n">vol</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">]</span>

            <span class="n">flux</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">energyOrder</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># swap order</span>
            <span class="n">newFlux</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                <span class="n">oneGroup</span> <span class="o">=</span> <span class="p">[</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">))]</span>
                <span class="n">newFlux</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">oneGroup</span><span class="p">)</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">newFlux</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.getAssembliesOfType">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getAssembliesOfType">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getAssembliesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of assemblies in the core that are of type assemType.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="n">exactMatch</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.getAssembly">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getAssembly">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getAssembly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemNum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">locationString</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">assemblyName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds an assembly in the core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        assemNum : int, optional</span>
<span class="sd">            Returns the assembly with this assemNum</span>
<span class="sd">        locationString : str</span>
<span class="sd">            A location string</span>
<span class="sd">        assemblyName : str, optional</span>
<span class="sd">            The assembly name</span>
<span class="sd">        *args : additional optional arguments for self.getAssemblies</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a : Assembly</span>
<span class="sd">            The assembly that matches, or None if nothing is found</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getAssemblyByName</span>
<span class="sd">        getAssemblyWithStringLocation</span>
<span class="sd">        getLocationContents : a much more efficient way to look up assemblies in a list of locations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">assemblyName</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblyByName</span><span class="p">(</span><span class="n">assemblyName</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="o">==</span> <span class="n">locationString</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getNum</span><span class="p">()</span> <span class="o">==</span> <span class="n">assemNum</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span>

        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Core.getAssemblyWithAssemNum">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getAssemblyWithAssemNum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getAssemblyWithAssemNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemNum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve assembly with a particular assembly number from the core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        assemNum : int</span>
<span class="sd">            The assembly number of interest</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        foundAssembly : Assembly object or None</span>
<span class="sd">            The assembly found, or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssembly</span><span class="p">(</span><span class="n">assemNum</span><span class="o">=</span><span class="n">assemNum</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.getAssemblyWithStringLocation">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getAssemblyWithStringLocation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getAssemblyWithStringLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locationString</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an assembly or none if given a location string like &#39;001-001&#39;.</span>

<span class="sd">        .. impl:: Get assembly by location.</span>
<span class="sd">            :id: I_ARMI_R_GET_ASSEM1</span>
<span class="sd">            :implements: R_ARMI_R_GET_ASSEM</span>

<span class="sd">            This method returns the :py:class:`assembly &lt;armi.reactor.core.assemblies.Assembly&gt;`</span>
<span class="sd">            located in the requested location. The location is provided to this method as an input</span>
<span class="sd">            parameter in a string with the format &quot;001-001&quot;. For a :py:class:`HexGrid</span>
<span class="sd">            &lt;armi.reactor.grids.hexagonal.HexGrid&gt;`, the first number indicates the hexagonal ring</span>
<span class="sd">            and the second number indicates the position within that ring. For a</span>
<span class="sd">            :py:class:`CartesianGrid &lt;armi.reactor.grids.cartesian.CartesianGrid&gt;`, the first number</span>
<span class="sd">            represents the x index and the second number represents the y index. If there is no</span>
<span class="sd">            assembly in the grid at the requested location, this method returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">locatorLabelToIndices</span><span class="p">(</span><span class="n">locationString</span><span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getLocatorFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="n">assem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">assem</span></div>


<div class="viewcode-block" id="Core.getAssemblyPitch">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getAssemblyPitch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getAssemblyPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the assembly pitch for the whole core.</span>

<span class="sd">        This returns the pitch according to the spatialGrid. To capture any thermal/hydraulic</span>
<span class="sd">        feedback of the core pitch, T/H modules will need to modify the grid pitch directly based</span>
<span class="sd">        on the relevant mechanical assumptions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pitch : float</span>
<span class="sd">            The assembly pitch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">pitch</span></div>


<div class="viewcode-block" id="Core.findNeighbors">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.findNeighbors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">findNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">showBlanks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">duplicateAssembliesOnReflectiveBoundary</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find assemblies that are next to this assembly.</span>

<span class="sd">        Return a list of neighboring assemblies.</span>

<span class="sd">        For a hexagonal grid, the list begins from the 30 degree point (point 1) then moves</span>
<span class="sd">        counterclockwise around.</span>

<span class="sd">        For a Cartesian grid, the order of the neighbors is east, north, west, south.</span>

<span class="sd">        .. impl:: Retrieve neighboring assemblies of a given assembly.</span>
<span class="sd">            :id: I_ARMI_R_FIND_NEIGHBORS</span>
<span class="sd">            :implements: R_ARMI_R_FIND_NEIGHBORS</span>

<span class="sd">            This method takes an :py:class:`Assembly</span>
<span class="sd">            &lt;armi.reactor.assemblies.Assembly&gt;` as an input parameter and returns</span>
<span class="sd">            a list of the assemblies neighboring that assembly. There are 6</span>
<span class="sd">            neighbors in a hexagonal grid and 4 neighbors in a Cartesian grid.</span>
<span class="sd">            The (i, j) indices of the neighbors are provided by</span>
<span class="sd">            :py:meth:`getNeighboringCellIndices</span>
<span class="sd">            &lt;armi.reactor.grids.StructuredGrid.getNeighboringCellIndices&gt;`. For</span>
<span class="sd">            a hexagonal grid, the (i, j) indices are converted to (ring,</span>
<span class="sd">            position) indexing using the ``core.spatialGrid`` instance attribute.</span>

<span class="sd">            The ``showBlanks`` option determines whether non-existing assemblies</span>
<span class="sd">            will be indicated with a ``None`` in the list or just excluded from</span>
<span class="sd">            the list altogether.</span>

<span class="sd">            The ``duplicateAssembliesOnReflectiveBoundary`` setting only works for</span>
<span class="sd">            1/3 core symmetry with periodic boundary conditions. For these types</span>
<span class="sd">            of geometries, if this setting is ``True``\ , neighbor lists for</span>
<span class="sd">            assemblies along a periodic boundary will include the assemblies</span>
<span class="sd">            along the opposite periodic boundary that are effectively neighbors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : Assembly object</span>
<span class="sd">            The assembly to find neighbors of.</span>

<span class="sd">        showBlanks : Boolean, optional</span>
<span class="sd">            If True, the returned array of 6 neighbors will return &quot;None&quot; for</span>
<span class="sd">            neighbors that do not explicitly exist in the 1/3 core model</span>
<span class="sd">            (including many that WOULD exist in a full core model).</span>

<span class="sd">            If False, the returned array will not include the &quot;None&quot; neighbors.</span>
<span class="sd">            If one or more neighbors does not explicitly exist in the 1/3 core</span>
<span class="sd">            model, the returned array will have a length of less than 6.</span>

<span class="sd">        duplicateAssembliesOnReflectiveBoundary : Boolean, optional</span>
<span class="sd">            If True, findNeighbors duplicates neighbor assemblies into their</span>
<span class="sd">            &quot;symmetric identicals&quot; so that even assemblies that border symmetry</span>
<span class="sd">            lines will have 6 neighbors. The only assemblies that will have</span>
<span class="sd">            fewer than 6 neighbors are those that border the outer core boundary</span>
<span class="sd">            (usually vacuum).</span>

<span class="sd">            If False, findNeighbors returns None for assemblies that do not</span>
<span class="sd">            exist in a 1/3 core model (but WOULD exist in a full core model).</span>

<span class="sd">            For example, applying findNeighbors for the central assembly (ring,</span>
<span class="sd">            pos) = (1, 1) in 1/3 core symmetry (with</span>
<span class="sd">            duplicateAssembliesOnReflectiveBoundary = True) would return a list</span>
<span class="sd">            of 6 assemblies, but those 6 would really only be assemblies (2, 1)</span>
<span class="sd">            and (2, 2) repeated 3 times each.</span>

<span class="sd">            Note that the value of duplicateAssembliesOnReflectiveBoundary only</span>
<span class="sd">            really matters if showBlanks == True. This will have no effect if</span>
<span class="sd">            the model is full core since asymmetric models could find many</span>
<span class="sd">            duplicates in the other thirds</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The duplicateAssembliesOnReflectiveBoundary setting only works for third</span>
<span class="sd">        core symmetry.</span>

<span class="sd">        This uses the &#39;mcnp&#39; index map (MCNP GEODST hex coordinates) instead of</span>
<span class="sd">        the standard (ring, pos) map. because neighbors have consistent indices</span>
<span class="sd">        this way. We then convert over to (ring, pos) using the lookup table</span>
<span class="sd">        that a reactor has.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        neighbors : list of assembly objects</span>
<span class="sd">            This is a list of &quot;nearest neighbors&quot; to assembly a.</span>

<span class="sd">            If showBlanks = False, it will return fewer than the maximum number</span>
<span class="sd">            of neighbors if not all neighbors explicitly exist in the core</span>
<span class="sd">            model. For a hexagonal grid, the maximum number of neighbors is 6.</span>
<span class="sd">            For a Cartesian grid, the maximum number is 4.</span>

<span class="sd">            If showBlanks = True and duplicateAssembliesOnReflectiveBoundary =</span>
<span class="sd">            False, it will have a &quot;None&quot; for assemblies that do not exist in the</span>
<span class="sd">            1/3 model.</span>

<span class="sd">            If showBlanks = True and duplicateAssembliesOnReflectiveBoundary =</span>
<span class="sd">            True, it will return the existing &quot;symmetric identical&quot; assembly of</span>
<span class="sd">            a non-existing assembly. It will only return &quot;None&quot; for an assembly</span>
<span class="sd">            when that assembly is non-existing AND has no existing &quot;symmetric</span>
<span class="sd">            identical&quot;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        grids.Grid.getSymmetricEquivalents</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">neighborIndices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getNeighboringCellIndices</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">())</span>

        <span class="n">dupReflectors</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">THIRD_CORE</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">boundary</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">PERIODIC</span>
            <span class="ow">and</span> <span class="n">duplicateAssembliesOnReflectiveBoundary</span>
        <span class="p">)</span>

        <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iN</span><span class="p">,</span> <span class="n">jN</span><span class="p">,</span> <span class="n">kN</span> <span class="ow">in</span> <span class="n">neighborIndices</span><span class="p">:</span>
            <span class="n">neighborLoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="n">iN</span><span class="p">,</span> <span class="n">jN</span><span class="p">,</span> <span class="n">kN</span><span class="p">]</span>
            <span class="n">neighbor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">neighborLoc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">showBlanks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dupReflectors</span><span class="p">:</span>
                    <span class="n">symmetricAssem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getReflectiveDuplicateAssembly</span><span class="p">(</span><span class="n">neighborLoc</span><span class="p">)</span>
                    <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symmetricAssem</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">neighbors</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_getReflectiveDuplicateAssembly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neighborLoc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return duplicate assemblies across symmetry line.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If an existing symmetric identical has been found, return it.</span>
<span class="sd">        If an existing symmetric identical has NOT been found, return a None (it&#39;s empty).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">otherTwoLocations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getSymmetricEquivalents</span><span class="p">(</span><span class="n">neighborLoc</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">otherTwoLocations</span><span class="p">:</span>
            <span class="n">neighborLocation2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">duplicateAssem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">neighborLocation2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">duplicateAssem</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">duplicates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">duplicateAssem</span><span class="p">)</span>

        <span class="c1"># should always be 0 or 1</span>
        <span class="n">nDuplicates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicates</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nDuplicates</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">duplicates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">nDuplicates</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too many neighbors found!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="Core.setMoveList">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.setMoveList">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setMoveList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">oldLoc</span><span class="p">,</span> <span class="n">newLoc</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="n">assemblyType</span><span class="p">,</span> <span class="n">assemName</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tracks the movements in terms of locations and enrichments.&quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">armi.physics.fuelCycle.fuelHandlers</span><span class="w"> </span><span class="kn">import</span> <span class="n">AssemblyMove</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">AssemblyMove</span><span class="p">(</span><span class="n">oldLoc</span><span class="p">,</span> <span class="n">newLoc</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="n">assemblyType</span><span class="p">,</span> <span class="n">assemName</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]:</span>
            <span class="c1"># remove the old version and throw the new one at the end.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.createFreshFeed">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.createFreshFeed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">createFreshFeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new feed assembly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cs : Settings</span>
<span class="sd">            Global settings for the case</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        createAssemblyOfType: creates an assembly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">createAssemblyOfType</span><span class="p">(</span><span class="n">assemType</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_freshFeedType</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.createAssemblyOfType">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.createAssemblyOfType">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">createAssemblyOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enrichList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an assembly of a specific type and apply enrichments if they are specified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        assemType : str</span>
<span class="sd">            The assembly type to create</span>
<span class="sd">        enrichList : list</span>
<span class="sd">            weight percent enrichments of each block</span>
<span class="sd">        cs : Settings</span>
<span class="sd">            Global settings for the case</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a : Assembly</span>
<span class="sd">            A new assembly</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This and similar fuel shuffle-enabling functionality on the Core are responsible</span>
<span class="sd">        for coupling between the Core and Blueprints. Technically, it should not be</span>
<span class="sd">        required to involve Blueprints at all in the construction of a Reactor model.</span>
<span class="sd">        Therefore in some circumstances, this function will not work. Ultimately, this</span>
<span class="sd">        should be purely the domain of blueprints themselves, and may be migrated out of</span>
<span class="sd">        Core in the future.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.fuelHandler.doRepeatShuffle : uses this to repeat shuffling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">blueprints</span><span class="o">.</span><span class="n">constructAssem</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">assemType</span><span class="p">)</span>

        <span class="c1"># check to see if a default bol assembly is being used or we are adding more information</span>
        <span class="k">if</span> <span class="n">enrichList</span><span class="p">:</span>
            <span class="c1"># got an enrichment list that should be the same height as the fuel blocks</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">enrichList</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="c1"># make endlessly iterable if float was passed in</span>
                <span class="n">enrichList</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">([</span><span class="n">enrichList</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">enrichList</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> and enrichment list do not have the same number of blocks.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">enrich</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">enrich</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="c1"># don&#39;t change blocks when enrich specified as 0</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">getUraniumMassEnrich</span><span class="p">()</span> <span class="o">-</span> <span class="n">enrich</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                    <span class="c1"># only adjust block enrichment if it&#39;s different.</span>
                    <span class="c1"># WARNING: If this is not fresh fuel, this messes up the number of moles of HM at BOL and</span>
                    <span class="c1"># therefore breaks the burnup metric.</span>
                    <span class="n">b</span><span class="o">.</span><span class="n">adjustUEnrich</span><span class="p">(</span><span class="n">enrich</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detailedAxialExpansion</span><span class="p">:</span>
            <span class="c1"># if detailedAxialExpansion: False, make sure that the assembly being created has the correct core mesh</span>
            <span class="n">a</span><span class="o">.</span><span class="n">setBlockMesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">referenceBlockAxialMesh</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">conserveMassFlag</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">)</span>  <span class="c1"># pass [1:] to skip 0.0</span>

        <span class="k">return</span> <span class="n">a</span></div>


<div class="viewcode-block" id="Core.saveAllFlux">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.saveAllFlux">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">saveAllFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fName</span><span class="o">=</span><span class="s2">&quot;allFlux.txt&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dump all flux to file for debugging purposes.&quot;&quot;&quot;</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">numGroups</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fName</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterBlocks</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">gi</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{:10s}</span><span class="s2"> </span><span class="si">{:10d}</span><span class="s2"> </span><span class="si">{:12.5E}</span><span class="s2"> </span><span class="si">{:12.5E}</span><span class="s2"> </span><span class="si">{:12.5E}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">block</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span>
                            <span class="n">gi</span><span class="p">,</span>
                            <span class="n">block</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span><span class="p">[</span><span class="n">gi</span><span class="p">],</span>
                            <span class="n">block</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">adjMgFlux</span><span class="p">[</span><span class="n">gi</span><span class="p">],</span>
                            <span class="n">block</span><span class="o">.</span><span class="n">getVolume</span><span class="p">(),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">adjMgFlux</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Too many flux values: </span><span class="si">{}</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">adjMgFlux</span><span class="p">)</span>
                    <span class="p">)</span></div>


<div class="viewcode-block" id="Core.getAssembliesOnSymmetryLine">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getAssembliesOnSymmetryLine">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getAssembliesOnSymmetryLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symmetryLineID</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find assemblies that are on a symmetry line in a symmetric core.&quot;&quot;&quot;</span>
        <span class="n">assembliesOnLine</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">isOnWhichSymmetryLine</span><span class="p">()</span> <span class="o">==</span> <span class="n">symmetryLineID</span><span class="p">:</span>
                <span class="n">assembliesOnLine</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="c1"># in order of innermost to outermost (for averaging)</span>
        <span class="n">assembliesOnLine</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">assembliesOnLine</span></div>


<div class="viewcode-block" id="Core.getCoreRadius">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getCoreRadius">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getCoreRadius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a radius that the core would fit into.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumRings</span><span class="p">(</span><span class="n">indexBased</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFirstBlock</span><span class="p">()</span><span class="o">.</span><span class="n">getPitch</span><span class="p">()</span></div>


<div class="viewcode-block" id="Core.findAllMeshPoints">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.findAllMeshPoints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">findAllMeshPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all mesh positions in core including both endpoints.</span>

<span class="sd">        .. impl:: Construct a mesh based on core blocks.</span>
<span class="sd">            :id: I_ARMI_R_MESH</span>
<span class="sd">            :implements: R_ARMI_R_MESH</span>

<span class="sd">            This method iterates through all of the assemblies provided, or all</span>
<span class="sd">            assemblies in the core if no list of ``assems`` is provided, and</span>
<span class="sd">            constructs a tuple of three lists which contain the unique i, j, and</span>
<span class="sd">            k mesh coordinates, respectively. The ``applySubMesh`` setting</span>
<span class="sd">            controls whether the mesh will include the submesh coordinates. For</span>
<span class="sd">            a standard assembly-based reactor geometry with a hexagonal or</span>
<span class="sd">            Cartesian assembly grid, this method is only used to produce axial</span>
<span class="sd">            (k) mesh points. If multiple assemblies are provided with different</span>
<span class="sd">            axial meshes, the axial mesh list will contain the union of all</span>
<span class="sd">            unique mesh points. Duplicate mesh points are removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        assems : list, optional</span>
<span class="sd">            assemblies to consider when determining the mesh points. If not given, all in-core assemblies are used.</span>
<span class="sd">        applySubMesh : bool, optional</span>
<span class="sd">            Apply submeshing parameters to make mesh points smaller than blocks. Default=True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        meshVals : tuple</span>
<span class="sd">            ((i-vals), (j-vals,), (k-vals,))</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.assemblies.Assembly.getAxialMesh : get block mesh</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        These include all mesh points, not just block boundaries. There may be multiple mesh points</span>
<span class="sd">        per block.</span>

<span class="sd">        If a large block with multiple mesh points is in the same core as arbitrarily-expanded fuel blocks</span>
<span class="sd">        from fuel performance, an imbalanced axial mesh may result.</span>

<span class="sd">        There is a challenge with TRZ blocks because we need the mesh centroid in terms of RZT, not XYZ</span>

<span class="sd">        When determining the submesh, it is important to not use too small of a rounding precision. It was</span>
<span class="sd">        found that when using a precision of units.FLOAT_DIMENSION_DECIMALS, that the division in `step`</span>
<span class="sd">        can produce mesh points that are the same up to the 9th or 10th digit, resulting in a repeated</span>
<span class="sd">        mesh point. This repetition results in problems in downstream methods, such as the uniform mesh converter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Finding all mesh points.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">assems</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">assems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">iMesh</span><span class="p">,</span> <span class="n">jMesh</span><span class="p">,</span> <span class="n">kMesh</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assems</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                <span class="c1"># these params should be combined into a new b.p.meshSubdivisions tuple</span>
                <span class="n">numPoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">AziMesh</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">RadMesh</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axMesh</span><span class="p">)</span> <span class="k">if</span> <span class="n">applySubMesh</span> <span class="k">else</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCellBase</span><span class="p">()</span>
                <span class="c1"># make sure this is in mesh coordinates (important to have TRZ, not XYZ in TRZ cases</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCellTop</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">subdivisions</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">((</span><span class="n">iMesh</span><span class="p">,</span> <span class="n">jMesh</span><span class="p">,</span> <span class="n">kMesh</span><span class="p">),</span> <span class="n">numPoints</span><span class="p">)):</span>
                    <span class="n">axisVal</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>  <span class="c1"># convert from np.float64</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">top</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">axisVal</span><span class="p">)</span> <span class="o">/</span> <span class="n">subdivisions</span>
                    <span class="k">for</span> <span class="n">_subdivision</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subdivisions</span><span class="p">):</span>
                        <span class="n">collection</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">axisVal</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">FLOAT_DIMENSION_DECIMALS</span><span class="p">))</span>
                        <span class="n">axisVal</span> <span class="o">+=</span> <span class="n">step</span>
                    <span class="c1"># add top too (only needed for last point)</span>
                    <span class="n">collection</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">axisVal</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">FLOAT_DIMENSION_DECIMALS</span><span class="p">))</span>

        <span class="n">iMesh</span><span class="p">,</span> <span class="n">jMesh</span><span class="p">,</span> <span class="n">kMesh</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">sorted</span><span class="p">,</span> <span class="p">(</span><span class="n">iMesh</span><span class="p">,</span> <span class="n">jMesh</span><span class="p">,</span> <span class="n">kMesh</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">iMesh</span><span class="p">,</span> <span class="n">jMesh</span><span class="p">,</span> <span class="n">kMesh</span></div>


<div class="viewcode-block" id="Core.findAllAxialMeshPoints">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.findAllAxialMeshPoints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">findAllAxialMeshPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of all z-mesh positions in the core including zero and the top.&quot;&quot;&quot;</span>
        <span class="n">_i</span><span class="p">,</span> <span class="n">_j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findAllMeshPoints</span><span class="p">(</span><span class="n">assems</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">k</span></div>


<div class="viewcode-block" id="Core.updateAxialMesh">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.updateAxialMesh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">updateAxialMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update axial mesh based on perturbed meshes of the assemblies that are linked to the ref assem.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        While processLoading finds *all* axial mesh points, this method only updates the values of the</span>
<span class="sd">        known mesh with the current assembly heights. **This does not change the number of mesh points**.</span>

<span class="sd">        If ``detailedAxialExpansion`` is active, the global axial mesh param still only tracks the refAssem.</span>
<span class="sd">        Otherwise, thousands upon thousands of mesh points would get created.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        processLoading : sets up the primary mesh that this perturbs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># most of the time, we want fuel, but they should mostly have the same number of blocks</span>
        <span class="c1"># if this becomes a problem, we might find either the</span>
        <span class="c1">#  1. mode: (len(a) for a in self).mode(), or</span>
        <span class="c1">#  2. max: max(len(a) for a in self)</span>
        <span class="c1"># depending on what makes the most sense</span>
        <span class="n">refAssem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refAssem</span>
        <span class="n">refMesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findAllAxialMeshPoints</span><span class="p">([</span><span class="n">refAssem</span><span class="p">])</span>
        <span class="n">avgHeight</span> <span class="o">=</span> <span class="n">average1DWithinTolerance</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">[</span><span class="n">h</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">zbottom</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axMesh</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axMesh</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">findAllAxialMeshPoints</span><span class="p">([</span><span class="n">a</span><span class="p">])</span> <span class="o">==</span> <span class="n">refMesh</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axialMesh</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">avgHeight</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()))</span></div>


<div class="viewcode-block" id="Core.findAxialMeshIndexOf">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.findAxialMeshIndexOf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">findAxialMeshIndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heightCm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the axial index of the axial node corresponding to this height.</span>

<span class="sd">        If the height lies on the boundary between two nodes, the lower node index</span>
<span class="sd">        is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        heightCm : float</span>
<span class="sd">            The height (cm) from the assembly bottom.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        zIndex : int</span>
<span class="sd">            The axial index (beginning with 0) of the mesh node containing the given height.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">zi</span><span class="p">,</span> <span class="n">currentHeightCm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axialMesh</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="k">if</span> <span class="n">currentHeightCm</span> <span class="o">&gt;=</span> <span class="n">heightCm</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">zi</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The value </span><span class="si">{}</span><span class="s2"> cm is not within range of the reactor axial mesh with max </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">heightCm</span><span class="p">,</span> <span class="n">currentHeightCm</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Core.addMoreNodes">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.addMoreNodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">addMoreNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meshList</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add additional mesh points in the the meshList so that the ratio of mesh sizes does not vary too fast.&quot;&quot;&quot;</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minMeshSizeRatio</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">innerMeshVal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meshList</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dP0</span> <span class="o">=</span> <span class="n">innerMeshVal</span> <span class="o">-</span> <span class="n">meshList</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">dP1</span> <span class="o">=</span> <span class="n">meshList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">innerMeshVal</span>

            <span class="k">if</span> <span class="n">dP0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dP0</span> <span class="o">+</span> <span class="n">dP1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ratio</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Mesh gap too small. Adjusting mesh to be more reasonable.&quot;</span><span class="p">)</span>
                <span class="n">meshList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">innerMeshVal</span> <span class="o">+</span> <span class="n">dP1</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">)</span>
                <span class="n">meshList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">meshList</span><span class="p">,</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">dP0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dP0</span> <span class="o">+</span> <span class="n">dP1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">ratio</span><span class="p">):</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Mesh gap too large. Adjusting mesh to be more reasonable.&quot;</span><span class="p">)</span>
                <span class="n">meshList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meshList</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dP0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">ratio</span><span class="p">))</span>
                <span class="n">meshList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">meshList</span><span class="p">,</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">meshList</span><span class="p">,</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Core.findAllAziMeshPoints">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.findAllAziMeshPoints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">findAllAziMeshPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extraAssems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of all azimuthal (theta)-mesh positions in the core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extraAssems : list</span>
<span class="sd">            additional assemblies to consider when determining the mesh points.</span>
<span class="sd">            They may be useful in the MCPNXT models to represent the fuel management dummies.</span>

<span class="sd">        applySubMesh : bool</span>
<span class="sd">            generates submesh points to further discretize the theta reactor mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findAllMeshPoints</span><span class="p">(</span><span class="n">extraAssems</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">i</span></div>


<div class="viewcode-block" id="Core.findAllRadMeshPoints">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.findAllRadMeshPoints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">findAllRadMeshPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extraAssems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of all radial-mesh positions in the core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extraAssems : list</span>
<span class="sd">            additional assemblies to consider when determining the mesh points. They may be useful</span>
<span class="sd">            in the MCPNXT models to represent the fuel management dummies.</span>

<span class="sd">        applySubMesh : bool</span>
<span class="sd">            (not implemented) generates submesh points to further discretize the radial reactor mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findAllMeshPoints</span><span class="p">(</span><span class="n">extraAssems</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">j</span></div>


<div class="viewcode-block" id="Core.getMaxBlockParam">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getMaxBlockParam">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getMaxBlockParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get max param over blocks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;generationNum&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot getMaxBlockParam over anything but blocks. Prefer `getMaxParam`.&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;generationNum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxParam</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.getTotalBlockParam">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getTotalBlockParam">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getTotalBlockParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get total param over blocks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;generationNum&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot getTotalBlockParam over anything but blocks. Prefer `calcTotalParam`.&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;generationNum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcTotalParam</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.getMaxNumPins">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getMaxNumPins">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getMaxNumPins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find max number of pins of any block in the reactor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterBlocks</span><span class="p">())</span></div>


<div class="viewcode-block" id="Core.getMinimumPercentFluxInFuel">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getMinimumPercentFluxInFuel">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getMinimumPercentFluxInFuel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mf">0.005</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starting with the outer ring, this method goes through the entire Reactor to determine what</span>
<span class="sd">        percentage of flux occurs at each ring.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : float</span>
<span class="sd">            This is the fraction of the total reactor fuel flux compared to the flux in a specific</span>
<span class="sd">            assembly in a ring</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        targetRing, fraction of flux : tuple</span>
<span class="sd">            targetRing is the ring with the fraction of flux that best meets the target.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the total number of assembly rings</span>
        <span class="n">numRings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumRings</span><span class="p">()</span>

        <span class="c1"># old target assembly fraction</span>
        <span class="n">fluxFraction</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">targetRing</span> <span class="o">=</span> <span class="n">numRings</span>

        <span class="n">allFuelBlocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>

        <span class="c1"># loop there all of the rings</span>
        <span class="k">for</span> <span class="n">ringNumber</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numRings</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Compare to outer most ring. flatten list into one list of all blocks</span>
            <span class="n">blocksInRing</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">iterBlocks</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssembliesInRing</span><span class="p">(</span><span class="n">ringNumber</span><span class="p">)])</span>
            <span class="p">)</span>

            <span class="n">totalPower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTotalBlockParam</span><span class="p">(</span><span class="s2">&quot;flux&quot;</span><span class="p">,</span> <span class="n">objs</span><span class="o">=</span><span class="n">allFuelBlocks</span><span class="p">)</span>
            <span class="n">ringPower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTotalBlockParam</span><span class="p">(</span><span class="s2">&quot;flux&quot;</span><span class="p">,</span> <span class="n">objs</span><span class="o">=</span><span class="n">blocksInRing</span><span class="p">)</span>

            <span class="c1"># make sure that there is a non zero return</span>
            <span class="k">if</span> <span class="n">fluxFraction</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ringPower</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fluxFraction</span> <span class="o">=</span> <span class="n">ringPower</span> <span class="o">/</span> <span class="n">totalPower</span>
                <span class="n">targetRing</span> <span class="o">=</span> <span class="n">ringNumber</span>

            <span class="c1"># this will only get the leakage if the target fraction isn&#39;t too low</span>
            <span class="k">if</span> <span class="n">ringPower</span> <span class="o">/</span> <span class="n">totalPower</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="ow">and</span> <span class="n">ringPower</span> <span class="o">/</span> <span class="n">totalPower</span> <span class="o">&gt;</span> <span class="n">fluxFraction</span><span class="p">:</span>
                <span class="n">fluxFraction</span> <span class="o">=</span> <span class="n">ringPower</span> <span class="o">/</span> <span class="n">totalPower</span>
                <span class="n">targetRing</span> <span class="o">=</span> <span class="n">ringNumber</span>

        <span class="k">return</span> <span class="n">targetRing</span><span class="p">,</span> <span class="n">fluxFraction</span></div>


<div class="viewcode-block" id="Core.getAvgTemp">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getAvgTemp">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getAvgTemp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">blockList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flux2Weight</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the volume-average fuel, cladding, coolant temperature in core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or list of Flags</span>
<span class="sd">            Component types to consider. If typeSpec is a list, then you get the volume average</span>
<span class="sd">            temperature of all components. For instance, getAvgTemp([Flags.CLAD, Flags.WIRE,</span>
<span class="sd">            Flags.DUCT]) returns the avg. structure temperature.</span>

<span class="sd">        blockList : list, optional</span>
<span class="sd">            Blocks to consider. If None, all blocks in core will be considered</span>

<span class="sd">        flux2Weight : bool, optional</span>
<span class="sd">            If true, will weight temperature against flux**2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        avgTemp : float</span>
<span class="sd">            The average temperature in C.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">blockList</span><span class="p">:</span>
            <span class="n">blockList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">blockList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flux2Weight</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flux</span><span class="o">**</span><span class="mf">2.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">):</span>
                <span class="n">vol</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>
                <span class="n">num</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">temperatureInC</span> <span class="o">*</span> <span class="n">vol</span> <span class="o">*</span> <span class="n">weight</span>
                <span class="n">denom</span> <span class="o">+=</span> <span class="n">vol</span> <span class="o">*</span> <span class="n">weight</span>

        <span class="k">if</span> <span class="n">denom</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;no temperature average for </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">))</span></div>


<div class="viewcode-block" id="Core.growToFullCore">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.growToFullCore">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">growToFullCore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copies symmetric assemblies to build a full core model out of a 1/3 core model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        converter : GeometryConverter</span>
<span class="sd">            Geometry converter used to do the conversion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.converters.geometryConverters</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
            <span class="n">ThirdCoreHexToFullCoreChanger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">converter</span> <span class="o">=</span> <span class="n">ThirdCoreHexToFullCoreChanger</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="n">converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">converter</span></div>


<div class="viewcode-block" id="Core.setPitchUniform">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.setPitchUniform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setPitchUniform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pitchInCm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the pitch in all blocks.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterBlocks</span><span class="p">():</span>
            <span class="n">b</span><span class="o">.</span><span class="n">setPitch</span><span class="p">(</span><span class="n">pitchInCm</span><span class="p">)</span>

        <span class="c1"># have to update the 2-D reactor mesh too.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">changePitch</span><span class="p">(</span><span class="n">pitchInCm</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.calcBlockMaxes">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.calcBlockMaxes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calcBlockMaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Searches all blocks for maximum values of key params.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.physics.optimize.OptimizationInterface.interactBOL : handles these maxes in optimization cases</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># restrict to fuel</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="o">.</span><span class="n">inCategory</span><span class="p">(</span><span class="s2">&quot;block-max&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">maxVal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxBlockParam</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">maxVal</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxVal</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">continue</span>

        <span class="c1"># add maxes based on pin-level max if it exists, block level max otherwise.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">maxBuF</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">getMaxParam</span><span class="p">(</span><span class="s2">&quot;percentBu&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FEED</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)),</span>
            <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">maxBuI</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">a</span><span class="o">.</span><span class="n">getMaxParam</span><span class="p">(</span><span class="s2">&quot;percentBu&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">Flags</span><span class="o">.</span><span class="n">IGNITER</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span>
                        <span class="n">Flags</span><span class="o">.</span><span class="n">DRIVER</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span>
                        <span class="n">Flags</span><span class="o">.</span><span class="n">STARTER</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">),</span>
            <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Core.getFuelBottomHeight">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.getFuelBottomHeight">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getFuelBottomHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain the height of the lowest fuel in the core.</span>

<span class="sd">        This is the &quot;axial coordinate shift&quot; between ARMI and SASSYS.</span>
<span class="sd">        While ARMI sets z=0 at the bottom of the lowest block (usually the</span>
<span class="sd">        grid plate), SASSYS sets z=0 at the bottom of the fuel.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lowestFuelHeightInCm : float</span>
<span class="sd">            The height (cm) of the lowest fuel in this core model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lowestFuelHeightInCm</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
        <span class="n">fuelBottoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">):</span>
            <span class="n">fuelHeightInCm</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fuelHeightInCm</span> <span class="o">+=</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">fuelHeightInCm</span> <span class="o">&lt;</span> <span class="n">lowestFuelHeightInCm</span><span class="p">:</span>
                <span class="n">lowestFuelHeightInCm</span> <span class="o">=</span> <span class="n">fuelHeightInCm</span>
            <span class="n">fuelBottoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fuelHeightInCm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lowestFuelHeightInCm</span></div>


<div class="viewcode-block" id="Core.processLoading">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.processLoading">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">processLoading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">dbLoad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        After nuclide densities are loaded, this goes through and prepares the reactor.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This does a few operations :</span>
<span class="sd">         * It process boosters,</span>
<span class="sd">         * sets axial snap lists,</span>
<span class="sd">         * checks the geometry,</span>
<span class="sd">         * sets up location tables (tracks where the initial feeds were (for moderation or something)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        updateAxialMesh : Perturbs the axial mesh originally set up here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setOptionsFromCs</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">header</span><span class="p">(</span><span class="s2">&quot;=========== Initializing Mesh, Assembly Zones, and Nuclide Categories =========== &quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterBlocks</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOL</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Good easter egg, but sometimes a user will want to use the framework do</span>
            <span class="c1"># only decay analyses and heavy metals are not required.</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;The system has no heavy metal and therefore is not a nuclear reactor.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Please make sure that this is intended and not a input error.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">dbLoad</span><span class="p">:</span>
            <span class="c1"># reactor.blueprints.assemblies need to be populated this normally happens during</span>
            <span class="c1"># blueprint constructAssem. But for DB load, this is not called so it must be here.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">blueprints</span><span class="o">.</span><span class="n">_prepConstruction</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># set reactor level meshing params</span>
            <span class="n">nonUniformAssems</span> <span class="o">=</span> <span class="p">[</span><span class="n">Flags</span><span class="o">.</span><span class="n">fromStringIgnoreErrors</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">[</span><span class="n">CONF_NON_UNIFORM_ASSEM_FLAGS</span><span class="p">]]</span>
            <span class="c1"># Some assemblies, like control assemblies, have a non-conforming mesh and should not be</span>
            <span class="c1"># included in self.p.referenceBlockAxialMesh and self.p.axialMesh</span>
            <span class="n">uniformAssems</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">nonUniformAssems</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">referenceBlockAxialMesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findAllAxialMeshPoints</span><span class="p">(</span>
                <span class="n">assems</span><span class="o">=</span><span class="n">uniformAssems</span><span class="p">,</span>
                <span class="n">applySubMesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axialMesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findAllAxialMeshPoints</span><span class="p">(</span>
                <span class="n">assems</span><span class="o">=</span><span class="n">uniformAssems</span><span class="p">,</span>
                <span class="n">applySubMesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">getNuclideCategories</span><span class="p">()</span>

        <span class="c1"># Generate list of flags that are to be stationary during assembly shuffling</span>
        <span class="n">stationaryBlockFlags</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">stationaryBlockFlagString</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">[</span><span class="n">CONF_STATIONARY_BLOCK_FLAGS</span><span class="p">]:</span>
            <span class="n">stationaryBlockFlags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">fromString</span><span class="p">(</span><span class="n">stationaryBlockFlagString</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stationaryBlockFlagsList</span> <span class="o">=</span> <span class="n">stationaryBlockFlags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setBlockMassParams</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">maxAssemNum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxParam</span><span class="p">(</span><span class="s2">&quot;assemNum&quot;</span><span class="p">)</span>

        <span class="n">getPluginManagerOrFail</span><span class="p">()</span><span class="o">.</span><span class="n">hook</span><span class="o">.</span><span class="n">onProcessCoreLoading</span><span class="p">(</span><span class="n">core</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="n">cs</span><span class="p">,</span> <span class="n">dbLoad</span><span class="o">=</span><span class="n">dbLoad</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.buildManualZones">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.buildManualZones">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">buildManualZones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the Zones that are defined in the given Settings, in the `zoneDefinitions` or `zonesFile` case setting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cs : Settings</span>
<span class="sd">            The standard ARMI settings object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Manual zones will be defined in a special string format, e.g.:</span>

<span class="sd">        &gt;&gt;&gt; zoneDefinitions:</span>
<span class="sd">        &gt;&gt;&gt;     - &quot;ring-1: 001-001&quot;</span>
<span class="sd">        &gt;&gt;&gt;     - &quot;ring-2: 002-001, 002-002&quot;</span>
<span class="sd">        &gt;&gt;&gt;     - &quot;ring-3: 003-001, 003-002, 003-003&quot;</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function will just define the Zones it sees in the settings, it does not do any validation against a Core</span>
<span class="sd">        object to ensure those manual zones make sense.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cs</span><span class="p">[</span><span class="n">CONF_ZONE_DEFINITIONS</span><span class="p">]:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Building Zones by manual definitions in </span><span class="si">{</span><span class="n">CONF_ZONE_DEFINITIONS</span><span class="si">}</span><span class="s2"> setting&quot;</span><span class="p">)</span>

            <span class="n">stripper</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zones</span> <span class="o">=</span> <span class="n">zones</span><span class="o">.</span><span class="n">Zones</span><span class="p">()</span>

            <span class="c1"># parse the special input string for zone definitions</span>
            <span class="k">for</span> <span class="n">zoneString</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">[</span><span class="n">CONF_ZONE_DEFINITIONS</span><span class="p">]:</span>
                <span class="n">zoneName</span><span class="p">,</span> <span class="n">zoneLocs</span> <span class="o">=</span> <span class="n">zoneString</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
                <span class="n">zoneLocs</span> <span class="o">=</span> <span class="n">zoneLocs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
                <span class="n">zone</span> <span class="o">=</span> <span class="n">zones</span><span class="o">.</span><span class="n">Zone</span><span class="p">(</span><span class="n">zoneName</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                <span class="n">zone</span><span class="o">.</span><span class="n">addLocs</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">stripper</span><span class="p">,</span> <span class="n">zoneLocs</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">zones</span><span class="o">.</span><span class="n">addZone</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">cs</span><span class="p">[</span><span class="n">CONF_ZONES_FILE</span><span class="p">]:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Custom zoning strategy applied from </span><span class="si">{</span><span class="n">CONF_ZONES_FILE</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">zones</span> <span class="o">=</span> <span class="n">Zones</span><span class="p">()</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_ZONES_FILE</span><span class="p">])</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
                <span class="n">zonesDict</span> <span class="o">=</span> <span class="n">YAML</span><span class="p">(</span><span class="n">typ</span><span class="o">=</span><span class="s2">&quot;safe&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">location</span><span class="p">,</span> <span class="n">zoneName</span> <span class="ow">in</span> <span class="n">zonesDict</span><span class="p">[</span><span class="s2">&quot;customZonesMap&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># if the the zoneName isn&#39;t already a Zones key, then add a new Zone</span>
                <span class="k">if</span> <span class="n">zoneName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">zones</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">zones</span><span class="o">.</span><span class="n">addZone</span><span class="p">(</span><span class="n">Zone</span><span class="p">(</span><span class="n">zoneName</span><span class="p">,</span> <span class="p">[</span><span class="n">location</span><span class="p">]))</span>
                <span class="c1"># if the zoneName is already a Zones key, then add the location to the existing Zone</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">zones</span><span class="p">[</span><span class="n">zoneName</span><span class="p">]</span><span class="o">.</span><span class="n">addLoc</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>

            <span class="c1"># sort the Zones</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zones</span><span class="o">.</span><span class="n">sortZones</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No zones defined in either </span><span class="si">{</span><span class="n">CONF_ZONE_DEFINITIONS</span><span class="si">}</span><span class="s2"> or </span><span class="si">{</span><span class="n">CONF_ZONES_FILE</span><span class="si">}</span><span class="s2"> settings&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Core.iterBlocks">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.cores.html#armi.reactor.cores.Core.iterBlocks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iterBlocks</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">typeSpec</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">flags</span><span class="o">.</span><span class="n">TypeSpec</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">predicate</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">blocks</span><span class="o">.</span><span class="n">Block</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">blocks</span><span class="o">.</span><span class="n">Block</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over the blocks in the core.</span>

<span class="sd">        Useful for operations that just want to find all the blocks in the core with light filtering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec: armi.reactor.flags.TypeSpec, optional</span>
<span class="sd">            Limit the traversal to blocks that have these flags.</span>
<span class="sd">        exact: bool, optional</span>
<span class="sd">            Strictness on the usage of ``typeSpec`` used in :meth:`armi.reactor.composites.hasFlags`</span>
<span class="sd">        predicate: f(block) -&gt; bool, optional</span>
<span class="sd">            Limit the traversal to blocks that pass this predicate. Can be used in addition to</span>
<span class="sd">            ``typeSpec`` to perform more advanced filtering.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iterator[Block]</span>
<span class="sd">            Iterator over blocks in the core that meet the conditions provided.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; for b in r.core.iterBlocks(Flags.FUEL):</span>
<span class="sd">        ...     pass</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        The :py:meth:`getBlocks` has more control over what is included in the returned list including looking at the</span>
<span class="sd">        spent fuel pool and assemblies that may not exist now but existed at BOL (via :meth:`getAssemblies`). But if</span>
<span class="sd">        you&#39;re just interested in the blocks in the core now, maybe with a flag attached to that block, this is what you</span>
<span class="sd">        should use.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Assumes your composite tree is structured ``Core`` -&gt; ``Assembly`` -&gt; ``Block``. If this is not the case,</span>
<span class="sd">        consider using :meth:`iterChildren`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">typeSpec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">typeChecker</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">b</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exact</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">typeChecker</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">blockChecker</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">b</span><span class="p">:</span> <span class="n">typeChecker</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">blockChecker</span> <span class="o">=</span> <span class="n">typeChecker</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterChildren</span><span class="p">(</span><span class="n">generationNum</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="n">blockChecker</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2009-2025, TerraPower, LLC.
      <span class="lastupdated">Last updated on 2025-12-17.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
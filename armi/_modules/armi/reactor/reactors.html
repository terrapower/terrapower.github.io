

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>armi.reactor.reactors &mdash; ARMI 0.2.3 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_fixes.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/armiicon_16x16.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="../../../_static/assets/jsonview.bundle.js"></script>
        <script src="../../../_static/assets/jsonview_loader.js"></script>
        <script src="../../../_static/sphinx-needs/libs/html/datatables.min.js"></script>
        <script src="../../../_static/sphinx-needs/libs/html/datatables_loader.js"></script>
        <script src="../../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >
          

          
            <a href="../../../index.html" class="icon icon-home"> ARMI
          

          
            
            <img src="../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../requirements/index.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../.apidocs/modules.html">API Docs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ARMI</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../armi.html">armi</a> &raquo;</li>
        
          <li><a href="../reactor.html">armi.reactor</a> &raquo;</li>
        
      <li>armi.reactor.reactors</li>
    
    
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for armi.reactor.reactors</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Reactor objects represent the highest level in the hierarchy of structures that compose the system</span>
<span class="sd">to be modeled. Core objects represent collections of assemblies.</span>

<span class="sd">Core is a high-level object in the data model in ARMI. They contain assemblies which in turn contain</span>
<span class="sd">more refinement in representing the physical reactor. The reactor is the owner of many of the</span>
<span class="sd">plant-wide state variables such as keff, cycle, and node.</span>

<span class="sd">.. impl:: ARMI represents the Reactor heirarchically.</span>
<span class="sd">   :id: IMPL_REACTOR_HIERARCHY_0</span>
<span class="sd">   :links: REQ_REACTOR_HIERARCHY</span>

<span class="sd">   The Reactor contains a Core, which contains a heirachical collection of Assemblies, which in turn</span>
<span class="sd">   each contain a collection of Blocks.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">tabulate</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">getPluginManagerOrFail</span><span class="p">,</span> <span class="n">materials</span><span class="p">,</span> <span class="n">nuclearDataIO</span><span class="p">,</span> <span class="n">settings</span>
<span class="kn">from</span> <span class="nn">armi.nuclearDataIO</span> <span class="kn">import</span> <span class="n">xsLibraries</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">assemblies</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">assemblyLists</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">composites</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">geometry</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">grids</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">parameters</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">reactorParameters</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">systemLayoutInput</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">zones</span>
<span class="kn">from</span> <span class="nn">armi.reactor.flags</span> <span class="kn">import</span> <span class="n">Flags</span>
<span class="kn">from</span> <span class="nn">armi.settings.fwSettings.globalSettings</span> <span class="kn">import</span> <span class="n">CONF_MATERIAL_NAMESPACE_ORDER</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">createFormattedStrWithDelimiter</span><span class="p">,</span> <span class="n">units</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">directoryChangers</span>
<span class="kn">from</span> <span class="nn">armi.utils.iterables</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">armi.utils.mathematics</span> <span class="kn">import</span> <span class="n">average1DWithinTolerance</span>
<span class="kn">from</span> <span class="nn">armi.reactor.converters.axialExpansionChanger</span> <span class="kn">import</span> <span class="n">AxialExpansionChanger</span>

<span class="c1"># init logger</span>
<span class="n">runLog</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="Reactor"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Reactor">[docs]</a><span class="k">class</span> <span class="nc">Reactor</span><span class="p">(</span><span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Top level of the composite structure, potentially representing all components in a reactor.</span>

<span class="sd">    This class contains the core and any ex-core structures that are to be represented in the ARMI</span>
<span class="sd">    model. Historically, the `Reactor` contained only the core. To support better representation of</span>
<span class="sd">    ex-core structures, the old `Reactor` functionality was moved to the newer `Core` class, which</span>
<span class="sd">    has a `Reactor` parent.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pDefs</span> <span class="o">=</span> <span class="n">reactorParameters</span><span class="o">.</span><span class="n">defineReactorParameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">blueprints</span><span class="p">):</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;R-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">o</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cycle</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">Flags</span><span class="o">.</span><span class="n">REACTOR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blueprints</span> <span class="o">=</span> <span class="n">blueprints</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;applies a settings and parent to the reactor and components.&quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;o&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">newR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">newR</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(),</span> <span class="n">memo</span><span class="p">))</span>
        <span class="n">newR</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;-copy&quot;</span>
        <span class="k">return</span> <span class="n">newR</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2"> id:</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="Reactor.add"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Reactor.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">):</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
        <span class="n">cores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CORE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cores</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cores</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Only 1 core may be specified at this time. Please adjust input. &quot;</span>
                    <span class="s2">&quot;Cores found: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cores</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">core</span> <span class="o">=</span> <span class="n">cores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="loadFromCs"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.loadFromCs">[docs]</a><span class="k">def</span> <span class="nf">loadFromCs</span><span class="p">(</span><span class="n">cs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a Reactor based on the input settings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">blueprints</span>

    <span class="n">bp</span> <span class="o">=</span> <span class="n">blueprints</span><span class="o">.</span><span class="n">loadFromCs</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">factory</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">bp</span><span class="p">)</span></div>


<div class="viewcode-block" id="factory"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.factory">[docs]</a><span class="k">def</span> <span class="nf">factory</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">geom</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">systemLayoutInput</span><span class="o">.</span><span class="n">SystemLayoutInput</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a reactor from input settings, blueprints and geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">blueprints</span>

    <span class="n">runLog</span><span class="o">.</span><span class="n">header</span><span class="p">(</span><span class="s2">&quot;=========== Constructing Reactor and Verifying Inputs ===========&quot;</span><span class="p">)</span>
    <span class="c1"># just before reactor construction, update the material &quot;registry&quot; with user settings,</span>
    <span class="c1"># if it is set. Often it is set by the application.</span>
    <span class="k">if</span> <span class="n">cs</span><span class="p">[</span><span class="n">CONF_MATERIAL_NAMESPACE_ORDER</span><span class="p">]:</span>
        <span class="n">materials</span><span class="o">.</span><span class="n">setMaterialNamespaceOrder</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_MATERIAL_NAMESPACE_ORDER</span><span class="p">])</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">Reactor</span><span class="p">(</span><span class="n">cs</span><span class="o">.</span><span class="n">caseTitle</span><span class="p">,</span> <span class="n">bp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;geomFile&quot;</span><span class="p">]:</span>
        <span class="n">blueprints</span><span class="o">.</span><span class="n">migrate</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">directoryChangers</span><span class="o">.</span><span class="n">DirectoryChanger</span><span class="p">(</span><span class="n">cs</span><span class="o">.</span><span class="n">inputDirectory</span><span class="p">,</span> <span class="n">dumpOnException</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># always construct the core first (for assembly serial number purposes)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bp</span><span class="o">.</span><span class="n">systemDesigns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The input must define a `core` system, but does not. Update inputs&quot;</span>
            <span class="p">)</span>
        <span class="n">coreDesign</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">systemDesigns</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">]</span>
        <span class="n">coreDesign</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="n">geom</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">structure</span> <span class="ow">in</span> <span class="n">bp</span><span class="o">.</span><span class="n">systemDesigns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">structure</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;core&quot;</span><span class="p">:</span>
                <span class="n">structure</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

    <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Reactor: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">r</span></div>


<div class="viewcode-block" id="Core"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core">[docs]</a><span class="k">class</span> <span class="nc">Core</span><span class="p">(</span><span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reactor structure made up of assemblies. Could be a Core, spent fuel pool, reactor head, etc.</span>

<span class="sd">    This has the bulk of the data management operations.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    params : dict</span>
<span class="sd">        Core-level parameters are scalar values that have time dependence. Examples are keff,</span>
<span class="sd">        maxPercentBu, etc.</span>

<span class="sd">    assemblies : list</span>
<span class="sd">        List of assembly objects that are currently in the core</span>

<span class="sd">    cs : CaseSettings object</span>
<span class="sd">        Global settings for the case</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pDefs</span> <span class="o">=</span> <span class="n">reactorParameters</span><span class="o">.</span><span class="n">defineCoreParameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the reactor object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of the object. Flags will inherit from this.</span>
<span class="sd">        geom : SystemLayoutInput object</span>
<span class="sd">            Contains face-map</span>
<span class="sd">        cs : CaseSettings object, optional</span>
<span class="sd">            the calculation settings dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">Flags</span><span class="o">.</span><span class="n">fromStringIgnoreErrors</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circularRingList</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># lookup tables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numRings</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xsIndex</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">numMoves</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># build a spent fuel pool for this reactor</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Building spent fuel pools&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfp</span> <span class="o">=</span> <span class="n">assemblyLists</span><span class="o">.</span><span class="n">SpentFuelPool</span><span class="p">(</span><span class="s2">&quot;Spent Fuel Pool&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># placeholder for ISOTXS object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locParams</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># location-based parameters</span>
        <span class="c1"># overridden in case.py to include pre-reactor time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeOfStart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zones</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># initialize the list that holds all shuffles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moveList</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalarVals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeList</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of block types to convert name - to -number.</span>

        <span class="c1"># leftover default &quot;settings&quot; that are intended to eventually be elsewhere.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freshFeedType</span> <span class="o">=</span> <span class="s2">&quot;feed fuel&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trackAssems</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circularRingMode</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circularRingPitch</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_automaticVariableMesh</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minMeshSizeRatio</span> <span class="o">=</span> <span class="mf">0.15</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputHeightsConsideredHot</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Core.setOptionsFromCs"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.setOptionsFromCs">[docs]</a>    <span class="k">def</span> <span class="nf">setOptionsFromCs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
        <span class="c1"># these are really &quot;user modifiable modeling constants&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">jumpRing</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;jumpRingNum&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freshFeedType</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;freshFeedType&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trackAssems</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;trackAssems&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circularRingMode</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;circularRingMode&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_circularRingPitch</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;circularRingPitch&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_automaticVariableMesh</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;automaticVariableMesh&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minMeshSizeRatio</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;minMeshSizeRatio&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputHeightsConsideredHot</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;inputHeightsConsideredHot&quot;</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies a settings and parent to the core and components.&quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regenAssemblyLists</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">newC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">newC</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(),</span> <span class="n">memo</span><span class="p">))</span>
        <span class="n">newC</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;-copy&quot;</span>
        <span class="k">return</span> <span class="n">newC</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2"> id:</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override the base Composite __iter__ to produce stable sort order.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getAssemblies()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">Reactor</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">geometry</span><span class="o">.</span><span class="n">SymmetryType</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot access symmetry before a spatialGrid is attached.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">symmetry</span>

    <span class="nd">@symmetry</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geomType</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot access geomType before a spatialGrid is attached.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">geomType</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">powerMultiplier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Symmetry factor for this model. 1 for full core, 3 for 1/3 core, etc.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This should not be a state variable because it just reflects the current geometry.</span>
<span class="sd">        It changes automatically if the symmetry changes (e.g. from a geometry conversion).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">symmetryFactor</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lib</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">xsLibraries</span><span class="o">.</span><span class="n">IsotxsLibrary</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the microscopic cross section library if one exists.</span>

<span class="sd">        - If there is a library currently associated with the core,</span>
<span class="sd">          it will be returned</span>
<span class="sd">        - Otherwise, an ``ISOTXS`` file will be searched for in the working directory,</span>
<span class="sd">          opened as ``ISOTXS`` object and returned.</span>
<span class="sd">        - Finally, if no ``ISOTXS`` file exists in the working directory,</span>
<span class="sd">          a None will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">isotxsFileName</span> <span class="o">=</span> <span class="n">nuclearDataIO</span><span class="o">.</span><span class="n">getExpectedISOTXSFileName</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">isotxsFileName</span><span class="p">):</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading microscopic cross section library `</span><span class="si">{</span><span class="n">isotxsFileName</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="o">=</span> <span class="n">nuclearDataIO</span><span class="o">.</span><span class="n">isotxs</span><span class="o">.</span><span class="n">readBinary</span><span class="p">(</span><span class="n">isotxsFileName</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span>

    <span class="nd">@lib</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lib</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the microscopic cross section library.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isFullCore</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if reactor is full core, otherwise False.&quot;&quot;&quot;</span>
        <span class="c1"># Avoid using `not core.isFullCore` to check if third core geometry</span>
        <span class="c1"># use `core.symmetry.domain == geometry.DomainType.THIRD_CORE</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">FULL_CORE</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">refAssem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the &quot;reference&quot; assembly for this Core.</span>

<span class="sd">        The reference assembly is defined as the center-most assembly with a FUEL flag,</span>
<span class="sd">        if any are present, or the center-most of any assembly otherwise.</span>

<span class="sd">        Warnings</span>
<span class="sd">        ========</span>
<span class="sd">        The convenience of this property should be weighed against it&#39;s somewhat</span>
<span class="sd">        arbitrary nature for any particular client. The center-most fueled assembly is</span>
<span class="sd">        not particularly representative of the state of the core as a whole.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()</span>
        <span class="n">assems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span> <span class="n">sortKey</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">assems</span><span class="p">:</span>
            <span class="n">assems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">sortKey</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">assems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Core.summarizeReactorStats"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.summarizeReactorStats">[docs]</a>    <span class="k">def</span> <span class="nf">summarizeReactorStats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Writes a summary of the reactor to check the mass and volume of all of the blocks.&quot;&quot;&quot;</span>
        <span class="n">totalMass</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">fissileMass</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">heavyMetalMass</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">totalVolume</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">numBlocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">():</span>
            <span class="n">totalMass</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">getMass</span><span class="p">()</span>
            <span class="n">fissileMass</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">getFissileMass</span><span class="p">()</span>
            <span class="n">heavyMetalMass</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">getHMMass</span><span class="p">()</span>
            <span class="n">totalVolume</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>
        <span class="n">totalMass</span> <span class="o">=</span> <span class="n">totalMass</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="n">fissileMass</span> <span class="o">=</span> <span class="n">fissileMass</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="n">heavyMetalMass</span> <span class="o">=</span> <span class="n">heavyMetalMass</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="n">totalVolume</span> <span class="o">=</span> <span class="n">totalVolume</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">powerMultiplier</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
            <span class="s2">&quot;Summary of </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">tabulate</span><span class="o">.</span><span class="n">tabulate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="s2">&quot;Number of Blocks&quot;</span><span class="p">,</span> <span class="n">numBlocks</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;Total Volume (cc)&quot;</span><span class="p">,</span> <span class="n">totalVolume</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;Total Mass (kg)&quot;</span><span class="p">,</span> <span class="n">totalMass</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;Fissile Mass (kg)&quot;</span><span class="p">,</span> <span class="n">fissileMass</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;Heavy Metal Mass (kg)&quot;</span><span class="p">,</span> <span class="n">heavyMetalMass</span><span class="p">),</span>
                <span class="p">],</span>
                <span class="n">tablefmt</span><span class="o">=</span><span class="s2">&quot;armi&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Core.getScalarEvolution"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getScalarEvolution">[docs]</a>    <span class="k">def</span> <span class="nf">getScalarEvolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalarVals</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="Core.locateAllAssemblies"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.locateAllAssemblies">[docs]</a>    <span class="k">def</span> <span class="nf">locateAllAssemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the current location of all assemblies.</span>

<span class="sd">        This is required for shuffle printouts, repeat shuffling, and</span>
<span class="sd">        MCNP shuffling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">includeAll</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">a</span><span class="o">.</span><span class="n">lastLocationLabel</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span></div>

<div class="viewcode-block" id="Core.removeAssembly"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.removeAssembly">[docs]</a>    <span class="k">def</span> <span class="nf">removeAssembly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">discharge</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes an assembly and puts it out of core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a1 : assembly</span>
<span class="sd">            The assembly to remove</span>

<span class="sd">        discharge : bool, optional</span>
<span class="sd">            Discharge the assembly, including adding it to the SFP. Default: True</span>


<span class="sd">        Originally, this held onto all assemblies in the spend fuel pool. However, having</span>
<span class="sd">        this sitting in memory becomes constraining for large problems. It is more</span>
<span class="sd">        memory-efficient to only save the assemblies that are required for detailed</span>
<span class="sd">        history tracking. In fact, there&#39;s no need to save the assembly object at all,</span>
<span class="sd">        just have the history interface save the relevant parameters. This is an important</span>
<span class="sd">        cleanup.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add : adds an assembly</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paramDefs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">ALL_DEFINITIONS</span><span class="p">)</span>
        <span class="n">paramDefs</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">forType</span><span class="p">(</span><span class="n">Core</span><span class="p">)))</span>
        <span class="n">paramDefs</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">forType</span><span class="p">(</span><span class="n">Reactor</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">paramDef</span> <span class="ow">in</span> <span class="n">paramDefs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">paramDef</span><span class="o">.</span><span class="n">assigned</span> <span class="o">&amp;</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span><span class="p">:</span>
                <span class="n">paramDef</span><span class="o">.</span><span class="n">assigned</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span>
        <span class="k">if</span> <span class="n">discharge</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Removing </span><span class="si">{0}</span><span class="s2"> from </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Purging  </span><span class="si">{0}</span><span class="s2"> from </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
        <span class="n">a1</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">dischargeTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">discharge</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trackAssems</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_removeListFromAuxiliaries</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.removeAssembliesInRing"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.removeAssembliesInRing">[docs]</a>    <span class="k">def</span> <span class="nf">removeAssembliesInRing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ringNum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all of the assemblies in a given ring</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssembliesInRing</span><span class="p">(</span><span class="n">ringNum</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">removeAssembly</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processLoading</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">getMasterCs</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_removeListFromAuxiliaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assembly</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove an assembly from all auxiliary reference tables and lists</span>

<span class="sd">        Otherwise it will get added back into assembliesByName, etc.</span>

<span class="sd">        History will fail if it tries to summarize an assembly that has been purged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span><span class="p">[</span><span class="n">assembly</span><span class="o">.</span><span class="n">getName</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">assembly</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">getName</span><span class="p">()]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot delete block </span><span class="si">{0}</span><span class="s2">. It is not in the Core.blocksByName structure&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">),</span>
                    <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;cannot dereference: lost block&quot;</span><span class="p">,</span>
                <span class="p">)</span>

<div class="viewcode-block" id="Core.removeAllAssemblies"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.removeAllAssemblies">[docs]</a>    <span class="k">def</span> <span class="nf">removeAllAssemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">discharge</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears the core.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        must clear auxiliary bookkeeping lists as well or else a regeneration step will</span>
<span class="sd">        auto-add assemblies back in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">assems</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assems</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">removeAssembly</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">discharge</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">removeAll</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span> <span class="o">=</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="Core.add"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">spatialLocator</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an assembly to the reactor.</span>

<span class="sd">        An object must be added before it is placed in a particular cell</span>
<span class="sd">        in the reactor&#39;s spatialGrid. When an object is added to a reactor</span>
<span class="sd">        it get placed in a generic location at the center of the reactor unless</span>
<span class="sd">        a spatialLocator is passed in as well.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : ArmiObject</span>
<span class="sd">            The object to add to the reactor</span>
<span class="sd">        spatialLocator : SpatialLocator object, optional</span>
<span class="sd">            The location in the reactor to add the new object to. Must be unoccupied.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        removeAssembly : removes an assembly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># resetting .assigned forces database to be rewritten for shuffled core</span>
        <span class="n">paramDefs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">ALL_DEFINITIONS</span><span class="p">)</span>
        <span class="n">paramDefs</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">forType</span><span class="p">(</span><span class="n">Core</span><span class="p">)))</span>
        <span class="n">paramDefs</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">forType</span><span class="p">(</span><span class="n">Reactor</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">paramDef</span> <span class="ow">in</span> <span class="n">paramDefs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">paramDef</span><span class="o">.</span><span class="n">assigned</span> <span class="o">&amp;</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span><span class="p">:</span>
                <span class="n">paramDef</span><span class="o">.</span><span class="n">assigned</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span>

        <span class="c1"># could speed up output by passing format args as an arg and only process if verb good.</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding   </span><span class="si">{0}</span><span class="s2"> to </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">aName</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>

        <span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">spatialLocator</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span>

        <span class="k">if</span> <span class="n">spatialLocator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">spatialLocator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot add </span><span class="si">{}</span><span class="s2"> because location </span><span class="si">{}</span><span class="s2"> is already filled by </span><span class="si">{}</span><span class="s2">.&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">aName</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">spatialLocator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># transfer spatialLocator to Core one</span>
            <span class="n">spatialLocator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">indices</span><span class="p">)]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">locatorInDomain</span><span class="p">(</span>
                <span class="n">spatialLocator</span><span class="p">,</span> <span class="n">symmetryOverlap</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span>
                    <span class="s2">&quot;Location `</span><span class="si">{}</span><span class="s2">` outside of the represented domain: `</span><span class="si">{}</span><span class="s2">`&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">spatialLocator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">spatialLocator</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="p">[</span><span class="n">spatialLocator</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="c1"># build a lookup table for history tracking.</span>
        <span class="k">if</span> <span class="n">aName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span><span class="p">[</span><span class="n">aName</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">:</span>
            <span class="c1"># try to keep assem numbering correct</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;The assembly </span><span class="si">{1}</span><span class="s2"> in the reactor already has the name </span><span class="si">{0}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">Cannot add </span><span class="si">{2}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Current assemNum is </span><span class="si">{3}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">aName</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span><span class="p">[</span><span class="n">aName</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">assemblies</span><span class="o">.</span><span class="n">getAssemNum</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Core already contains an assembly with the same name.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span><span class="p">[</span><span class="n">aName</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">getName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">b</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geomType</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="o">.</span><span class="n">HEX</span><span class="p">:</span>
            <span class="n">ring</span><span class="p">,</span> <span class="n">_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">(</span>
                <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ring</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">numRings</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">numRings</span> <span class="o">=</span> <span class="n">ring</span>

        <span class="c1"># track the highest assem Num so when we load from a DB the future assemNums remain constant</span>
        <span class="n">aNum</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span>
        <span class="k">if</span> <span class="n">aNum</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">maxAssemNum</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">maxAssemNum</span> <span class="o">=</span> <span class="n">aNum</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">lastLocationLabel</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">DATABASE</span><span class="p">:</span>
            <span class="c1"># time the assembly enters the core in days</span>
            <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">chargeTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">time</span>
            <span class="c1"># cycle that the assembly enters the core</span>
            <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">chargeCycle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cycle</span>
            <span class="c1"># convert to kg</span>
            <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">chargeFis</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">getFissileMass</span><span class="p">()</span> <span class="o">/</span> <span class="mf">1000.0</span>
            <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">chargeBu</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">getMaxParam</span><span class="p">(</span><span class="s2">&quot;percentBu&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.genAssembliesAddedThisCycle"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.genAssembliesAddedThisCycle">[docs]</a>    <span class="k">def</span> <span class="nf">genAssembliesAddedThisCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yield the assemblies that have been added in the current cycle.</span>

<span class="sd">        This uses the reactor&#39;s cycle parameter and the assemblies&#39; chargeCycle</span>
<span class="sd">        parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">chargeCycle</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cycle</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">a</span></div>

<div class="viewcode-block" id="Core.getNumRings"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getNumRings">[docs]</a>    <span class="k">def</span> <span class="nf">getNumRings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexBased</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of rings in this reactor. Based on location so indexing will start at 1.</span>

<span class="sd">        WARNING: If you loop through range(maxRing) then ring+1 is the one you want!!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexBased : bool, optional</span>
<span class="sd">            If true, will force location-index interpretation, even if &quot;circular shuffling&quot; is enabled.</span>

<span class="sd">        When circular ring shuffling is activated, this changes interpretation.</span>
<span class="sd">        Developers plan on making this another method for the secondary interpretation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">circularRingList</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">indexBased</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circularRingList</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumHexRings</span><span class="p">()</span></div>

<div class="viewcode-block" id="Core.getNumHexRings"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getNumHexRings">[docs]</a>    <span class="k">def</span> <span class="nf">getNumHexRings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of hex rings in this reactor. Based on location so indexing will start at 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">maxRing</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">():</span>
            <span class="n">ring</span><span class="p">,</span> <span class="n">_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
            <span class="n">maxRing</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxRing</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">maxRing</span></div>

<div class="viewcode-block" id="Core.getNumAssembliesWithAllRingsFilledOut"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getNumAssembliesWithAllRingsFilledOut">[docs]</a>    <span class="k">def</span> <span class="nf">getNumAssembliesWithAllRingsFilledOut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nRings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns nAssmWithBlanks (see description immediately below).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nRings : int</span>
<span class="sd">            The number of hex assembly rings in this core, including</span>
<span class="sd">            partially-complete (non-full) rings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nAssmWithBlanks: int</span>
<span class="sd">            The number of assemblies that WOULD exist in this core if</span>
<span class="sd">            all outer assembly hex rings were &quot;filled out&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">nRings</span> <span class="o">*</span> <span class="p">(</span><span class="n">nRings</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nRings</span> <span class="o">*</span> <span class="p">(</span><span class="n">nRings</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nRings</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="Core.getNumEnergyGroups"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getNumEnergyGroups">[docs]</a>    <span class="k">def</span> <span class="nf">getNumEnergyGroups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of energy groups used in the problem</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.nuclearDataIO.ISOTXS.read1D : reads the number of energy groups off the ISOTXS library.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">numGroups</span></div>

    <span class="c1"># NOTE: this method is never used</span>
<div class="viewcode-block" id="Core.countAssemblies"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.countAssemblies">[docs]</a>    <span class="k">def</span> <span class="nf">countAssemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeList</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fullCore</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts the number of assemblies of type in ring (or in full reactor)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeList : iterable, optional</span>
<span class="sd">            Restruct counts to this assembly type.</span>

<span class="sd">        rings : int</span>
<span class="sd">            The reactor ring to find assemblies in</span>

<span class="sd">        fullCore : bool, optional</span>
<span class="sd">            If True, will consider the core symmetry. Default: False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">assems</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeList</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">assems</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assems</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ring</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fullCore</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_a</span> <span class="ow">in</span> <span class="n">assems</span><span class="p">)</span>

        <span class="n">pmult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">powerMultiplier</span>  <span class="c1"># value is loop-independent</span>

        <span class="n">rings</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assems</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">pmult</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rings</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.countBlocksWithFlags"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.countBlocksWithFlags">[docs]</a>    <span class="k">def</span> <span class="nf">countBlocksWithFlags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blockTypeSpec</span><span class="p">,</span> <span class="n">assemTypeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total number of blocks in an assembly in the reactor that</span>
<span class="sd">        meets the specified type</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        blockTypeSpec : Flags or list of Flags</span>
<span class="sd">            The types of blocks to be counted in a single assembly</span>

<span class="sd">        assemTypeSpec : Flags or list of Flags</span>
<span class="sd">            The types of assemblies that are to be examine for the blockTypes</span>
<span class="sd">            of interest.  None is every assembly</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        maxBlocks : int</span>
<span class="sd">            The maximum number of blocks of the specified types in a single</span>
<span class="sd">            assembly in the entire core</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">assems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">typeSpec</span><span class="o">=</span><span class="n">assemTypeSpec</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">blockTypeSpec</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assems</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># In case assems is empty</span>
            <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Core.countFuelAxialBlocks"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.countFuelAxialBlocks">[docs]</a>    <span class="k">def</span> <span class="nf">countFuelAxialBlocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return the maximum number of fuel type blocks in any assembly in</span>
<span class="sd">        the reactor</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getFirstFuelBlockAxialNode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fuelblocks</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">a</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">includeBolAssems</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fuel</span><span class="p">)</span> <span class="k">for</span> <span class="n">fuel</span> <span class="ow">in</span> <span class="n">fuelblocks</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># thrown when iterator is empty</span>
            <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Core.getFirstFuelBlockAxialNode"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getFirstFuelBlockAxialNode">[docs]</a>    <span class="k">def</span> <span class="nf">getFirstFuelBlockAxialNode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the offset of the fuel from the grid plate in the assembly</span>
<span class="sd">        with the lowest fuel block.</span>

<span class="sd">        This assembly will dictate at what block level the SASSYS reactivity</span>
<span class="sd">        coefficients will start to be generated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">i</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">includeBolAssems</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;ValueError is thrown if min is called on an empty sequence.</span>
<span class="sd">            Since this is expected to be a rare case, try/except is more</span>
<span class="sd">            efficient than an if/else condition that checks whether the</span>
<span class="sd">            iterator is empty (the latter would require generating a list</span>
<span class="sd">            or tuple, which further adds to the inefficiency). Hence Python&#39;s</span>
<span class="sd">            mantra, &quot;It&#39;s easier to ask forgiveness than permission.&quot; In fact</span>
<span class="sd">            it&#39;s quicker to ask forgiveness than permission.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.getAssembliesInRing"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAssembliesInRing">[docs]</a>    <span class="k">def</span> <span class="nf">getAssembliesInRing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exactType</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclusions</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the assemblies in a specified ring. Definitions of rings can change</span>
<span class="sd">        with problem parameters.</span>

<span class="sd">        This function acts as a switch between two separate functions that define what a</span>
<span class="sd">        ring is based on a cs setting &#39;circularRingMode&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ring : int</span>
<span class="sd">            The ring number</span>

<span class="sd">        typeSpec : str, list</span>
<span class="sd">            a string or list of assembly types of interest</span>

<span class="sd">        exactType : bool</span>
<span class="sd">            flag to match the assembly type exactly</span>

<span class="sd">        exclusions : list of assemblies</span>
<span class="sd">            list of assemblies that are not to be considered</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        aList : list of assemblies</span>
<span class="sd">            A list of assemblies that match the criteria within the ring</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circularRingMode</span><span class="p">:</span>
            <span class="n">getter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssembliesInCircularRing</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">getter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssembliesInSquareOrHexRing</span>

        <span class="k">return</span> <span class="n">getter</span><span class="p">(</span>
            <span class="n">ring</span><span class="o">=</span><span class="n">ring</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exactType</span><span class="o">=</span><span class="n">exactType</span><span class="p">,</span> <span class="n">exclusions</span><span class="o">=</span><span class="n">exclusions</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Core.getMaxAssembliesInHexRing"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getMaxAssembliesInHexRing">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxAssembliesInHexRing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">fullCore</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the maximum number of assemblies possible for a given Hexagonal ring.</span>

<span class="sd">        ring - The ring of interest to calculate the maximum number of assemblies.</span>
<span class="sd">        numEdgeAssems - The number of edge assemblies in the reactor model (1/3 core).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Assumes that odd rings do not have an edge assembly in third core geometry.</span>
<span class="sd">        These should be removed in: self._modifyGeometryAfterLoad during importGeom</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numAssemsUpToOuterRing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumAssembliesWithAllRingsFilledOut</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="n">numAssemsUpToInnerRing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumAssembliesWithAllRingsFilledOut</span><span class="p">(</span><span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">maxAssemsInRing</span> <span class="o">=</span> <span class="n">numAssemsUpToOuterRing</span> <span class="o">-</span> <span class="n">numAssemsUpToInnerRing</span>

        <span class="c1"># See note*</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fullCore</span><span class="p">:</span>
            <span class="n">ringMod</span> <span class="o">=</span> <span class="n">ring</span> <span class="o">%</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">ringMod</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">maxAssemsInRing</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">maxAssemsInRing</span></div>

<div class="viewcode-block" id="Core.getAssembliesInSquareOrHexRing"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAssembliesInSquareOrHexRing">[docs]</a>    <span class="k">def</span> <span class="nf">getAssembliesInSquareOrHexRing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exactType</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclusions</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the assemblies in a specified ring.  Definitions of rings can change</span>
<span class="sd">        with problem parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ring : int</span>
<span class="sd">            The ring number</span>

<span class="sd">        typeSpec : Flags or [Flags], optional</span>
<span class="sd">            a Flags instance or list of Flags with assembly types of interest</span>

<span class="sd">        exactType : bool</span>
<span class="sd">            flag to match the assembly type exactly</span>

<span class="sd">        exclusions : list of assemblies</span>
<span class="sd">            list of assemblies that are not to be considered</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        assems : list of assemblies</span>
<span class="sd">            A list of assemblies that match the criteria within the ring</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">assems</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclusions</span><span class="p">:</span>
            <span class="n">exclusions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclusions</span><span class="p">)</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">exclusions</span><span class="p">)</span>

        <span class="c1"># filter based on geomType</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geomType</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="o">.</span><span class="n">CARTESIAN</span>
        <span class="p">):</span>  <span class="c1"># a ring in cartesian is basically a square.</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span><span class="n">xy</span> <span class="o">==</span> <span class="n">ring</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">indices</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ring</span><span class="p">))</span>

        <span class="c1"># filter based on typeSpec</span>
        <span class="k">if</span> <span class="n">typeSpec</span><span class="p">:</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exactType</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">assems</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.getAssembliesInCircularRing"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAssembliesInCircularRing">[docs]</a>    <span class="k">def</span> <span class="nf">getAssembliesInCircularRing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exactType</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclusions</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets an assemblies within a circular range of the center of the core.  This</span>
<span class="sd">        function allows for more circular styled assembly shuffling instead of the</span>
<span class="sd">        current hex approach.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ring : int</span>
<span class="sd">            The ring number</span>

<span class="sd">        typeSpec : Flags or list of Flags</span>
<span class="sd">            a Flags instance or list of Flags with assembly types of interest</span>

<span class="sd">        exactType : bool</span>
<span class="sd">            flag to match the assembly type exactly</span>

<span class="sd">        exclusions : list of assemblies</span>
<span class="sd">            list of assemblies that are not to be considered</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        assems : list of assemblies</span>
<span class="sd">            A list of assemblies that match the criteria within the ring</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geomType</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="o">.</span><span class="n">CARTESIAN</span><span class="p">:</span>
            <span class="c1"># a ring in cartesian is basically a square.</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;A circular ring in cartesian coordinates has not been defined yet.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># determine if the circularRingList has been generated</span>
        <span class="c1"># TODO: make circularRingList a property that is generated on request</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">circularRingList</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">circularRingList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buildCircularRingDictionary</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_circularRingPitch</span>
            <span class="p">)</span>

        <span class="n">assems</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Remove exclusions</span>
        <span class="k">if</span> <span class="n">exclusions</span><span class="p">:</span>
            <span class="n">exclusions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclusions</span><span class="p">)</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">exclusions</span><span class="p">)</span>

        <span class="c1"># get assemblies at locations</span>
        <span class="n">locSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">circularRingList</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span>
        <span class="n">assems</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="ow">in</span> <span class="n">locSet</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">typeSpec</span><span class="p">:</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exactType</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">assems</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.buildCircularRingDictionary"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.buildCircularRingDictionary">[docs]</a>    <span class="k">def</span> <span class="nf">buildCircularRingDictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ringPitch</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a dictionary of all circular rings in the core.  This is required information for getAssembliesInCircularRing.</span>

<span class="sd">        The purpose of this function is to allow for more circular core shuffling in the hex design.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ringPitch : float, optional</span>
<span class="sd">            The relative pitch that should be used to define the spacing between each ring.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
            <span class="s2">&quot;Building a circular ring dictionary with ring pitch </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ringPitch</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">referenceAssembly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="n">refLocation</span> <span class="o">=</span> <span class="n">referenceAssembly</span><span class="o">.</span><span class="n">spatialLocator</span>
        <span class="n">pitchFactor</span> <span class="o">=</span> <span class="n">ringPitch</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">pitch</span>

        <span class="n">circularRingDict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">distanceTo</span><span class="p">(</span><span class="n">refLocation</span><span class="p">)</span>
            <span class="c1"># To reduce numerical sensitivity, round distance to 6 decimal places</span>
            <span class="c1"># before truncating.</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">dist</span> <span class="o">*</span> <span class="n">pitchFactor</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span> <span class="ow">or</span> <span class="mi">1</span>  <span class="c1"># 1 is the smallest ring.</span>
            <span class="n">circularRingDict</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">circularRingDict</span></div>

    <span class="k">def</span> <span class="nf">_getAssembliesByName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the assembly name-to-assembly object map is deleted or out of date, then this will</span>
<span class="sd">        regenerate it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Generating assemblies-by-name map.&quot;</span><span class="p">)</span>

        <span class="c1"># NOTE: eliminated unnecessary repeated lookups in self for self.assembliesByName</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span> <span class="o">=</span> <span class="n">assymap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># don&#39;t includeAll b/c detailed ones are not ready yet</span>
        <span class="k">for</span> <span class="n">assem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">includeBolAssems</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includeSFP</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">aName</span> <span class="o">=</span> <span class="n">assem</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">aName</span> <span class="ow">in</span> <span class="n">assymap</span> <span class="ow">and</span> <span class="n">assymap</span><span class="p">[</span><span class="n">aName</span><span class="p">]</span> <span class="o">!=</span> <span class="n">assem</span><span class="p">:</span>
                <span class="c1"># dangerous situation that can occur in restart runs where the global assemNum isn&#39;t updated.</span>
                <span class="c1"># !=assem clause added because sometimes an assem is in one of the includeAll lists that is also in the</span>
                <span class="c1"># core and that&#39;s ok.</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;Two (or more) assemblies in the reactor (and associated lists) have the name </span><span class="si">{0}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;including </span><span class="si">{1}</span><span class="s2"> and </span><span class="si">{2}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aName</span><span class="p">,</span> <span class="n">assem</span><span class="p">,</span> <span class="n">assymap</span><span class="p">[</span><span class="n">aName</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Assembly name collision.&quot;</span><span class="p">)</span>

            <span class="n">assymap</span><span class="p">[</span><span class="n">aName</span><span class="p">]</span> <span class="o">=</span> <span class="n">assem</span>

<div class="viewcode-block" id="Core.getAssemblyByName"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAssemblyByName">[docs]</a>    <span class="k">def</span> <span class="nf">getAssemblyByName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the assembly that has this name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            the assembly name e.g. &#39;A0001&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        assembly</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getAssembly : more general version of this method</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembliesByName</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>

<div class="viewcode-block" id="Core.getAssemblies"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAssemblies">[docs]</a>    <span class="k">def</span> <span class="nf">getAssemblies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sortKey</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">includeBolAssems</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">includeSFP</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">includeAll</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">zones</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of all the assemblies in the reactor.</span>

<span class="sd">        Assemblies from the Core itself are sorted based on the Assemblies&#39; comparison</span>
<span class="sd">        operators (location-based). This is done so that two reactors with physically</span>
<span class="sd">        identical properties are more likely to behave similarly when their assemblies</span>
<span class="sd">        may have been added in different orders. In the future this will likely be</span>
<span class="sd">        replaced by sorting the _children list itself internally, as there is still</span>
<span class="sd">        opportunity for inconsistencies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or iterable of Flags, optional</span>
<span class="sd">            List of assembly types that will be returned</span>

<span class="sd">        sortKey : callable, optional</span>
<span class="sd">            Sort predicate to use when sorting the assemblies.</span>

<span class="sd">        includeBolAssems : bool, optional</span>
<span class="sd">            Include the BOL assemblies as well as the ones that are in the core.</span>
<span class="sd">            Default: False</span>

<span class="sd">        includeSFP : bool, optional</span>
<span class="sd">            Include assemblies in the SFP</span>

<span class="sd">        includeAll : bool, optional</span>
<span class="sd">            Will include ALL assemblies.</span>

<span class="sd">        zones : str or iterable, optional</span>
<span class="sd">            Only include assemblies that are in this zone/these zones</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Attempts have been made to make this a generator but there were some Cython</span>
<span class="sd">        incompatibilities that we could not get around and so we are sticking with a</span>
<span class="sd">        list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">includeAll</span><span class="p">:</span>
            <span class="n">includeBolAssems</span> <span class="o">=</span> <span class="n">includeSFP</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">assems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">includeBolAssems</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">blueprints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">blueprints</span><span class="o">.</span><span class="n">assemblies</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">assems</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sortKey</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">includeSFP</span><span class="p">:</span>
            <span class="n">assems</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">getChildren</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">typeSpec</span><span class="p">:</span>
            <span class="n">assems</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assems</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exact</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">zones</span><span class="p">:</span>
            <span class="n">zoneLocs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zones</span><span class="o">.</span><span class="n">getZoneLocations</span><span class="p">(</span><span class="n">zones</span><span class="p">)</span>
            <span class="n">assems</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assems</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="ow">in</span> <span class="n">zoneLocs</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">assems</span></div>

<div class="viewcode-block" id="Core.getBlockByName"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getBlockByName">[docs]</a>    <span class="k">def</span> <span class="nf">getBlockByName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds a block based on its name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Block name e.g. A0001A</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Block : the block with the name</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The blocksByName structure must be up to date for this to work properly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_genBlocksByName</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>

<div class="viewcode-block" id="Core.getBlocksByIndices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getBlocksByIndices">[docs]</a>    <span class="k">def</span> <span class="nf">getBlocksByIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get blocks in assemblies by block indices.&quot;&quot;&quot;</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">assem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assem</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">blocks</span></div>

    <span class="k">def</span> <span class="nf">_genBlocksByName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If self.blocksByName is deleted, then this will regenerate it.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocksByName</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">block</span><span class="o">.</span><span class="n">getName</span><span class="p">():</span> <span class="n">block</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">includeAll</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>

    <span class="c1"># TODO: (Idea) wrap this in an &quot;if not self.blocksByLocName:&quot;</span>
    <span class="c1"># This will likely fail, but it will help diagnose why property approach</span>
    <span class="c1"># wasn&#39;t working correctly</span>
<div class="viewcode-block" id="Core.genBlocksByLocName"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.genBlocksByLocName">[docs]</a>    <span class="k">def</span> <span class="nf">genBlocksByLocName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If self.blocksByLocName is deleted, then this will regenerate it or update it if things change</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocksByLocName</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">block</span><span class="o">.</span><span class="n">getLocation</span><span class="p">():</span> <span class="n">block</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">includeAll</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="Core.getBlocks"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getBlocks">[docs]</a>    <span class="k">def</span> <span class="nf">getBlocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all blocks in the reactor in order</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bType : list or Flags, optional</span>
<span class="sd">            Restrict results to a specific block type such as Flags.FUEL, Flags.SHIELD, etc.</span>

<span class="sd">        includeBolAssems : bool, optional</span>
<span class="sd">            Include the BOL-Assembly blocks as well. These blocks are created at BOL</span>
<span class="sd">            and used to create new assemblies, etc. If true, the blocks in these</span>
<span class="sd">            assemblies will be returned as well as the ones in the reactor.</span>

<span class="sd">        kwargs : dict</span>
<span class="sd">            Any keyword argument from R.getAssemblies()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        blocks : iterator</span>
<span class="sd">            all blocks in the reactor (or of type requested)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getAssemblies : locates the assemblies in the search</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bType</span><span class="p">:</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">blocks</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">bType</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">blocks</span></div>

<div class="viewcode-block" id="Core.getFirstBlock"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getFirstBlock">[docs]</a>    <span class="k">def</span> <span class="nf">getFirstBlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blockType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first block of the requested type in the reactor, or return first block.</span>
<span class="sd">        exact=True will only match fuel, not testfuel, for example.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        blockType : Flags, optional</span>
<span class="sd">            The type of block to return</span>

<span class="sd">        exact : bool, optional</span>
<span class="sd">            Requires an exact match on blockType</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        b : Block object (or None if no such block exists)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">blockType</span><span class="p">,</span> <span class="n">exact</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">b</span></div>

<div class="viewcode-block" id="Core.getFirstAssembly"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getFirstAssembly">[docs]</a>    <span class="k">def</span> <span class="nf">getFirstAssembly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the first assembly in the reactor.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        This function should be used with great care. There are **very** few</span>
<span class="sd">        circumstances in which one wants the &quot;first&quot; of a given sort of assembly,</span>
<span class="sd">        `whichever that may happen to be`. Precisely which assembly is returned is</span>
<span class="sd">        sensitive to all sorts of implementation details in Grids, etc., which make the</span>
<span class="sd">        concept of &quot;first&quot; rather slippery. Prefer using some sort of precise logic to</span>
<span class="sd">        pick a specific assembly from the Core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or iterable of Flags, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">typeSpec</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No assem of type </span><span class="si">{0}</span><span class="s2"> in reactor&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Assumes at least one assembly in `self`</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="Core.regenAssemblyLists"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.regenAssemblyLists">[docs]</a>    <span class="k">def</span> <span class="nf">regenAssemblyLists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the attribute lists which contain assemblies are deleted (such as by reactors.detachAllAssemblies),</span>
<span class="sd">        then this function will call the other functions to regrow them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_getAssembliesByName</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_genBlocksByName</span><span class="p">()</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="s2">&quot;Regenerating Core Zones&quot;</span><span class="p">)</span>
        <span class="c1"># TODO: this call is questionable... the cs should correspond to analysis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buildZones</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">getMasterCs</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_genChildByLocationLookupTable</span><span class="p">()</span></div>

<div class="viewcode-block" id="Core.getAllXsSuffixes"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAllXsSuffixes">[docs]</a>    <span class="k">def</span> <span class="nf">getAllXsSuffixes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all XS suffices (e.g. AA, AB, etc.) in the core.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">()))</span></div>

<div class="viewcode-block" id="Core.getNuclideCategories"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getNuclideCategories">[docs]</a>    <span class="k">def</span> <span class="nf">getNuclideCategories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Categorize nuclides as coolant, fuel and structure.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is used to categorize nuclides for Doppler broadening. Control nuclides are treated as structure.</span>

<span class="sd">        The categories are defined in the following way:</span>

<span class="sd">        1. Add nuclides from coolant components to coolantNuclides</span>
<span class="sd">        2. Add nuclides from fuel components to fuelNuclides (this may be incomplete, e.g.</span>
<span class="sd">           at BOL there are no fission products)</span>
<span class="sd">        3. Add nuclides from all other components to structureNuclides</span>
<span class="sd">        4. Since fuelNuclides may be incomplete, add anything else the user wants to model</span>
<span class="sd">           that isn&#39;t already listed in coolantNuclides or structureNuclides.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coolantNuclides : set</span>
<span class="sd">            set of nuclide names</span>

<span class="sd">        fuelNuclides : set</span>
<span class="sd">            set of nuclide names</span>

<span class="sd">        structureNuclides : set</span>
<span class="sd">            set of nuclide names</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">:</span>
            <span class="n">coolantNuclides</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">fuelNuclides</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">structureNuclides</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;coolant&quot;</span><span class="p">:</span>
                    <span class="n">coolantNuclides</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getNuclides</span><span class="p">())</span>
                <span class="k">elif</span> <span class="s2">&quot;fuel&quot;</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">getName</span><span class="p">():</span>
                    <span class="n">fuelNuclides</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getNuclides</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">structureNuclides</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getNuclides</span><span class="p">())</span>
            <span class="n">structureNuclides</span> <span class="o">-=</span> <span class="n">coolantNuclides</span>
            <span class="n">structureNuclides</span> <span class="o">-=</span> <span class="n">fuelNuclides</span>
            <span class="n">remainingNuclides</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">blueprints</span><span class="o">.</span><span class="n">allNuclidesInProblem</span><span class="p">)</span>
                <span class="o">-</span> <span class="n">structureNuclides</span>
                <span class="o">-</span> <span class="n">coolantNuclides</span>
            <span class="p">)</span>
            <span class="n">fuelNuclides</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">remainingNuclides</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;coolant&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coolantNuclides</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;fuel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fuelNuclides</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">structureNuclides</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summarizeNuclideCategories</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;coolant&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;fuel&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">],</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Core.summarizeNuclideCategories"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.summarizeNuclideCategories">[docs]</a>    <span class="k">def</span> <span class="nf">summarizeNuclideCategories</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write summary table of the various nuclide categories within the reactor.&quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Nuclide categorization for cross section temperature assignments:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="n">tabulate</span><span class="o">.</span><span class="n">tabulate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;Fuel&quot;</span><span class="p">,</span>
                        <span class="n">createFormattedStrWithDelimiter</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;fuel&quot;</span><span class="p">]</span>
                        <span class="p">),</span>
                    <span class="p">),</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;Coolant&quot;</span><span class="p">,</span>
                        <span class="n">createFormattedStrWithDelimiter</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;coolant&quot;</span><span class="p">]</span>
                        <span class="p">),</span>
                    <span class="p">),</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;Structure&quot;</span><span class="p">,</span>
                        <span class="n">createFormattedStrWithDelimiter</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_nuclideCategories</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span>
                        <span class="p">),</span>
                    <span class="p">),</span>
                <span class="p">],</span>
                <span class="n">headers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Nuclide Category&quot;</span><span class="p">,</span> <span class="s2">&quot;Nuclides&quot;</span><span class="p">],</span>
                <span class="n">tablefmt</span><span class="o">=</span><span class="s2">&quot;armi&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Core.getLocationContents"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getLocationContents">[docs]</a>    <span class="k">def</span> <span class="nf">getLocationContents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locs</span><span class="p">,</span> <span class="n">assemblyLevel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">locContents</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of locations, this goes through and finds the blocks or assemblies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        locs : list of location objects or strings</span>
<span class="sd">            The locations you&#39;d like to find assemblies in</span>
<span class="sd">        assemblyLevel : bool, optional</span>
<span class="sd">            If True, will find assemblies rather than blocks</span>
<span class="sd">        locContents : dict, optional</span>
<span class="sd">            A master lookup table with location string keys and block/assembly values</span>
<span class="sd">            useful if you want to call this function many times and would like a speedup.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        blockList : iterable</span>
<span class="sd">            List of blocks or assemblies that correspond to the locations passed in</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Useful in reading the db.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        makeLocationLookup : allows caching to speed this up if you call it a lot.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Why isn&#39;t locContents an attribute of reactor? It could be another</span>
        <span class="c1"># property that is generated on demand</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">locContents</span><span class="p">:</span>
            <span class="n">locContents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">makeLocationLookup</span><span class="p">(</span><span class="n">assemblyLevel</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># now look &#39;em up</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">locContents</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">loc</span><span class="p">)]</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">locs</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;There is nothing in core location </span><span class="si">{0}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span></div>

<div class="viewcode-block" id="Core.makeLocationLookup"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.makeLocationLookup">[docs]</a>    <span class="k">def</span> <span class="nf">makeLocationLookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemblyLevel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a location-keyed lookup table to figure out which block (or</span>
<span class="sd">        assembly, if assemblyLevel=True) is in which location. Used within</span>
<span class="sd">        getLocationContents, but can also be used to pre-build a cache for that</span>
<span class="sd">        function, speeding the lookup with a cache.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getLocationContents : can use this lookup table to go faster.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># build a lookup table one time.</span>
        <span class="k">if</span> <span class="n">assemblyLevel</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">():</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">b</span><span class="o">.</span><span class="n">getLocation</span><span class="p">():</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">}</span></div>

    <span class="c1"># TODO: Can be cleaned up, but need test case to guard agains breakage</span>
<div class="viewcode-block" id="Core.getFluxVector"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getFluxVector">[docs]</a>    <span class="k">def</span> <span class="nf">getFluxVector</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">energyOrder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">extSrc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">volumeIntegrated</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the multigroup real or adjoint flux of the entire reactor as a vector</span>

<span class="sd">        Order of meshes is based on getBlocks</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        energyOrder : int, optional</span>
<span class="sd">            A value of 0 implies that the flux will have all energy groups for</span>
<span class="sd">            the first mesh point, and then all energy groups for the next mesh point, etc.</span>

<span class="sd">            A value of 1 implies that the flux will have values for all mesh points</span>
<span class="sd">            of the first energy group first, followed by all mesh points for the second energy</span>
<span class="sd">            group, etc.</span>

<span class="sd">        adjoint : bool, optional</span>
<span class="sd">            If True, will return adjoint flux instead of real flux.</span>

<span class="sd">        extSrc : bool, optional</span>
<span class="sd">            If True, will return external source instead of real flux.</span>

<span class="sd">        volumeIntegrated : bool, optional</span>
<span class="sd">            If true (default), flux units will be #-cm/s. If false, they will be #-cm^2/s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vals : list</span>
<span class="sd">            The values you requested. length is NxG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">())</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">numGroups</span><span class="p">)</span>

        <span class="c1"># build in order 0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">adjoint</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">adjMgFlux</span>
            <span class="k">elif</span> <span class="n">extSrc</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">extSrc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">volumeIntegrated</span><span class="p">:</span>
                <span class="n">vol</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="o">/</span> <span class="n">vol</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">]</span>

            <span class="n">flux</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">energyOrder</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># swap order.</span>
            <span class="n">newFlux</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                <span class="n">oneGroup</span> <span class="o">=</span> <span class="p">[</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">))]</span>
                <span class="n">newFlux</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">oneGroup</span><span class="p">)</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">newFlux</span>

        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.getAssembliesOfType"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAssembliesOfType">[docs]</a>    <span class="k">def</span> <span class="nf">getAssembliesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of assemblies in the core that are of type assemType.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="n">exactMatch</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.getAssembly"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAssembly">[docs]</a>    <span class="k">def</span> <span class="nf">getAssembly</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">assemNum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">locationString</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">assemblyName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds an assembly in the core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        assemNum : int, optional</span>
<span class="sd">            Returns the assembly with this assemNum</span>
<span class="sd">        locationString : str</span>
<span class="sd">            A location string</span>
<span class="sd">        assemblyName : str, optional</span>
<span class="sd">            The assembly name</span>
<span class="sd">        *args : additional optional arguments for self.getAssemblies</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a : Assembly</span>
<span class="sd">            The assembly that matches, or None if nothing is found</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getAssemblyByName</span>
<span class="sd">        getAssemblyWithStringLocation</span>
<span class="sd">        getLocationContents : a much more efficient way to look up assemblies in a list of locations</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">assemblyName</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblyByName</span><span class="p">(</span><span class="n">assemblyName</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="o">==</span> <span class="n">locationString</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getNum</span><span class="p">()</span> <span class="o">==</span> <span class="n">assemNum</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="Core.getAssemblyWithAssemNum"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAssemblyWithAssemNum">[docs]</a>    <span class="k">def</span> <span class="nf">getAssemblyWithAssemNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemNum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve assembly with a particular assembly number from the core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        assemNum : int</span>
<span class="sd">            The assembly number of interest</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        foundAssembly : Assembly object or None</span>
<span class="sd">            The assembly found, or None</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssembly</span><span class="p">(</span><span class="n">assemNum</span><span class="o">=</span><span class="n">assemNum</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.getAssemblyWithStringLocation"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAssemblyWithStringLocation">[docs]</a>    <span class="k">def</span> <span class="nf">getAssemblyWithStringLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locationString</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an assembly or none if given a location string like &#39;B0014&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">locatorLabelToIndices</span><span class="p">(</span><span class="n">locationString</span><span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getLocatorFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="n">assem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">assem</span></div>

<div class="viewcode-block" id="Core.getAssemblyPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAssemblyPitch">[docs]</a>    <span class="k">def</span> <span class="nf">getAssemblyPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the assembly pitch for the whole core.</span>

<span class="sd">        This returns the pitch according to the spatialGrid.</span>
<span class="sd">        To capture any thermal/hydraulic feedback of the core pitch,</span>
<span class="sd">        T/H modules will need to modify the grid pitch directly based</span>
<span class="sd">        on the relevant mechanical assumptions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pitch : float</span>
<span class="sd">            The assembly pitch.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">pitch</span></div>

<div class="viewcode-block" id="Core.findNeighbors"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.findNeighbors">[docs]</a>    <span class="k">def</span> <span class="nf">findNeighbors</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">showBlanks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">duplicateAssembliesOnReflectiveBoundary</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find assemblies that are next this assembly.</span>

<span class="sd">        Return a list of neighboring assemblies from the 30 degree point (point 1) then</span>
<span class="sd">        counterclockwise around.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : Assembly object</span>
<span class="sd">            The assembly to find neighbors of.</span>

<span class="sd">        showBlanks : Boolean, optional</span>
<span class="sd">            If True, the returned array of 6 neighbors will return &quot;None&quot; for neighbors</span>
<span class="sd">            that do not explicitly exist in the 1/3 core model (including many that WOULD</span>
<span class="sd">            exist in a full core model).</span>

<span class="sd">            If False, the returned array will not include the &quot;None&quot; neighbors. If one or</span>
<span class="sd">            more neighbors does not explicitly exist in the 1/3 core model, the returned</span>
<span class="sd">            array will have a length of less than 6.</span>

<span class="sd">        duplicateAssembliesOnReflectiveBoundary : Boolean, optional</span>
<span class="sd">            If True, findNeighbors duplicates neighbor assemblies into their &quot;symmetric</span>
<span class="sd">            identicals&quot; so that even assemblies that border symmetry lines will have 6</span>
<span class="sd">            neighbors. The only assemblies that will have fewer than 6 neighbors are those</span>
<span class="sd">            that border the outer core boundary (usually vacuum).</span>

<span class="sd">            If False, findNeighbors returns None for assemblies that do not exist in a 1/3</span>
<span class="sd">            core model (but WOULD exist in a full core model).</span>

<span class="sd">            For example, applying findNeighbors for the central assembly (ring, pos) = (1,</span>
<span class="sd">            1) in 1/3 core symmetry (with duplicateAssembliesOnReflectiveBoundary = True)</span>
<span class="sd">            would return a list of 6 assemblies, but those 6 would really only be</span>
<span class="sd">            assemblies (2, 1) and (2, 2) repeated 3 times each.</span>

<span class="sd">            Note that the value of duplicateAssembliesOnReflectiveBoundary only really if</span>
<span class="sd">            showBlanks = True.  This will have no effect if the model is full core since</span>
<span class="sd">            asymmetric models could find many duplicates in the other thirds</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This only works for 1/3 or full core symmetry.</span>

<span class="sd">        This uses the &#39;mcnp&#39; index map (MCNP GEODST hex coordinates) instead of the</span>
<span class="sd">        standard (ring, pos) map. because neighbors have consistent indices this way.  We</span>
<span class="sd">        then convert over to (ring, pos) using the lookup table that a reactor has.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        neighbors : list of assembly objects</span>
<span class="sd">            This is a list of &quot;nearest neighbors&quot; to assembly a.</span>

<span class="sd">            If showBlanks = False, it will return fewer than 6 neighbors if not all 6</span>
<span class="sd">            neighbors explicitly exist in the core model.</span>

<span class="sd">            If showBlanks = True and duplicateAssembliesOnReflectiveBoundary = False, it</span>
<span class="sd">            will have a &quot;None&quot; for assemblies that do not exist in the 1/3 model.</span>

<span class="sd">            If showBlanks = True and duplicateAssembliesOnReflectiveBoundary = True, it</span>
<span class="sd">            will return the existing &quot;symmetric identical&quot; assembly of a non-existing</span>
<span class="sd">            assembly. It will only return &quot;None&quot; for an assembly when that assembly is</span>
<span class="sd">            non-existing AND has no existing &quot;symmetric identical&quot;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        grids.Grid.getSymmetricEquivalents</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">neighborIndices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getNeighboringCellIndices</span><span class="p">(</span>
            <span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="n">dupReflectors</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">THIRD_CORE</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">boundary</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">PERIODIC</span>
            <span class="ow">and</span> <span class="n">duplicateAssembliesOnReflectiveBoundary</span>
        <span class="p">)</span>

        <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iN</span><span class="p">,</span> <span class="n">jN</span><span class="p">,</span> <span class="n">kN</span> <span class="ow">in</span> <span class="n">neighborIndices</span><span class="p">:</span>
            <span class="n">neighborLoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="n">iN</span><span class="p">,</span> <span class="n">jN</span><span class="p">,</span> <span class="n">kN</span><span class="p">]</span>
            <span class="n">neighbor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">neighborLoc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">showBlanks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dupReflectors</span><span class="p">:</span>
                    <span class="n">symmetricAssem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getReflectiveDuplicateAssembly</span><span class="p">(</span><span class="n">neighborLoc</span><span class="p">)</span>
                    <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symmetricAssem</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">neighbors</span></div>

    <span class="k">def</span> <span class="nf">_getReflectiveDuplicateAssembly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">neighborLoc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return duplicate assemblies accross symmetry line.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If an existing symmetric identical has been found, return it.</span>
<span class="sd">        If an existing symmetric identical has NOT been found, return a None (it&#39;s empty).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">otherTwoLocations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getSymmetricEquivalents</span><span class="p">(</span><span class="n">neighborLoc</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">otherTwoLocations</span><span class="p">:</span>
            <span class="n">neighborLocation2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">duplicateAssem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">neighborLocation2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">duplicateAssem</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">duplicates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">duplicateAssem</span><span class="p">)</span>
        <span class="c1"># should always be 0 or 1</span>
        <span class="n">nDuplicates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicates</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nDuplicates</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">duplicates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">nDuplicates</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too many neighbors found!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="Core.setMoveList"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.setMoveList">[docs]</a>    <span class="k">def</span> <span class="nf">setMoveList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">oldLoc</span><span class="p">,</span> <span class="n">newLoc</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="n">assemblyType</span><span class="p">,</span> <span class="n">assemName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tracks the movements in terms of locations and enrichments.&quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">oldLoc</span><span class="p">,</span> <span class="n">newLoc</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="n">assemblyType</span><span class="p">,</span> <span class="n">assemName</span><span class="p">)</span>
        <span class="c1"># NOTE: moveList is actually a moveDict (misnomer)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveList</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moveList</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moveList</span><span class="p">[</span><span class="n">cycle</span><span class="p">]:</span>
            <span class="c1"># remove the old version and throw the new on at the end.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moveList</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moveList</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.createFreshFeed"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.createFreshFeed">[docs]</a>    <span class="k">def</span> <span class="nf">createFreshFeed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new feed assembly.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        createAssemblyOfType: creates an assembly</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        createFreshFeed and createAssemblyOfType and this</span>
<span class="sd">        all need to be merged together somehow.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">createAssemblyOfType</span><span class="p">(</span><span class="n">assemType</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_freshFeedType</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.createAssemblyOfType"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.createAssemblyOfType">[docs]</a>    <span class="k">def</span> <span class="nf">createAssemblyOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enrichList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an assembly of a specific type and apply enrichments if they are specified</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        assemType : str</span>
<span class="sd">            The assembly type to create</span>
<span class="sd">        enrichList : list</span>
<span class="sd">            weight percent enrichments of each block</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a : Assembly</span>
<span class="sd">            A new assembly</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This and similar fuel shuffle-enabling functionality on the Core are responsible</span>
<span class="sd">        for coupling between the Core and Blueprints. Technically, it should not be</span>
<span class="sd">        required to involve Blueprints at all in the construction of a Reactor model.</span>
<span class="sd">        Therefore in some circumstances, this function will not work. Ultimately, this</span>
<span class="sd">        should be purely the domain of blueprints themselves, and may be migrated out of</span>
<span class="sd">        Core in the future.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.fuelHandler.doRepeatShuffle : uses this to repeat shuffling</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">blueprints</span><span class="o">.</span><span class="n">constructAssem</span><span class="p">(</span>
            <span class="n">cs</span> <span class="ow">or</span> <span class="n">settings</span><span class="o">.</span><span class="n">getMasterCs</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="n">assemType</span>
        <span class="p">)</span>

        <span class="c1"># check to see if a default bol assembly is being used or we are adding more information</span>
        <span class="k">if</span> <span class="n">enrichList</span><span class="p">:</span>
            <span class="c1"># got an enrichment list that should be the same height as the fuel blocks</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">enrichList</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="c1"># make endlessly iterable if float was passed in</span>
                <span class="n">enrichList</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">([</span><span class="n">enrichList</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">enrichList</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> and enrichment list do not have the same number of blocks.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">a</span>
                    <span class="p">)</span>
                <span class="p">)</span>

            <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">enrich</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">enrich</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="c1"># don&#39;t change blocks when enrich specified as 0</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">getUraniumMassEnrich</span><span class="p">()</span> <span class="o">-</span> <span class="n">enrich</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                    <span class="c1"># only adjust block enrichment if it&#39;s different.</span>
                    <span class="c1"># WARNING: If this is not fresh fuel, this messes up the number of moles of HM at BOL and</span>
                    <span class="c1"># therefore breaks the burnup metric.</span>
                    <span class="n">b</span><span class="o">.</span><span class="n">adjustUEnrich</span><span class="p">(</span><span class="n">enrich</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="Core.saveAllFlux"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.saveAllFlux">[docs]</a>    <span class="k">def</span> <span class="nf">saveAllFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fName</span><span class="o">=</span><span class="s2">&quot;allFlux.txt&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dump all flux to file for debugging purposes.&quot;&quot;&quot;</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">())</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">numGroups</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fName</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">gi</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{:10s}</span><span class="s2"> </span><span class="si">{:10d}</span><span class="s2"> </span><span class="si">{:12.5E}</span><span class="s2"> </span><span class="si">{:12.5E}</span><span class="s2"> </span><span class="si">{:12.5E}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">block</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span>
                            <span class="n">gi</span><span class="p">,</span>
                            <span class="n">block</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span><span class="p">[</span><span class="n">gi</span><span class="p">],</span>
                            <span class="n">block</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">adjMgFlux</span><span class="p">[</span><span class="n">gi</span><span class="p">],</span>
                            <span class="n">block</span><span class="o">.</span><span class="n">getVolume</span><span class="p">(),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">adjMgFlux</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">groups</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Too many flux values: </span><span class="si">{}</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">block</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">adjMgFlux</span>
                        <span class="p">)</span>
                    <span class="p">)</span></div>

<div class="viewcode-block" id="Core.getAssembliesOnSymmetryLine"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAssembliesOnSymmetryLine">[docs]</a>    <span class="k">def</span> <span class="nf">getAssembliesOnSymmetryLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symmetryLineID</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find assemblies that are on a symmetry line in a symmetric core.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">assembliesOnLine</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">isOnWhichSymmetryLine</span><span class="p">()</span> <span class="o">==</span> <span class="n">symmetryLineID</span><span class="p">:</span>
                <span class="n">assembliesOnLine</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="c1"># in order of innermost to outermost (for averaging)</span>
        <span class="n">assembliesOnLine</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">assembliesOnLine</span></div>

<div class="viewcode-block" id="Core.buildZones"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.buildZones">[docs]</a>    <span class="k">def</span> <span class="nf">buildZones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the zones on the reactor.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zones</span> <span class="o">=</span> <span class="n">zones</span><span class="o">.</span><span class="n">buildZones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zones</span> <span class="o">=</span> <span class="n">zones</span><span class="o">.</span><span class="n">splitZones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zones</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.getCoreRadius"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getCoreRadius">[docs]</a>    <span class="k">def</span> <span class="nf">getCoreRadius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a radius that the core would fit into.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumRings</span><span class="p">(</span><span class="n">indexBased</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFirstBlock</span><span class="p">()</span><span class="o">.</span><span class="n">getPitch</span><span class="p">()</span></div>

<div class="viewcode-block" id="Core.findAllMeshPoints"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.findAllMeshPoints">[docs]</a>    <span class="k">def</span> <span class="nf">findAllMeshPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all mesh positions in core including both endpoints.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        assems : list, optional</span>
<span class="sd">            assemblies to consider when determining the mesh points. If not given, all in-core assemblies are used.</span>
<span class="sd">        applySubMesh : bool, optional</span>
<span class="sd">            Apply submeshing parameters to make mesh points smaller than blocks. Default=True.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        meshVals : tuple</span>
<span class="sd">            ((i-vals), (j-vals,), (k-vals,))</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.assemblies.Assembly.getAxialMesh : get block mesh</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        These include all mesh points, not just block boundaries. There may be multiple mesh points</span>
<span class="sd">        per block.</span>

<span class="sd">        If a large block with multiple mesh points is in the same core as arbitrarily-expanded fuel blocks</span>
<span class="sd">        from fuel performance, an imbalanced axial mesh may result.</span>

<span class="sd">        There is a challenge with TRZ blocks because we need the mesh centroid in terms of RZT, not XYZ</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Finding all mesh points.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">assems</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">assems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">iMesh</span><span class="p">,</span> <span class="n">jMesh</span><span class="p">,</span> <span class="n">kMesh</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assems</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                <span class="c1"># these params should be combined into a new b.p.meshSubdivisions tuple</span>
                <span class="n">numPoints</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">AziMesh</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">RadMesh</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axMesh</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">applySubMesh</span>
                    <span class="k">else</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCellBase</span><span class="p">()</span>
                <span class="c1"># make sure this is in mesh coordinates (important to have TRZ, not XYZ in TRZ cases</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCellTop</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">subdivisions</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">((</span><span class="n">iMesh</span><span class="p">,</span> <span class="n">jMesh</span><span class="p">,</span> <span class="n">kMesh</span><span class="p">),</span> <span class="n">numPoints</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">axisVal</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>  <span class="c1"># convert from numpy.float64</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">top</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">axisVal</span><span class="p">)</span> <span class="o">/</span> <span class="n">subdivisions</span>
                    <span class="k">for</span> <span class="n">_subdivision</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subdivisions</span><span class="p">):</span>
                        <span class="n">collection</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">axisVal</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">FLOAT_DIMENSION_DECIMALS</span><span class="p">))</span>
                        <span class="n">axisVal</span> <span class="o">+=</span> <span class="n">step</span>
                    <span class="c1"># add top too (only needed for last point)</span>
                    <span class="n">collection</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">axisVal</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">FLOAT_DIMENSION_DECIMALS</span><span class="p">))</span>

        <span class="n">iMesh</span><span class="p">,</span> <span class="n">jMesh</span><span class="p">,</span> <span class="n">kMesh</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">sorted</span><span class="p">,</span> <span class="p">(</span><span class="n">iMesh</span><span class="p">,</span> <span class="n">jMesh</span><span class="p">,</span> <span class="n">kMesh</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">iMesh</span><span class="p">,</span> <span class="n">jMesh</span><span class="p">,</span> <span class="n">kMesh</span></div>

<div class="viewcode-block" id="Core.findAllAxialMeshPoints"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.findAllAxialMeshPoints">[docs]</a>    <span class="k">def</span> <span class="nf">findAllAxialMeshPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of all z-mesh positions in the core including zero and the top.&quot;&quot;&quot;</span>
        <span class="n">_i</span><span class="p">,</span> <span class="n">_j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findAllMeshPoints</span><span class="p">(</span><span class="n">assems</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">k</span></div>

<div class="viewcode-block" id="Core.updateAxialMesh"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.updateAxialMesh">[docs]</a>    <span class="k">def</span> <span class="nf">updateAxialMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update axial mesh based on perturbed meshes of the assemblies that are linked to the ref assem.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        While processLoading finds *all* axial mesh points, this method only updates the values of the</span>
<span class="sd">        known mesh with the current assembly heights. **This does not change the number of mesh points**.</span>

<span class="sd">        If ``detailedAxialExpansion`` is active, the global axial mesh param still only tracks the refAssem.</span>
<span class="sd">        Otherwise, thousands upon thousands of mesh points would get created.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        processLoading : sets up the master mesh that this perturbs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># most of the time, we want fuel, but they should mostly have the same number of blocks</span>
        <span class="c1"># if this becomes a problem, we might find either the</span>
        <span class="c1">#  1. mode: (len(a) for a in self).mode(), or</span>
        <span class="c1">#  2. max: max(len(a) for a in self)</span>
        <span class="c1"># depending on what makes the most sense</span>
        <span class="n">refAssem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refAssem</span>
        <span class="n">refMesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findAllAxialMeshPoints</span><span class="p">([</span><span class="n">refAssem</span><span class="p">])</span>
        <span class="n">avgHeight</span> <span class="o">=</span> <span class="n">average1DWithinTolerance</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">[</span>
                        <span class="n">h</span>
                        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span>
                        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">zbottom</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axMesh</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axMesh</span>
                    <span class="p">]</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">findAllAxialMeshPoints</span><span class="p">([</span><span class="n">a</span><span class="p">])</span> <span class="o">==</span> <span class="n">refMesh</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axialMesh</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">avgHeight</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()))</span></div>

<div class="viewcode-block" id="Core.findAxialMeshIndexOf"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.findAxialMeshIndexOf">[docs]</a>    <span class="k">def</span> <span class="nf">findAxialMeshIndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heightCm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the axial index of the axial node corresponding to this height.</span>

<span class="sd">        If the height lies on the boundary between two nodes, the lower node index</span>
<span class="sd">        is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        heightCm : float</span>
<span class="sd">            The height (cm) from the assembly bottom.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        zIndex : int</span>
<span class="sd">            The axial index (beginning with 0) of the mesh node containing the given height.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">zi</span><span class="p">,</span> <span class="n">currentHeightCm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axialMesh</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="k">if</span> <span class="n">currentHeightCm</span> <span class="o">&gt;=</span> <span class="n">heightCm</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">zi</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The value </span><span class="si">{}</span><span class="s2"> cm is not within range of the reactor axial mesh with max </span><span class="si">{}</span><span class="s2">&quot;</span>
            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">heightCm</span><span class="p">,</span> <span class="n">currentHeightCm</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Core.addMoreNodes"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.addMoreNodes">[docs]</a>    <span class="k">def</span> <span class="nf">addMoreNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meshList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add additional mesh points in the the meshList so that the ratio of mesh sizes does not vary too fast.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minMeshSizeRatio</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">innerMeshVal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meshList</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dP0</span> <span class="o">=</span> <span class="n">innerMeshVal</span> <span class="o">-</span> <span class="n">meshList</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">dP1</span> <span class="o">=</span> <span class="n">meshList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">innerMeshVal</span>

            <span class="k">if</span> <span class="n">dP0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dP0</span> <span class="o">+</span> <span class="n">dP1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ratio</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Mesh gap too small. Adjusting mesh to be more reasonable.&quot;</span>
                <span class="p">)</span>
                <span class="n">meshList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">innerMeshVal</span> <span class="o">+</span> <span class="n">dP1</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">)</span>
                <span class="n">meshList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">meshList</span><span class="p">,</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">dP0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dP0</span> <span class="o">+</span> <span class="n">dP1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">ratio</span><span class="p">):</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Mesh gap too large. Adjusting mesh to be more reasonable.&quot;</span>
                <span class="p">)</span>
                <span class="n">meshList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meshList</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dP0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">ratio</span><span class="p">))</span>
                <span class="n">meshList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">meshList</span><span class="p">,</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">meshList</span><span class="p">,</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Core.findAllAziMeshPoints"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.findAllAziMeshPoints">[docs]</a>    <span class="k">def</span> <span class="nf">findAllAziMeshPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extraAssems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns a list of all azimuthal (theta)-mesh positions in the core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extraAssems : list</span>
<span class="sd">            additional assemblies to consider when determining the mesh points.</span>
<span class="sd">            They may be useful in the MCPNXT models to represent the fuel management dummies.</span>

<span class="sd">        applySubMesh : bool</span>
<span class="sd">            generates submesh points to further discretize the theta reactor mesh</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findAllMeshPoints</span><span class="p">(</span><span class="n">extraAssems</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">i</span></div>

<div class="viewcode-block" id="Core.findAllRadMeshPoints"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.findAllRadMeshPoints">[docs]</a>    <span class="k">def</span> <span class="nf">findAllRadMeshPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extraAssems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of all radial-mesh positions in the core.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extraAssems : list</span>
<span class="sd">            additional assemblies to consider when determining the mesh points.  They may</span>
<span class="sd">            be useful in the MCPNXT models to represent the fuel management dummies.</span>

<span class="sd">        applySubMesh : bool</span>
<span class="sd">            (not implemented) generates submesh points to further discretize the radial</span>
<span class="sd">            reactor mesh</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findAllMeshPoints</span><span class="p">(</span><span class="n">extraAssems</span><span class="p">,</span> <span class="n">applySubMesh</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">j</span></div>

<div class="viewcode-block" id="Core.getMaxBlockParam"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getMaxBlockParam">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxBlockParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get max param over blocks&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;generationNum&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot getMaxBlockParam over anything but blocks. Prefer `getMaxParam`.&quot;</span>
            <span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;generationNum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxParam</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.getTotalBlockParam"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getTotalBlockParam">[docs]</a>    <span class="k">def</span> <span class="nf">getTotalBlockParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get total param over blocks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;generationNum&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot getTotalBlockParam over anything but blocks. Prefer `calcTotalParam`.&quot;</span>
            <span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;generationNum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcTotalParam</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.getMaxNumPins"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getMaxNumPins">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxNumPins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;find max number of pins of any block in the reactor&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">())</span></div>

<div class="viewcode-block" id="Core.getMinimumPercentFluxInFuel"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getMinimumPercentFluxInFuel">[docs]</a>    <span class="k">def</span> <span class="nf">getMinimumPercentFluxInFuel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mf">0.005</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Goes through the entire reactor to determine what percentage of flux occures at</span>
<span class="sd">        each ring.  Starting with the outer ring, this function helps determine the effective</span>
<span class="sd">        size of the core where additional assemblies will not help the breeding in the TWR.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        target : float</span>
<span class="sd">            This is the fraction of the total reactor fuel flux compared to the flux in a</span>
<span class="sd">            specific assembly in a ring</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        targetRing, fraction of flux : tuple</span>
<span class="sd">            targetRing is the ring with the fraction of flux that best meets the target.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the total number of assembly rings</span>
        <span class="n">numRings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumRings</span><span class="p">()</span>

        <span class="c1"># old target assembly fraction</span>
        <span class="n">fluxFraction</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">targetRing</span> <span class="o">=</span> <span class="n">numRings</span>

        <span class="n">allFuelBlocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">))</span>

        <span class="c1"># loop there all of the rings</span>
        <span class="k">for</span> <span class="n">ringNumber</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numRings</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># compare to outer most ring</span>
            <span class="c1"># flatten list into one list of all blocks</span>
            <span class="n">blocksInRing</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                    <span class="o">*</span><span class="p">[</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssembliesInRing</span><span class="p">(</span><span class="n">ringNumber</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># TODO: itertools.chain.from_iterable(...)</span>

            <span class="n">totalPower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTotalBlockParam</span><span class="p">(</span><span class="s2">&quot;flux&quot;</span><span class="p">,</span> <span class="n">objs</span><span class="o">=</span><span class="n">allFuelBlocks</span><span class="p">)</span>
            <span class="n">ringPower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTotalBlockParam</span><span class="p">(</span><span class="s2">&quot;flux&quot;</span><span class="p">,</span> <span class="n">objs</span><span class="o">=</span><span class="n">blocksInRing</span><span class="p">)</span>

            <span class="c1"># make sure that there is a non zero return</span>
            <span class="k">if</span> <span class="n">fluxFraction</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ringPower</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fluxFraction</span> <span class="o">=</span> <span class="n">ringPower</span> <span class="o">/</span> <span class="n">totalPower</span>
                <span class="n">targetRing</span> <span class="o">=</span> <span class="n">ringNumber</span>

            <span class="c1"># this will only get the leakage if the target fraction isn&#39;t too low</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">ringPower</span> <span class="o">/</span> <span class="n">totalPower</span> <span class="o">&lt;</span> <span class="n">target</span>
                <span class="ow">and</span> <span class="n">ringPower</span> <span class="o">/</span> <span class="n">totalPower</span> <span class="o">&gt;</span> <span class="n">fluxFraction</span>
            <span class="p">):</span>
                <span class="n">fluxFraction</span> <span class="o">=</span> <span class="n">ringPower</span> <span class="o">/</span> <span class="n">totalPower</span>
                <span class="n">targetRing</span> <span class="o">=</span> <span class="n">ringNumber</span>

        <span class="k">return</span> <span class="n">targetRing</span><span class="p">,</span> <span class="n">fluxFraction</span></div>

<div class="viewcode-block" id="Core.getAvgTemp"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAvgTemp">[docs]</a>    <span class="k">def</span> <span class="nf">getAvgTemp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">blockList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flux2Weight</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get the volume-average fuel, cladding, coolant temperature in core</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or list of Flags</span>
<span class="sd">            Component types to consider. If typeSpec is a list, then you get the volume average</span>
<span class="sd">            temperature of all components. For instance, getAvgTemp([Flags.CLAD, Flags.WIRE,</span>
<span class="sd">            Flags.DUCT]) returns the avg. structure temperature.</span>

<span class="sd">        blockList : list, optional</span>
<span class="sd">            Blocks to consider. If None, all blocks in core will be considered</span>

<span class="sd">        flux2Weight : bool, optional</span>
<span class="sd">            If true, will weight temperature against flux**2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        avgTemp : float</span>
<span class="sd">            The average temperature in C.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">blockList</span><span class="p">:</span>
            <span class="n">blockList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">blockList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flux2Weight</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flux</span> <span class="o">**</span> <span class="mf">2.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">):</span>
                <span class="n">vol</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>
                <span class="n">num</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">temperatureInC</span> <span class="o">*</span> <span class="n">vol</span> <span class="o">*</span> <span class="n">weight</span>
                <span class="n">denom</span> <span class="o">+=</span> <span class="n">vol</span> <span class="o">*</span> <span class="n">weight</span>

        <span class="k">if</span> <span class="n">denom</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;no temperature average for </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">))</span></div>

<div class="viewcode-block" id="Core.getAllNuclidesIn"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getAllNuclidesIn">[docs]</a>    <span class="k">def</span> <span class="nf">getAllNuclidesIn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mats</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all nuclides that are present in these materials anywhere in the core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mats : iterable or Material</span>
<span class="sd">            List (or single) of materials to scan the full core for, accumulating a master nuclide list</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        allNucNames : list</span>
<span class="sd">            All nuclide names in this material anywhere in the reactor</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getDominantMaterial : finds the most prevalent material in a certain type of blocks</span>
<span class="sd">        Block.adjustDensity : modifies nuclides in a block</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you need to know the nuclides in a fuel pin, you can&#39;t just use the sample returned</span>
<span class="sd">        from getDominantMaterial, because it may be a fresh fuel material (U and Zr) even though</span>
<span class="sd">        there are burned materials elsewhere (with U, Zr, Pu, LFP, etc.).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mats</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># single material passed in</span>
            <span class="n">mats</span> <span class="o">=</span> <span class="p">[</span><span class="n">mats</span><span class="p">]</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mats</span><span class="p">)</span>
        <span class="n">allNucNames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="n">allNucNames</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getNuclides</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">allNucNames</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.growToFullCore"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.growToFullCore">[docs]</a>    <span class="k">def</span> <span class="nf">growToFullCore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;copies symmetric assemblies to build a full core model out of a 1/3 core model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        converter : GeometryConverter</span>
<span class="sd">            Geometry converter used to do the conversion.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">armi.reactor.converters.geometryConverters</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">ThirdCoreHexToFullCoreChanger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">converter</span> <span class="o">=</span> <span class="n">ThirdCoreHexToFullCoreChanger</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="n">converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">converter</span></div>

<div class="viewcode-block" id="Core.setPitchUniform"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.setPitchUniform">[docs]</a>    <span class="k">def</span> <span class="nf">setPitchUniform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pitchInCm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        set the pitch in all blocks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">():</span>
            <span class="n">b</span><span class="o">.</span><span class="n">setPitch</span><span class="p">(</span><span class="n">pitchInCm</span><span class="p">)</span>

        <span class="c1"># have to update the 2-D reactor mesh too.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">changePitch</span><span class="p">(</span><span class="n">pitchInCm</span><span class="p">)</span></div>

<div class="viewcode-block" id="Core.calcBlockMaxes"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.calcBlockMaxes">[docs]</a>    <span class="k">def</span> <span class="nf">calcBlockMaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        searches all blocks for maximum values of key params</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.physics.optimize.OptimizationInterface.interactBOL : handles these maxes in optimization cases</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># restrict to fuel</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="o">.</span><span class="n">inCategory</span><span class="p">(</span><span class="s2">&quot;block-max&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">maxVal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxBlockParam</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">maxVal</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxVal</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">continue</span>

        <span class="c1"># add maxes based on pin-level max if it exists, block level max otherwise.</span>
        <span class="c1"># may want to use percentBuMax for pin-detailed cases.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">maxBuF</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">a</span><span class="o">.</span><span class="n">getMaxParam</span><span class="p">(</span><span class="s2">&quot;percentBu&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FEED</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">maxBuI</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">a</span><span class="o">.</span><span class="n">getMaxParam</span><span class="p">(</span><span class="s2">&quot;percentBu&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">Flags</span><span class="o">.</span><span class="n">IGNITER</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span>
                        <span class="n">Flags</span><span class="o">.</span><span class="n">DRIVER</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span>
                        <span class="n">Flags</span><span class="o">.</span><span class="n">STARTER</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">),</span>
            <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Core.getFuelBottomHeight"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.getFuelBottomHeight">[docs]</a>    <span class="k">def</span> <span class="nf">getFuelBottomHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain the height of the lowest fuel in the core.</span>

<span class="sd">        This is the &quot;axial coordinate shift&quot; between ARMI and SASSYS.</span>
<span class="sd">        While ARMI sets z=0 at the bottom of the lowest block (usually the</span>
<span class="sd">        grid plate), SASSYS sets z=0 at the bottom of the fuel.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lowestFuelHeightInCm : float</span>
<span class="sd">            The height (cm) of the lowest fuel in this core model.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lowestFuelHeightInCm</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
        <span class="n">fuelBottoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">):</span>
            <span class="n">fuelHeightInCm</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fuelHeightInCm</span> <span class="o">+=</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">fuelHeightInCm</span> <span class="o">&lt;</span> <span class="n">lowestFuelHeightInCm</span><span class="p">:</span>
                <span class="n">lowestFuelHeightInCm</span> <span class="o">=</span> <span class="n">fuelHeightInCm</span>
            <span class="n">fuelBottoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fuelHeightInCm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lowestFuelHeightInCm</span></div>

<div class="viewcode-block" id="Core.processLoading"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.reactors.html#armi.reactor.reactors.Core.processLoading">[docs]</a>    <span class="k">def</span> <span class="nf">processLoading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        After nuclide densities are loaded, this goes through and prepares the reactor.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This does a few operations :</span>
<span class="sd">         * It process boosters,</span>
<span class="sd">         * sets axial snap lists,</span>
<span class="sd">         * checks the geometry,</span>
<span class="sd">         * sets up location tables ( tracks where the initial feeds were (for moderation or something)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        updateAxialMesh : Perturbs the axial mesh originally set up here.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">header</span><span class="p">(</span>
            <span class="s2">&quot;=========== Initializing Mesh, Assembly Zones, and Nuclide Categories =========== &quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOL</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Good easter egg, but sometimes a user will want to use the framework do</span>
            <span class="c1"># only decay analyses and heavy metals are not required.</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;The system has no heavy metal and therefore is not a nuclear reactor.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Please make sure that this is intended and not a input error.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axialMesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findAllAxialMeshPoints</span><span class="p">()</span>
        <span class="n">refAssem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refAssem</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;detailedAxialExpansion&quot;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">includeBolAssems</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="c1"># prepare for mesh snapping during axial expansion</span>
                <span class="n">a</span><span class="o">.</span><span class="n">makeAxialSnapList</span><span class="p">(</span><span class="n">refAssem</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">numRings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumRings</span><span class="p">()</span>  <span class="c1"># TODO: why needed?</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">getNuclideCategories</span><span class="p">()</span>

        <span class="c1"># some blocks will not move in the core like grid plates... Find them and fix them in place</span>
        <span class="n">stationaryBlocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># look for blocks that should not be shuffled in an assembly.  It is assumed that the</span>
        <span class="c1"># reference assembly has all the fixed block information and it is the same for all assemblies</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">refAssem</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">GRID_PLATE</span><span class="p">):</span>
                <span class="n">stationaryBlocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="c1"># TODO: remove hard-coded assumption of grid plates (T3019)</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
                    <span class="s2">&quot;Detected a grid plate </span><span class="si">{}</span><span class="s2">.  Adding to stationary blocks&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="n">cs</span><span class="p">[</span><span class="s2">&quot;stationaryBlocks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stationaryBlocks</span>

        <span class="c1"># Perform initial zoning task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buildZones</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">maxAssemNum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxParam</span><span class="p">(</span><span class="s2">&quot;assemNum&quot;</span><span class="p">)</span>

        <span class="n">getPluginManagerOrFail</span><span class="p">()</span><span class="o">.</span><span class="n">hook</span><span class="o">.</span><span class="n">onProcessCoreLoading</span><span class="p">(</span><span class="n">core</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2009-2022, TerraPower, LLC.
      <span class="lastupdated">
        Last updated on 2022-06-16.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
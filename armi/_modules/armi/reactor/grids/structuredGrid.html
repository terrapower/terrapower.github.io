<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>armi.reactor.grids.structuredGrid &mdash; ARMI 0.4.0 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme_fixes.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-rendered-html.css" type="text/css" />
    <link rel="shortcut icon" href="../../../../_static/armiicon_16x16.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            ARMI
              <img src="../../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.4.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../.apidocs/modules.html">API Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #233C5B" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ARMI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../../armi.html">armi</a></li>
          <li class="breadcrumb-item"><a href="../../reactor.html">armi.reactor</a></li>
          <li class="breadcrumb-item"><a href="../grids.html">armi.reactor.grids</a></li>
      <li class="breadcrumb-item active">armi.reactor.grids.structuredGrid</li>
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for armi.reactor.grids.structuredGrid</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2023 Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">armi.reactor.grids.grid</span> <span class="kn">import</span> <span class="n">Grid</span>
<span class="kn">from</span> <span class="nn">armi.reactor.grids.locations</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">IJKType</span><span class="p">,</span>
    <span class="n">IndexLocation</span><span class="p">,</span>
    <span class="n">LocationBase</span><span class="p">,</span>
    <span class="n">MultiIndexLocation</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># data structure for database-serialization of grids</span>
<span class="n">GridParameters</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span>
    <span class="s2">&quot;GridParameters&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;unitSteps&quot;</span><span class="p">,</span> <span class="s2">&quot;bounds&quot;</span><span class="p">,</span> <span class="s2">&quot;unitStepLimits&quot;</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="s2">&quot;geomType&quot;</span><span class="p">,</span> <span class="s2">&quot;symmetry&quot;</span><span class="p">),</span>
<span class="p">)</span>


<div class="viewcode-block" id="StructuredGrid"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid">[docs]</a><span class="k">class</span> <span class="nc">StructuredGrid</span><span class="p">(</span><span class="n">Grid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A connected set of cells characterized by indices mapping to space and vice versa.</span>

<span class="sd">    The cells may be characterized by any mixture of regular repeating steps and</span>
<span class="sd">    user-defined steps in any direction.</span>

<span class="sd">    For example, a 2-D hex lattice has constant, regular steps whereas a 3-D hex mesh</span>
<span class="sd">    may have user-defined axial meshes. Similar for Cartesian, RZT, etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unitSteps : tuple of tuples, optional</span>
<span class="sd">        Describes the grid spatially as a function on indices.</span>
<span class="sd">        Each tuple describes how each ``(x,y,or z)`` dimension is influenced by</span>
<span class="sd">        ``(i,j,k)``. In other words, it is::</span>

<span class="sd">            (dxi, dxj, jxk), (dyi, dyj, dyk), (dzi, dzj, dzk)</span>

<span class="sd">        where ``dmn`` is the distance (in cm) that dimension ``m`` will change as a</span>
<span class="sd">        function of index ``n``.</span>

<span class="sd">        Unit steps are used as a generic method for defining repetitive grids in a</span>
<span class="sd">        variety of geometries, including hexagonal and Cartesian.  The tuples are not</span>
<span class="sd">        vectors in the direction of the translation, but rather grouped by direction. If</span>
<span class="sd">        the bounds argument is described for a direction, the bounds will be used rather</span>
<span class="sd">        than the unit step information. The default of (0, 0, 0) makes all dimensions</span>
<span class="sd">        insensitive to indices since the coordinates are calculated by the dot product</span>
<span class="sd">        of this and the indices.  With this default, any dimension that is desired to</span>
<span class="sd">        change with indices should be defined with bounds. RZtheta grids are created</span>
<span class="sd">        exclusively with bounds.</span>
<span class="sd">    bounds : 3-tuple</span>
<span class="sd">        Absolute increasing bounds in cm including endpoints of a non-uniform grid.</span>
<span class="sd">        Each item represents the boundaries in the associated direction.  Use Nones when</span>
<span class="sd">        unitSteps should be applied instead. Most useful for thetaRZ grids or other</span>
<span class="sd">        non-uniform grids.</span>
<span class="sd">    unitStepLimits : 3-tuple</span>
<span class="sd">        The limit of the steps in all three directions. This constrains step-defined</span>
<span class="sd">        grids to be finite so we can populate them with SpatialLocator objects.</span>
<span class="sd">    offset : 3-tuple, optional</span>
<span class="sd">        Offset in cm for each axis. By default the center of the (0,0,0)-th object is in</span>
<span class="sd">        the center of the grid. Offsets can move it so that the (0,0,0)-th object can</span>
<span class="sd">        be fully within a quadrant (i.e. in a Cartesian grid).</span>
<span class="sd">    armiObject : ArmiObject, optional</span>
<span class="sd">        The ArmiObject that this grid describes. For example if it&#39;s a 1-D assembly</span>
<span class="sd">        grid, the armiObject is the assembly. Note that ``self.armiObject.spatialGrid``</span>
<span class="sd">        is ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A 2D a rectangular grid with width (x) 2 and height (y) 3 would be::</span>

<span class="sd">    &gt;&gt;&gt; grid = Grid(unitSteps=((2, 0, 0), (0, 3, 0),(0, 0, 0)))</span>

<span class="sd">    A regular hex grid with pitch 1 is::</span>

<span class="sd">    &gt;&gt;&gt; grid = Grid(unitSteps= ((sqrt(3)/2, 0.0, 0.0), (0.5, 1.0, 0.0), (0, 0, 0))</span>

<span class="sd">    .. note:: For this unit hex the magnitude of the vector constructed using the</span>
<span class="sd">              0th index of each tuple is 1.0.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Each dimension must either be defined through unitSteps or bounds.</span>
<span class="sd">    The combination of unitSteps with bounds was settled upon after some struggle to</span>
<span class="sd">    have one unified definition of a grid (i.e. just bounds). A hexagonal grid is</span>
<span class="sd">    somewhat challenging to represent with bounds because the axes are not orthogonal,</span>
<span class="sd">    so a unit-direction vector plus bounds would be required. And then the bounds would</span>
<span class="sd">    be wasted space because they can be derived simply by unit steps. Memory efficiency</span>
<span class="sd">    is important in this object so the compact representation of</span>
<span class="sd">    unitSteps-when-possible, bounds-otherwise was settled upon.</span>

<span class="sd">    Design considerations include:</span>

<span class="sd">    * unitSteps are more intuitive as operations starting from the center of a cell,</span>
<span class="sd">      particularly with hexagons and rectangles. Otherwise the 0,0 position of a hexagon</span>
<span class="sd">      in the center of 1/3-symmetric hexagon is at the phantom bottom left of the</span>
<span class="sd">      hexagon.</span>

<span class="sd">    * Users generally prefer to input mesh bounds rather than centers (e.g. starting at</span>
<span class="sd">      0.5 instead of 0.0 in a unit mesh is weird).</span>

<span class="sd">    * If we store bounds, computing bounds is simple and computing centers takes ~2x the</span>
<span class="sd">      effort. If we store centers, it&#39;s the opposite.</span>

<span class="sd">    * Regardless of how we store things, we&#39;ll need a Grid that has the lower-left</span>
<span class="sd">      assembly fully inside the problem (i.e. for full core Cartesian) as well as</span>
<span class="sd">      another one that has the lower-left assembly half-way or quarter-way sliced off</span>
<span class="sd">      (for 1/2, 1/4, and 1/8 symmetries).  The ``offset`` parameter handles this.</span>

<span class="sd">    * Looking up mesh boundaries (to define a mesh in another code) is generally more</span>
<span class="sd">      common than looking up centers (for plotting or measuring distance).</span>

<span class="sd">    * A grid can be anchored to the object that it is in with a backreference. This</span>
<span class="sd">      gives it the ability to traverse the composite tree and map local to global</span>
<span class="sd">      locations without having to duplicate the composite pattern on grids. This remains</span>
<span class="sd">      optional so grids can be used for non-reactor-package reasons.  It may seem</span>
<span class="sd">      slightly cleaner to set the armiObject to the parent&#39;s spatialLocator itself</span>
<span class="sd">      but the major disadvantage of this is that when an object moves, the armiObject</span>
<span class="sd">      would have to be updated. By anchoring directly to Composite objects, the parent</span>
<span class="sd">      is always up to date no matter where or how things get moved.</span>

<span class="sd">    * Unit step calculations use dot products and must not be polluted by the bound</span>
<span class="sd">      indices. Thus we reduce the size of the unitSteps tuple accordingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">unitSteps</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">unitStepLimits</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">geomType</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">symmetry</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">armiObject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">geomType</span><span class="p">,</span> <span class="n">symmetry</span><span class="p">,</span> <span class="n">armiObject</span><span class="p">)</span>
        <span class="c1"># these lists contain the indices representing which dimensions for which steps</span>
        <span class="c1"># are used, or for which bounds are used. index 0 is x direction, etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundDims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dimensionIndex</span><span class="p">,</span> <span class="n">bound</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bounds</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimensionIndex</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_boundDims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimensionIndex</span><span class="p">)</span>

        <span class="c1"># numpy prefers tuples like this to do slicing on arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundDims</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundDims</span><span class="p">),)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span><span class="p">),)</span>

        <span class="n">unitSteps</span> <span class="o">=</span> <span class="n">_tuplify</span><span class="p">(</span><span class="n">unitSteps</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unitStepLimits</span> <span class="o">=</span> <span class="n">_tuplify</span><span class="p">(</span><span class="n">unitStepLimits</span><span class="p">)</span>

        <span class="c1"># only represent unit steps in dimensions they&#39;re being used so as to not</span>
        <span class="c1"># pollute the dot product. This may reduce the length of this from 3 to 2 or 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unitSteps</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buildLocations</span><span class="p">()</span>  <span class="c1"># locations are owned by a grid, so the grid builds them.</span>

        <span class="p">(</span><span class="n">_ii</span><span class="p">,</span> <span class="n">iLen</span><span class="p">),</span> <span class="p">(</span><span class="n">_ji</span><span class="p">,</span> <span class="n">jLen</span><span class="p">),</span> <span class="p">(</span><span class="n">_ki</span><span class="p">,</span> <span class="n">kLen</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getIndexBounds</span><span class="p">()</span>
        <span class="c1"># True if only contains k-cells.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_isAxialOnly</span> <span class="o">=</span> <span class="n">iLen</span> <span class="o">==</span> <span class="n">jLen</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">kLen</span> <span class="o">&gt;</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isAxialOnly</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isAxialOnly</span>

<div class="viewcode-block" id="StructuredGrid.reduce"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.reduce">[docs]</a>    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GridParameters</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recreate the parameter necessary to create this grid.&quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">)</span>

        <span class="n">bounds</span> <span class="o">=</span> <span class="n">_tuplify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">)</span>

        <span class="c1"># recreate a constructor-friendly version of `_unitSteps` from live data (may have been reduced from</span>
        <span class="c1"># length 3 to length 2 or 1 based on mixing the step-based definition and the bounds-based definition</span>
        <span class="c1"># described in Design Considerations above.)</span>
        <span class="c1"># We don&#39;t just save the original tuple passed in because that may miss transformations that</span>
        <span class="c1"># occur between instantiation and reduction.</span>
        <span class="n">unitSteps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">compressedSteps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">[:])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="c1"># Recall _stepDims are stored as a single-value tuple (for numpy indexing)</span>
            <span class="c1"># So this just is grabbing the actual data.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">unitSteps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compressedSteps</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Add dummy value which will never get used (it gets reduced away)</span>
                <span class="n">unitSteps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">unitSteps</span> <span class="o">=</span> <span class="n">_tuplify</span><span class="p">(</span><span class="n">unitSteps</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">GridParameters</span><span class="p">(</span>
            <span class="n">unitSteps</span><span class="p">,</span>
            <span class="n">bounds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unitStepLimits</span><span class="p">,</span>
            <span class="n">offset</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_geomType</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_symmetry</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Offset in cm for each axis.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>

    <span class="nd">@offset</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">offset</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2"> -- </span><span class="si">{}</span><span class="se">\n</span><span class="s2">Bounds:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))]</span>
            <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;  </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">]</span>
            <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;Steps:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">]</span>
            <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;  </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">]</span>
            <span class="o">+</span> <span class="p">[</span>
                <span class="s2">&quot;Anchor: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">armiObject</span><span class="p">),</span>
                <span class="s2">&quot;Offset: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">),</span>
                <span class="s2">&quot;Num Locations: </span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ijk</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">IJKType</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">IJKType</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">LocationBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a location by (i, j, k) indices. If it does not exist, create a new one and return it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ijk : tuple of indices or list of the same</span>
<span class="sd">            If provided a tuple, an IndexLocation will be created (if necessary) and</span>
<span class="sd">            returned. If provided a list, each element will create a new IndexLocation</span>
<span class="sd">            (if necessary), and a MultiIndexLocation containing all of the passed</span>
<span class="sd">            indices will be returned.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The method is defaultdict-like, in that it will create a new location on the fly. However,</span>
<span class="sd">        the class itself is not really a dictionary, it is just index-able. For example, there is no</span>
<span class="sd">        desire to have a ``__setitem__`` method, because the only way to create a location is by</span>
<span class="sd">        retrieving it or through ``buildLocations``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ijk</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">ijk</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">IndexLocation</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ijk</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">MultiIndexLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">locators</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ijk</span><span class="p">]</span>
            <span class="n">val</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">locators</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Unsupported index type `</span><span class="si">{}</span><span class="s2">` for `</span><span class="si">{}</span><span class="s2">`&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ijk</span><span class="p">),</span> <span class="n">ijk</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>

<div class="viewcode-block" id="StructuredGrid.items"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">IJKType</span><span class="p">,</span> <span class="n">IndexLocation</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="o">.</span><span class="n">items</span><span class="p">()</span></div>

<div class="viewcode-block" id="StructuredGrid.backUp"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.backUp">[docs]</a>    <span class="k">def</span> <span class="nf">backUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gather internal info that should be restored within a retainState.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span></div>

<div class="viewcode-block" id="StructuredGrid.restoreBackup"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.restoreBackup">[docs]</a>    <span class="k">def</span> <span class="nf">restoreBackup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backup</span></div>

<div class="viewcode-block" id="StructuredGrid.getCoordinates"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.getCoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">getCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">nativeCoords</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the coordinates of the center of the mesh cell at the given indices</span>
<span class="sd">        in cm.</span>

<span class="sd">        .. impl:: Get the coordinates from a location in a grid.</span>
<span class="sd">            :id: I_ARMI_GRID_GLOBAL_POS</span>
<span class="sd">            :implements: R_ARMI_GRID_GLOBAL_POS</span>

<span class="sd">            Probably the most common request of a structure grid will be to give the</span>
<span class="sd">            grid indices and return the physical coordinates of the center of the mesh</span>
<span class="sd">            cell. This is super handy in any situation where the coordinates have</span>
<span class="sd">            physical meaning.</span>

<span class="sd">            The math for finding the centroid turns out to be very easy, as the mesh is</span>
<span class="sd">            defined on the coordinates. So finding the mid-point along one axis is just</span>
<span class="sd">            taking the upper and lower bounds and dividing by two. And this is done for</span>
<span class="sd">            all axes. There are no more complicated situations where we need to find</span>
<span class="sd">            the centroid of a octagon on a rectangular mesh, or the like.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluateMesh</span><span class="p">(</span>
            <span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroidBySteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroidByBounds</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="StructuredGrid.getCellBase"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.getCellBase">[docs]</a>    <span class="k">def</span> <span class="nf">getCellBase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the mesh base (lower left) of this mesh cell in cm.&quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluateMesh</span><span class="p">(</span>
            <span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshBaseBySteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshBaseByBounds</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="StructuredGrid.getCellTop"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.getCellTop">[docs]</a>    <span class="k">def</span> <span class="nf">getCellTop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the mesh top (upper right) of this mesh cell in cm.&quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluateMesh</span><span class="p">(</span>
            <span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshBaseBySteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshBaseByBounds</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_evaluateMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">stepOperator</span><span class="p">,</span> <span class="n">boundsOperator</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate some function of indices on this grid.</span>

<span class="sd">        Recall from above that steps are mesh-centered and bounds are mesh-edged.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method may be simplifiable. Complications arose from mixtures of bounds-</span>
<span class="sd">        based and step-based meshing. These were separate subclasses, but in practice</span>
<span class="sd">        many cases have some mix of step-based (hexagons, squares), and bounds based</span>
<span class="sd">        (radial, zeta).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boundCoords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">boundCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">boundsOperator</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">bounds</span><span class="p">))</span>

        <span class="c1"># limit step operator to the step dimensions</span>
        <span class="n">stepCoords</span> <span class="o">=</span> <span class="n">stepOperator</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span><span class="p">])</span>

        <span class="c1"># now mix/match bounds coords with step coords appropriately.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span><span class="p">]</span> <span class="o">=</span> <span class="n">stepCoords</span>
        <span class="n">result</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundDims</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundCoords</span>

        <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>

    <span class="k">def</span> <span class="nf">_centroidBySteps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_meshBaseBySteps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_centroidBySteps</span><span class="p">(</span><span class="n">indices</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroidBySteps</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_centroidByBounds</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># avoid wrap-around</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Bounds-defined indices may not be negative.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bounds</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_meshBaseByBounds</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Bounds-defined indices may not be negative.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bounds</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

<div class="viewcode-block" id="StructuredGrid.getNeighboringCellIndices"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.getNeighboringCellIndices">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getNeighboringCellIndices</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the indices of the immediate neighbors of a mesh point in the plane.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span></div>

<div class="viewcode-block" id="StructuredGrid.getAboveAndBelowCellIndices"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.getAboveAndBelowCellIndices">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getAboveAndBelowCellIndices</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="StructuredGrid.getIndexBounds"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.getIndexBounds">[docs]</a>    <span class="k">def</span> <span class="nf">getIndexBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get min index and number of indices in this grid.</span>

<span class="sd">        Step-defined grids would be infinite but for the step limits defined in the constructor.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This produces output that is intended to be passed to a ``range`` statement.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexBounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">minMax</span><span class="p">,</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitStepLimits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indexBounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minMax</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexBounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indexBounds</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructuredGrid.getBounds"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.getBounds">[docs]</a>    <span class="k">def</span> <span class="nf">getBounds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
        <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the grid bounds for each dimension, if present.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span></div>

<div class="viewcode-block" id="StructuredGrid.getLocatorFromRingAndPos"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.getLocatorFromRingAndPos">[docs]</a>    <span class="k">def</span> <span class="nf">getLocatorFromRingAndPos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the location based on ring and position.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ring : int</span>
<span class="sd">            Ring number (1-based indexing)</span>
<span class="sd">        pos : int</span>
<span class="sd">            Position number (1-based indexing)</span>
<span class="sd">        k : int, optional</span>
<span class="sd">            Axial index (0-based indexing)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getIndicesFromRingAndPos</span>
<span class="sd">            This implements the transform into i, j indices based on ring and position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getIndicesFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span></div>

<div class="viewcode-block" id="StructuredGrid.getIndicesFromRingAndPos"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.getIndicesFromRingAndPos">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">getIndicesFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return i, j indices given ring and position.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This should be implemented as a staticmethod, since no Grids currently in</span>
<span class="sd">        exsistence actually need any instance data to perform this task, and</span>
<span class="sd">        staticmethods provide the convenience of calling the method without an instance</span>
<span class="sd">        of the class in the first place.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="StructuredGrid.getMinimumRings"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.getMinimumRings">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">getMinimumRings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum number of rings needed to fit ``n`` objects.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        While this is useful and safe for answering the question of &quot;how many rings do I</span>
<span class="sd">        need to hold N things?&quot;, is generally not safe to use it to answer &quot;I have N</span>
<span class="sd">        things; within how many rings are they distributed?&quot;. This function provides a</span>
<span class="sd">        lower bound, assuming that objects are densely-packed. If they are not actually</span>
<span class="sd">        densely packed, this may be unphysical.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="StructuredGrid.getPositionsInRing"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.getPositionsInRing">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">getPositionsInRing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of positions within a ring.&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="StructuredGrid.getRingPos"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.getRingPos">[docs]</a>    <span class="k">def</span> <span class="nf">getRingPos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get ring and position number in this grid.</span>

<span class="sd">        For non-hex grids this is just i and j.</span>

<span class="sd">        A tuple is returned so that it is easy to compare pairs of indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Regular grids don&#39;t know about ring and position. Check the parent.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">armiObject</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">armiObject</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">armiObject</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">armiObject</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No ring position found, because no spatial grid was found.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructuredGrid.getAllIndices"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.grids.structuredGrid.html#armi.reactor.grids.structuredGrid.StructuredGrid.getAllIndices">[docs]</a>    <span class="k">def</span> <span class="nf">getAllIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all possible indices in this grid.&quot;&quot;&quot;</span>
        <span class="n">iBounds</span><span class="p">,</span> <span class="n">jBounds</span><span class="p">,</span> <span class="n">kBounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getIndexBounds</span><span class="p">()</span>
        <span class="n">allIndices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">iBounds</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">jBounds</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">kBounds</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">allIndices</span></div>

    <span class="k">def</span> <span class="nf">_buildLocations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Populate all grid cells with a characteristic SpatialLocator.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAllIndices</span><span class="p">():</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">IndexLocation</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">loc</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">pitch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Grid pitch.</span>

<span class="sd">        Some implementations may rely on a single pitch, such</span>
<span class="sd">        as axial or hexagonal grids. Cartesian grids may use</span>
<span class="sd">        a single pitch between elements or separate pitches</span>
<span class="sd">        for the x and y dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or tuple of (float, float)</span>
<span class="sd">            Grid spacing in cm</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<span class="k">def</span> <span class="nf">_tuplify</span><span class="p">(</span><span class="n">maybeArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maybeArray</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">maybeArray</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="k">else</span> <span class="n">row</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">maybeArray</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">maybeArray</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2009-2024, TerraPower, LLC.
      <span class="lastupdated">Last updated on 2024-10-29.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>armi.reactor.converters.geometryConverters &mdash; ARMI 0.4.0 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme_fixes.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-rendered-html.css" type="text/css" />
    <link rel="shortcut icon" href="../../../../_static/armiicon_16x16.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            ARMI
              <img src="../../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.4.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../.apidocs/modules.html">API Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #233C5B" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ARMI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../../armi.html">armi</a></li>
          <li class="breadcrumb-item"><a href="../../reactor.html">armi.reactor</a></li>
      <li class="breadcrumb-item active">armi.reactor.converters.geometryConverters</li>
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for armi.reactor.converters.geometryConverters</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Change a reactor from one geometry to another.</span>

<span class="sd">Examples may include going from Hex to R-Z or from Third-core to full core.  This module contains</span>
<span class="sd">**converters** (which create new reactor objects with different geometry), and **changers** (which</span>
<span class="sd">modify a given reactor in place) in this module.</span>

<span class="sd">Generally, mass is conserved in geometry conversions.</span>

<span class="sd">Warning</span>
<span class="sd">-------</span>
<span class="sd">These are mostly designed for hex geometry.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">materials</span>
<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">runLog</span>
<span class="kn">from</span> <span class="nn">armi.physics.neutronics.fissionProductModel</span> <span class="kn">import</span> <span class="n">lumpedFissionProduct</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">assemblies</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">blocks</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">components</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">geometry</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">grids</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">parameters</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">reactors</span>
<span class="kn">from</span> <span class="nn">armi.reactor.converters</span> <span class="kn">import</span> <span class="n">blockConverters</span>
<span class="kn">from</span> <span class="nn">armi.reactor.converters</span> <span class="kn">import</span> <span class="n">meshConverters</span>
<span class="kn">from</span> <span class="nn">armi.reactor.flags</span> <span class="kn">import</span> <span class="n">Flags</span>
<span class="kn">from</span> <span class="nn">armi.reactor.parameters</span> <span class="kn">import</span> <span class="n">Category</span>
<span class="kn">from</span> <span class="nn">armi.reactor.parameters</span> <span class="kn">import</span> <span class="n">NEVER</span>
<span class="kn">from</span> <span class="nn">armi.reactor.parameters</span> <span class="kn">import</span> <span class="n">ParamLocation</span>
<span class="kn">from</span> <span class="nn">armi.reactor.parameters</span> <span class="kn">import</span> <span class="n">SINCE_LAST_GEOMETRY_TRANSFORMATION</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">hexagon</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">plotting</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">units</span>

<span class="n">BLOCK_AXIAL_MESH_SPACING</span> <span class="o">=</span> <span class="p">(</span>
    <span class="mi">20</span>  <span class="c1"># Block axial mesh spacing set for nodal diffusion calculation (cm)</span>
<span class="p">)</span>
<span class="n">STR_SPACE</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>


<div class="viewcode-block" id="GeometryChanger"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.GeometryChanger">[docs]</a><span class="k">class</span> <span class="nc">GeometryChanger</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Geometry changer class that updates the geometry (number of assems or blocks per assem) of a given reactor.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_newAssembliesAdded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cs</span> <span class="o">=</span> <span class="n">cs</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="GeometryChanger.convert"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.GeometryChanger.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the conversion.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        r : Reactor object</span>
<span class="sd">            The reactor to convert.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="GeometryChanger.reset"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.GeometryChanger.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When called, the reactor core model is reset to it&#39;s original configuration, or</span>
<span class="sd">        parameter data from the converted reactor core model is transformed back to the origin</span>
<span class="sd">        reactor state, thus cleaning up the converted reactor core model.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This should be implemented on each of the geometry converters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Resetting the state of the converted reactor core model in </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_newAssembliesAdded</span> <span class="o">=</span> <span class="p">[]</span></div></div>


<div class="viewcode-block" id="GeometryConverter"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.GeometryConverter">[docs]</a><span class="k">class</span> <span class="nc">GeometryConverter</span><span class="p">(</span><span class="n">GeometryChanger</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for GeometryConverter which makes a new converted reactor.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    To convert a hex case to a R-Z case, do this:</span>

<span class="sd">    &gt;&gt;&gt; from armi.reactorConverters import HexToRZConverter</span>
<span class="sd">    &gt;&gt;&gt; HexToRZConverter(useMostCommonXsId=False, expandReactor=False)</span>
<span class="sd">    &gt;&gt;&gt; geomConv.convert(r)</span>
<span class="sd">    &gt;&gt;&gt; newR = geomConv.convReactor</span>
<span class="sd">    &gt;&gt;&gt; dif3d = dif3dInterface.Dif3dInterface(&#39;dif3dRZ&#39;, newR)</span>
<span class="sd">    &gt;&gt;&gt; dif3d.o = self.o</span>
<span class="sd">    &gt;&gt;&gt; dif3d.writeInput(&#39;rzGeom_actual.inp&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">GeometryChanger</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="n">cs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="FuelAssemNumModifier"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.FuelAssemNumModifier">[docs]</a><span class="k">class</span> <span class="nc">FuelAssemNumModifier</span><span class="p">(</span><span class="n">GeometryChanger</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modify the number of fuel assemblies in the reactor.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The number of fuel assemblies should ALWAYS be set for the third-core regardless of the</span>
<span class="sd">      reactor geometry model.</span>
<span class="sd">    - The modification is only valid for third-core and full-core geometry models.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
        <span class="n">GeometryChanger</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numFuelAssems</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># in full core.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fuelType</span> <span class="o">=</span> <span class="s2">&quot;feed fuel&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overwriteList</span> <span class="o">=</span> <span class="p">[</span><span class="n">Flags</span><span class="o">.</span><span class="n">REFLECTOR</span><span class="p">,</span> <span class="n">Flags</span><span class="o">.</span><span class="n">SHIELD</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ringsToAdd</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modifyReactorPower</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="FuelAssemNumModifier.convert"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.FuelAssemNumModifier.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the number of fuel assemblies in the reactor.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - While adding fuel, does not modify existing fuel/control positions, but does overwrite</span>
<span class="sd">          assemblies in the overwriteList (e.g. reflectors, shields)</span>
<span class="sd">        - Once specified amount of fuel is in place, removes all assemblies past the outer fuel boundary</span>
<span class="sd">        - To re-add reflector/shield assemblies around the new core, use the ringsToAdd attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span> <span class="o">=</span> <span class="n">r</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">!=</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">!=</span> <span class="mi">3</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid reactor geometry </span><span class="si">{}</span><span class="s2"> in </span><span class="si">{}</span><span class="s2">. Reactor must be full or third core to modify the &quot;</span>
                <span class="s2">&quot;number of assemblies.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Set the number of fueled and non-fueled positions within the core (Full core or third-core)</span>
        <span class="n">coreGeom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;full-core&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">else</span> <span class="s2">&quot;third-core&quot;</span>
        <span class="p">)</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Modifying </span><span class="si">{}</span><span class="s2"> geometry to have </span><span class="si">{}</span><span class="s2"> fuel assemblies.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">coreGeom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numFuelAssems</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">nonFuelAssems</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">sum</span><span class="p">(</span><span class="ow">not</span> <span class="n">assem</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span> <span class="k">for</span> <span class="n">assem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="p">)</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numFuelAssems</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span>
        <span class="n">totalCoreAssems</span> <span class="o">=</span> <span class="n">nonFuelAssems</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numFuelAssems</span>

        <span class="c1"># Adjust the total power of the reactor by keeping power per assembly constant</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">modifyReactorPower</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span> <span class="o">*=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numFuelAssems</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">))</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span>
            <span class="p">)</span>

        <span class="c1"># Get the sorted assembly locations in the core (Full core or third core)</span>
        <span class="n">assemOrderList</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">generateSortedHexLocationList</span><span class="p">(</span>
            <span class="n">totalCoreAssems</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">assemOrderList</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">loc</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">assemOrderList</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">isInFirstThird</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="c1"># Add fuel assemblies to the core</span>
        <span class="n">addingFuelIsComplete</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">numFuelAssemsAdded</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">assemOrderList</span><span class="p">:</span>
            <span class="n">assem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">numFuelAssemsAdded</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">numFuelAssems</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">assem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Cannot find expected fuel assem in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">loc</span><span class="p">))</span>
                <span class="c1"># Add new fuel assembly to the core</span>
                <span class="k">if</span> <span class="n">assem</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overwriteList</span><span class="p">):</span>
                    <span class="n">fuelAssem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">createAssemblyOfType</span><span class="p">(</span>
                        <span class="n">assemType</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fuelType</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cs</span>
                    <span class="p">)</span>
                    <span class="c1"># Remove existing assembly in the core location before adding new assembly</span>
                    <span class="k">if</span> <span class="n">assem</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overwriteList</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">removeAssembly</span><span class="p">(</span><span class="n">assem</span><span class="p">,</span> <span class="n">discharge</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fuelAssem</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                    <span class="n">numFuelAssemsAdded</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Keep the existing assembly in the core</span>
                    <span class="k">if</span> <span class="n">assem</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">):</span>
                        <span class="c1"># Count the assembly in the location if it is fuel</span>
                        <span class="n">numFuelAssemsAdded</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>
            <span class="c1"># Flag the completion of adding fuel assemblies (see note 1)</span>
            <span class="k">elif</span> <span class="n">numFuelAssemsAdded</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">numFuelAssems</span><span class="p">:</span>
                <span class="n">addingFuelIsComplete</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Remove the remaining assemblies in the the assembly list once all the fuel has been added</span>
            <span class="k">if</span> <span class="n">addingFuelIsComplete</span> <span class="ow">and</span> <span class="n">assem</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">removeAssembly</span><span class="p">(</span><span class="n">assem</span><span class="p">,</span> <span class="n">discharge</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Remove all other assemblies from the core</span>
        <span class="k">for</span> <span class="n">assem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">assem</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">assemOrderList</span>
            <span class="p">):</span>  <span class="c1"># check if assembly is on the list</span>
                <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">removeAssembly</span><span class="p">(</span>
                    <span class="n">assem</span><span class="p">,</span> <span class="n">discharge</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>  <span class="c1"># get rid of the old assembly</span>

        <span class="c1"># Add the remaining rings of assemblies to the core</span>
        <span class="k">for</span> <span class="n">assemType</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ringsToAdd</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addRing</span><span class="p">(</span><span class="n">assemType</span><span class="o">=</span><span class="n">assemType</span><span class="p">)</span>

        <span class="c1"># Complete the reactor loading</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">processLoading</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">numRings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getNumRings</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">regenAssemblyLists</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">circularRingList</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">None</span>  <span class="c1"># need to reset this (possibly other stuff too)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="FuelAssemNumModifier.addRing"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.FuelAssemNumModifier.addRing">[docs]</a>    <span class="k">def</span> <span class="nf">addRing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemType</span><span class="o">=</span><span class="s2">&quot;big shield&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a ring of fuel assemblies around the outside of an existing core.</span>

<span class="sd">        Works by first finding the assembly furthest from the center, then filling in</span>
<span class="sd">        all assemblies that are within one pitch further with the specified assembly type</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        assemType : str</span>
<span class="sd">            Assembly type that will be added to the outside of the core</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span>
        <span class="c1"># first look through the core and finds the one farthest from the center</span>
        <span class="n">maxDist</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">assem</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">():</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">assem</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span>
            <span class="p">)</span>  <span class="c1"># get distance from origin</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span>
                <span class="n">dist</span><span class="p">,</span> <span class="mi">6</span>
            <span class="p">)</span>  <span class="c1"># round dist to 6 places to avoid differences due to floating point math</span>
            <span class="n">maxDist</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxDist</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>

        <span class="c1"># add one hex pitch to the maximum distance to get the bounding distance for the new ring</span>
        <span class="n">hexPitch</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">pitch</span>
        <span class="n">newRingDist</span> <span class="o">=</span> <span class="n">maxDist</span> <span class="o">+</span> <span class="n">hexPitch</span>

        <span class="n">maxArea</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">newRingDist</span> <span class="o">+</span> <span class="n">hexPitch</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span>
        <span class="p">)</span>  <span class="c1"># area that is guaranteed to bound the new core</span>
        <span class="n">maxAssemsFull</span> <span class="o">=</span> <span class="n">maxArea</span> <span class="o">/</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">area</span><span class="p">(</span>
            <span class="n">hexPitch</span>
        <span class="p">)</span>  <span class="c1"># divide by hex area to get number of hexes in a full core</span>

        <span class="c1"># generate ordered list of assembly locations</span>
        <span class="n">assemOrderList</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">generateSortedHexLocationList</span><span class="p">(</span><span class="n">maxAssemsFull</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">assemOrderList</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">loc</span>
                <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">assemOrderList</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">isInFirstThird</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> only works on full or 1/3 symmetry.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="c1"># add new assemblies to core within one ring</span>
        <span class="k">for</span> <span class="n">locator</span> <span class="ow">in</span> <span class="n">assemOrderList</span><span class="p">:</span>
            <span class="n">assem</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">locator</span>
            <span class="p">)</span>  <span class="c1"># check on assemblies, moving radially outward</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">locator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">())</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">newRingDist</span><span class="p">:</span>  <span class="c1"># check distance</span>
                <span class="k">if</span> <span class="n">assem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># no assembly in that position, add assembly</span>
                    <span class="n">newAssem</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">createAssemblyOfType</span><span class="p">(</span>
                        <span class="n">assemType</span><span class="o">=</span><span class="n">assemType</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cs</span>
                    <span class="p">)</span>
                    <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newAssem</span><span class="p">,</span> <span class="n">locator</span><span class="p">)</span>  <span class="c1"># put new assembly in reactor!</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># all other types of assemblies (fuel, control, etc) leave as is</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span></div>

<div class="viewcode-block" id="FuelAssemNumModifier.reset"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.FuelAssemNumModifier.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resetting the reactor core model state after adding fuel assemblies is not currently supported.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div></div>


<div class="viewcode-block" id="HexToRZThetaConverter"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.HexToRZThetaConverter">[docs]</a><span class="k">class</span> <span class="nc">HexToRZThetaConverter</span><span class="p">(</span><span class="n">GeometryConverter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert hex-based cases to an equivalent R-Z-Theta full core geometry.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    converterSettings: dict</span>
<span class="sd">        Settings that specify how the mesh of the RZTheta reactor should be generated. Controls the</span>
<span class="sd">        number of theta regions, how to group regions, etc.</span>

<span class="sd">        uniformThetaMesh</span>
<span class="sd">            bool flag that determines if the theta mesh should be uniform or not</span>

<span class="sd">        thetaBins</span>
<span class="sd">            Number of theta bins to create</span>

<span class="sd">        radialConversionType</span>
<span class="sd">           * ``Ring Compositions`` -- to convert by composition</span>

<span class="sd">        axialConversionType</span>
<span class="sd">            * ``Axial Coordinates`` --  use</span>
<span class="sd">              :py:class:`armi.reactor.converters.meshConverters._RZThetaReactorMeshConverterByAxialCoordinates`</span>
<span class="sd">            * ``Axial Bins`` -- use</span>
<span class="sd">              :py:class:`armi.reactor.converters.meshConverters._RZThetaReactorMeshConverterByAxialBins`</span>

<span class="sd">        homogenizeAxiallyByFlags</span>
<span class="sd">            Boolean that if set to True will ignore the `axialConversionType` input and determine a</span>
<span class="sd">            mesh based on the material boundaries for each RZ region axially.</span>

<span class="sd">    expandReactor : bool</span>
<span class="sd">        If True, the HEX-Z reactor will be expanded to full core geometry prior to converting to the</span>
<span class="sd">        RZT reactor. Either way the converted RZTheta core will be full core.</span>
<span class="sd">    strictHomogenization : bool</span>
<span class="sd">        If True, the converter will restrict HEX-Z blocks with dissimilar XS types from being</span>
<span class="sd">        homogenized into an RZT block.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_GEOMETRY_TYPE</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="o">.</span><span class="n">RZT</span>
    <span class="n">_SYMMETRY_TYPE</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">SymmetryType</span><span class="p">(</span>
        <span class="n">domainType</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">FULL_CORE</span><span class="p">,</span>
        <span class="n">boundaryType</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">NO_SYMMETRY</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">_BLOCK_MIXTURE_TYPE_MAP</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;mixture control&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;control&quot;</span><span class="p">],</span>
        <span class="s2">&quot;mixture fuel&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fuel&quot;</span><span class="p">],</span>
        <span class="s2">&quot;mixture radial shield&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;radial shield&quot;</span><span class="p">],</span>
        <span class="s2">&quot;mixture axial shield&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;shield&quot;</span><span class="p">],</span>
        <span class="s2">&quot;mixture structure&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="s2">&quot;grid plate&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reflector&quot;</span><span class="p">,</span>
            <span class="s2">&quot;inlet nozzle&quot;</span><span class="p">,</span>
            <span class="s2">&quot;handling socket&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;mixture duct&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;duct&quot;</span><span class="p">],</span>
        <span class="s2">&quot;mixture plenum&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;plenum&quot;</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="n">_BLOCK_MIXTURE_TYPE_EXCLUSIONS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;control&quot;</span><span class="p">,</span> <span class="s2">&quot;fuel&quot;</span><span class="p">,</span> <span class="s2">&quot;radial shield&quot;</span><span class="p">]</span>
    <span class="n">_MESH_BY_RING_COMP</span> <span class="o">=</span> <span class="s2">&quot;Ring Compositions&quot;</span>
    <span class="n">_MESH_BY_AXIAL_COORDS</span> <span class="o">=</span> <span class="s2">&quot;Axial Coordinates&quot;</span>
    <span class="n">_MESH_BY_AXIAL_BINS</span> <span class="o">=</span> <span class="s2">&quot;Axial Bins&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">converterSettings</span><span class="p">,</span> <span class="n">expandReactor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strictHomogenization</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="n">GeometryConverter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converterSettings</span> <span class="o">=</span> <span class="n">converterSettings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshConverter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expandSourceReactor</span> <span class="o">=</span> <span class="n">expandReactor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strictHomogenization</span> <span class="o">=</span> <span class="n">strictHomogenization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radialMeshConversionType</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axialMeshConversionType</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_previousRadialZoneAssemTypes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_currentRadialZoneType</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assemsInRadialZone</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_newBlockNum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blockMap</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blockVolFracs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_homogenizeAxiallyByFlags</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_generateConvertedReactorMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the source reactor using the converterSettings.&quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Generating mesh coordinates for the reactor conversion&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radialMeshConversionType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">converterSettings</span><span class="p">[</span><span class="s2">&quot;radialConversionType&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axialMeshConversionType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">converterSettings</span><span class="p">[</span><span class="s2">&quot;axialConversionType&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_homogenizeAxiallyByFlags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">converterSettings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;homogenizeAxiallyByFlags&quot;</span><span class="p">,</span> <span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">converter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radialMeshConversionType</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MESH_BY_RING_COMP</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_homogenizeAxiallyByFlags</span><span class="p">:</span>
                <span class="n">converter</span> <span class="o">=</span> <span class="n">meshConverters</span><span class="o">.</span><span class="n">RZThetaReactorMeshConverterByRingCompositionAxialFlags</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">converterSettings</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axialMeshConversionType</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MESH_BY_AXIAL_COORDS</span><span class="p">:</span>
                <span class="n">converter</span> <span class="o">=</span> <span class="n">meshConverters</span><span class="o">.</span><span class="n">RZThetaReactorMeshConverterByRingCompositionAxialCoordinates</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">converterSettings</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axialMeshConversionType</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MESH_BY_AXIAL_BINS</span><span class="p">:</span>
                <span class="n">converter</span> <span class="o">=</span> <span class="n">meshConverters</span><span class="o">.</span><span class="n">RZThetaReactorMeshConverterByRingCompositionAxialBins</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">converterSettings</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">converter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No mesh converter exists for `radialConversionType` and `axialConversionType` settings &quot;</span>
                <span class="s2">&quot;of </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_radialMeshConversionType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axialMeshConversionType</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshConverter</span> <span class="o">=</span> <span class="n">converter</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshConverter</span><span class="o">.</span><span class="n">generateMesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="p">)</span>

<div class="viewcode-block" id="HexToRZThetaConverter.convert"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.HexToRZThetaConverter.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the conversion to 3 dimensional R-Z-Theta.</span>

<span class="sd">        .. impl:: Tool to convert a hex core to an RZTheta core.</span>
<span class="sd">            :id: I_ARMI_CONV_3DHEX_TO_2DRZ</span>
<span class="sd">            :implements: R_ARMI_CONV_3DHEX_TO_2DRZ</span>

<span class="sd">            This method converts the hex-z mesh to r-theta-z mesh.</span>
<span class="sd">            It first verifies that the geometry type of the input reactor ``r``</span>
<span class="sd">            has the expected HEX geometry. Upon conversion, it determines the inner</span>
<span class="sd">            and outer diameters of each ring in the r-theta-z mesh and calls</span>
<span class="sd">            ``_createRadialThetaZone`` to create a radial theta zone with a homogenized mixture.</span>
<span class="sd">            The axial dimension of the r-theta-z mesh is then updated by ``updateAxialMesh``.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        r : Reactor object</span>
<span class="sd">            The reactor to convert.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The linked requirement technically points to a child class of this class, HexToRZConverter.</span>
<span class="sd">        However, this is the method where the conversion actually happens and thus the</span>
<span class="sd">        implementation tag is noted here.</span>

<span class="sd">        As a part of the RZT mesh converters it is possible to obtain a radial mesh that has</span>
<span class="sd">        repeated ring numbers.  For instance, if there are fuel assemblies and control assemblies</span>
<span class="sd">        within the same radial hex ring then it&#39;s possible that a radial mesh output from the</span>
<span class="sd">        byRingComposition mesh converter method will look something like:</span>

<span class="sd">        self.meshConverter.radialMesh = [2, 3, 4, 4, 5, 5, 6, 6, 6, 7, 8, 8, 9, 10]</span>

<span class="sd">        In this instance the hex ring will remain the same for multiple iterations over radial</span>
<span class="sd">        direction when homogenizing the hex core into the RZT geometry. In this case, the converter</span>
<span class="sd">        needs to keep track of the compositions within this ring so that it can separate this</span>
<span class="sd">        repeated ring into multiple RZT rings. Each of the RZT rings should have a single</span>
<span class="sd">        composition (fuel1, fuel2, control, etc.)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.converters.meshConverters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converting </span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="si">}</span><span class="s2"> using </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">geomType</span> <span class="o">!=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="o">.</span><span class="n">HEX</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot use </span><span class="si">{}</span><span class="s2"> to convert </span><span class="si">{}</span><span class="s2"> reactor&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">geomType</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span> <span class="o">=</span> <span class="n">r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setupSourceReactorForConversion</span><span class="p">()</span>
        <span class="n">rztSpatialGrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generateConvertedReactorMesh</span><span class="p">()</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">rztSpatialGrid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setupConvertedReactor</span><span class="p">(</span><span class="n">rztSpatialGrid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span>

        <span class="n">innerDiameter</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">lowerRing</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">radialMeshCm</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">radialIndex</span><span class="p">,</span> <span class="n">upperRing</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshConverter</span><span class="o">.</span><span class="n">radialMesh</span><span class="p">):</span>
            <span class="n">lowerTheta</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1"># see notes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_previousRadialZoneAssemTypes</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_previousRadialZoneAssemTypes</span> <span class="k">if</span> <span class="n">lowerRing</span> <span class="o">==</span> <span class="n">upperRing</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">lowerRing</span> <span class="o">==</span> <span class="n">upperRing</span><span class="p">:</span>
                <span class="n">lowerRing</span> <span class="o">=</span> <span class="n">upperRing</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_setNextAssemblyTypeInRadialZone</span><span class="p">(</span><span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setAssemsInRadialZone</span><span class="p">(</span><span class="n">radialIndex</span><span class="p">,</span> <span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">thetaIndex</span><span class="p">,</span> <span class="n">upperTheta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshConverter</span><span class="o">.</span><span class="n">thetaMesh</span><span class="p">):</span>
                <span class="n">zoneAssems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getAssemsInRadialThetaZone</span><span class="p">(</span>
                    <span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">,</span> <span class="n">lowerTheta</span><span class="p">,</span> <span class="n">upperTheta</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_writeRadialThetaZoneHeader</span><span class="p">(</span>
                    <span class="n">radialIndex</span><span class="p">,</span>
                    <span class="n">lowerRing</span><span class="p">,</span>
                    <span class="n">upperRing</span><span class="p">,</span>
                    <span class="n">thetaIndex</span><span class="p">,</span>
                    <span class="n">lowerTheta</span><span class="p">,</span>
                    <span class="n">upperTheta</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">outerDiameter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_createRadialThetaZone</span><span class="p">(</span>
                    <span class="n">innerDiameter</span><span class="p">,</span>
                    <span class="n">thetaIndex</span><span class="p">,</span>
                    <span class="n">radialIndex</span><span class="p">,</span>
                    <span class="n">lowerTheta</span><span class="p">,</span>
                    <span class="n">upperTheta</span><span class="p">,</span>
                    <span class="n">zoneAssems</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">lowerTheta</span> <span class="o">=</span> <span class="n">upperTheta</span>
            <span class="n">innerDiameter</span> <span class="o">=</span> <span class="n">outerDiameter</span>
            <span class="n">lowerRing</span> <span class="o">=</span> <span class="n">upperRing</span>
            <span class="n">radialMeshCm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outerDiameter</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>

        <span class="c1"># replace temporary index-based ring indices with actual radial distances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">radialMeshCm</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">updateAxialMesh</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">summarizeReactorStats</span><span class="p">()</span>

        <span class="c1"># Track the new assemblies that were created when the converted reactor was</span>
        <span class="c1"># initialized so that the global assembly counter can be reset later.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_newAssembliesAdded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_setNextAssemblyTypeInRadialZone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the currently-active assembly type to the next active one based on a specific order.</span>

<span class="sd">        If this is called with the same (lowerRing, upperRing) twice, the next assembly type</span>
<span class="sd">        will be applied. This is useful, for instance, in putting control zones amidst fuel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sortedAssemTypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getSortedAssemblyTypesInRadialZone</span><span class="p">(</span>
            <span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">aType</span> <span class="ow">in</span> <span class="n">sortedAssemTypes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">aType</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_previousRadialZoneAssemTypes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_previousRadialZoneAssemTypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aType</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_currentRadialZoneType</span> <span class="o">=</span> <span class="n">aType</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_getSortedAssemblyTypesInRadialZone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve assembly types in a radial zone between (lowerRing, upperRing), sort from highest</span>
<span class="sd">        occurrence to lowest.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Assembly types are based on the assembly names and not the direct composition within each</span>
<span class="sd">          assembly. For instance, if two assemblies are named `fuel 1` and `fuel 2` but they have</span>
<span class="sd">          the same composition at some reactor state then they will still be separated as two</span>
<span class="sd">          different assembly types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aCountByTypes</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getAssembliesInCurrentRadialZone</span><span class="p">(</span><span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">):</span>
            <span class="n">aCountByTypes</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># sort on tuple (int, str) to force consistent ordering of result when counts are tied</span>
        <span class="n">sortedAssemTypes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">aCountByTypes</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">aType</span><span class="p">:</span> <span class="p">(</span><span class="n">aCountByTypes</span><span class="p">[</span><span class="n">aType</span><span class="p">],</span> <span class="n">aType</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">sortedAssemTypes</span>

    <span class="k">def</span> <span class="nf">_getAssembliesInCurrentRadialZone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">):</span>
        <span class="n">ringAssems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">):</span>
            <span class="n">ringAssems</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssembliesInSquareOrHexRing</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ringAssems</span>

    <span class="k">def</span> <span class="nf">_setupSourceReactorForConversion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">summarizeReactorStats</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expandSourceReactor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_expandSourceReactorGeometry</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_setupConvertedReactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span> <span class="o">=</span> <span class="n">reactors</span><span class="o">.</span><span class="n">Reactor</span><span class="p">(</span>
            <span class="s2">&quot;ConvertedReactor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">blueprints</span>
        <span class="p">)</span>
        <span class="n">core</span> <span class="o">=</span> <span class="n">reactors</span><span class="o">.</span><span class="n">Core</span><span class="p">(</span><span class="s2">&quot;Core&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">core</span><span class="o">.</span><span class="n">setOptionsFromCs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">core</span><span class="p">)</span>

        <span class="n">grid</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SYMMETRY_TYPE</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">geomType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GEOMETRY_TYPE</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">armiObject</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s2">&quot; - </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_GEOMETRY_TYPE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setAssemsInRadialZone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radialIndex</span><span class="p">,</span> <span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve a list of assemblies in the reactor between (lowerRing, upperRing).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        self._assemsInRadialZone keeps track of the unique assemblies that are in each radial ring.</span>
<span class="sd">        This ensures that no assemblies are duplicated when using self._getAssemsInRadialThetaZone()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lowerTheta</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">_thetaIndex</span><span class="p">,</span> <span class="n">upperTheta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshConverter</span><span class="o">.</span><span class="n">thetaMesh</span><span class="p">):</span>
            <span class="n">assemsInRadialThetaZone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getAssemsInRadialThetaZone</span><span class="p">(</span>
                <span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">,</span> <span class="n">lowerTheta</span><span class="p">,</span> <span class="n">upperTheta</span>
            <span class="p">)</span>
            <span class="n">newAssemsInRadialZone</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">assemsInRadialThetaZone</span><span class="p">)</span>
            <span class="n">oldAssemsInRadialZone</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_assemsInRadialZone</span><span class="p">[</span><span class="n">radialIndex</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assemsInRadialZone</span><span class="p">[</span><span class="n">radialIndex</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">newAssemsInRadialZone</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">oldAssemsInRadialZone</span><span class="p">)))</span>
            <span class="p">)</span>
            <span class="n">lowerTheta</span> <span class="o">=</span> <span class="n">upperTheta</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assemsInRadialZone</span><span class="p">[</span><span class="n">radialIndex</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No assemblies in radial zone </span><span class="si">{}</span><span class="s2"> between rings </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_assemsInRadialZone</span><span class="p">[</span><span class="n">radialIndex</span><span class="p">],</span> <span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_getAssembliesInSector</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Locate assemblies in an angular sector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta1, theta2 : float</span>
<span class="sd">            The angles (in degrees) in which assemblies shall be drawn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        aList : list</span>
<span class="sd">            List of assemblies in this sector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">converter</span> <span class="o">=</span> <span class="n">EdgeAssemblyChanger</span><span class="p">()</span>
        <span class="n">converter</span><span class="o">.</span><span class="n">addEdgeAssemblies</span><span class="p">(</span><span class="n">core</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">core</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">()</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">theta</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tau</span> <span class="o">+</span> <span class="n">theta</span>

            <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="n">phi</span> <span class="o">=</span> <span class="n">theta</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">theta1</span> <span class="o">&lt;=</span> <span class="n">phi</span> <span class="o">&lt;=</span> <span class="n">theta2</span>
                <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">theta1</span> <span class="o">-</span> <span class="n">phi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span>
                <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">theta2</span> <span class="o">-</span> <span class="n">phi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span>
            <span class="p">):</span>
                <span class="n">aList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">converter</span><span class="o">.</span><span class="n">removeEdgeAssemblies</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">aList</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There are no assemblies in </span><span class="si">{}</span><span class="s2"> between angles of </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">core</span><span class="p">,</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">aList</span>

    <span class="k">def</span> <span class="nf">_getAssemsInRadialThetaZone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">,</span> <span class="n">lowerTheta</span><span class="p">,</span> <span class="n">upperTheta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve list of assemblies in the reactor between (lowerRing, upperRing) and</span>
<span class="sd">        (lowerTheta, upperTheta).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">thetaAssems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getAssembliesInSector</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">lowerTheta</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">upperTheta</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">ringAssems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getAssembliesInCurrentRadialZone</span><span class="p">(</span><span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radialMeshConversionType</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MESH_BY_RING_COMP</span><span class="p">:</span>
            <span class="n">ringAssems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selectAssemsBasedOnType</span><span class="p">(</span><span class="n">ringAssems</span><span class="p">)</span>

        <span class="n">ringAssems</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ringAssems</span><span class="p">)</span>
        <span class="n">thetaAssems</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">thetaAssems</span><span class="p">)</span>
        <span class="n">assemsInRadialThetaZone</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ringAssems</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">thetaAssems</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">assemsInRadialThetaZone</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No assemblies in radial-theta zone between rings </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;and theta bounds of </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">,</span> <span class="n">lowerTheta</span><span class="p">,</span> <span class="n">upperTheta</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">assemsInRadialThetaZone</span>

    <span class="k">def</span> <span class="nf">_selectAssemsBasedOnType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assems</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve a list of assemblies of a given type within a subset of an assembly list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        assems: list</span>
<span class="sd">            Subset of assemblies in the reactor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">selectedAssems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assems</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currentRadialZoneType</span><span class="p">:</span>
                <span class="n">selectedAssems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">selectedAssems</span>

    <span class="k">def</span> <span class="nf">_createRadialThetaZone</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">innerDiameter</span><span class="p">,</span> <span class="n">thetaIndex</span><span class="p">,</span> <span class="n">radialIndex</span><span class="p">,</span> <span class="n">lowerTheta</span><span class="p">,</span> <span class="n">upperTheta</span><span class="p">,</span> <span class="n">zoneAssems</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new stack of circles to the TRZ reactor by homogenizing assems.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        innerDiameter : float</span>
<span class="sd">            The current innerDiameter of the radial-theta zone</span>

<span class="sd">        thetaIndex : float</span>
<span class="sd">            The theta index of the radial-theta zone</span>

<span class="sd">        radialIndex : float</span>
<span class="sd">            The radial index of the radial-theta zone</span>

<span class="sd">        lowerTheta : float</span>
<span class="sd">            The lower theta bound for the radial-theta zone</span>

<span class="sd">        upperTheta : float</span>
<span class="sd">            The upper theta bound for the radial-theta zone</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        outerDiameter : float</span>
<span class="sd">            The outer diameter (in cm) of the radial zone just added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newAssembly</span> <span class="o">=</span> <span class="n">assemblies</span><span class="o">.</span><span class="n">ThRZAssembly</span><span class="p">(</span><span class="s2">&quot;mixtureAssem&quot;</span><span class="p">)</span>
        <span class="n">newAssembly</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span>
            <span class="n">thetaIndex</span><span class="p">,</span> <span class="n">radialIndex</span><span class="p">,</span> <span class="mi">0</span>
        <span class="p">]</span>
        <span class="n">newAssembly</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">AziMesh</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">newAssembly</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">AxialGrid</span><span class="o">.</span><span class="n">fromNCells</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshConverter</span><span class="o">.</span><span class="n">axialMesh</span><span class="p">),</span> <span class="n">armiObject</span><span class="o">=</span><span class="n">newAssembly</span>
        <span class="p">)</span>

        <span class="n">lfp</span> <span class="o">=</span> <span class="n">lumpedFissionProduct</span><span class="o">.</span><span class="n">lumpedFissionProductFactory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cs</span><span class="p">)</span>

        <span class="n">lowerAxialZ</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">axialIndex</span><span class="p">,</span> <span class="n">upperAxialZ</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshConverter</span><span class="o">.</span><span class="n">axialMesh</span><span class="p">):</span>
            <span class="c1"># Setup the new block data</span>
            <span class="n">newBlockName</span> <span class="o">=</span> <span class="s2">&quot;B</span><span class="si">{:04d}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">newAssembly</span><span class="o">.</span><span class="n">getNum</span><span class="p">()),</span> <span class="nb">chr</span><span class="p">(</span><span class="n">axialIndex</span> <span class="o">+</span> <span class="mi">65</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">newBlock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">ThRZBlock</span><span class="p">(</span><span class="n">newBlockName</span><span class="p">)</span>

            <span class="c1"># Compute the homogenized block data</span>
            <span class="p">(</span>
                <span class="n">newBlockAtoms</span><span class="p">,</span>
                <span class="n">newBlockType</span><span class="p">,</span>
                <span class="n">newBlockTemp</span><span class="p">,</span>
                <span class="n">newBlockVol</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createHomogenizedRZTBlock</span><span class="p">(</span>
                <span class="n">newBlock</span><span class="p">,</span> <span class="n">lowerAxialZ</span><span class="p">,</span> <span class="n">upperAxialZ</span><span class="p">,</span> <span class="n">zoneAssems</span>
            <span class="p">)</span>
            <span class="c1"># Compute radial zone outer diameter</span>
            <span class="n">axialSegmentHeight</span> <span class="o">=</span> <span class="n">upperAxialZ</span> <span class="o">-</span> <span class="n">lowerAxialZ</span>
            <span class="n">radialZoneVolume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calcRadialRingVolume</span><span class="p">(</span>
                <span class="n">lowerAxialZ</span><span class="p">,</span> <span class="n">upperAxialZ</span><span class="p">,</span> <span class="n">radialIndex</span>
            <span class="p">)</span>
            <span class="n">radialRingArea</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">radialZoneVolume</span>
                <span class="o">/</span> <span class="n">axialSegmentHeight</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span>
            <span class="p">)</span>
            <span class="n">outerDiameter</span> <span class="o">=</span> <span class="n">blockConverters</span><span class="o">.</span><span class="n">getOuterDiamFromIDAndArea</span><span class="p">(</span>
                <span class="n">innerDiameter</span><span class="p">,</span> <span class="n">radialRingArea</span>
            <span class="p">)</span>

            <span class="c1"># Set new homogenized block parameters</span>
            <span class="n">material</span> <span class="o">=</span> <span class="n">materials</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">Material</span><span class="p">()</span>
            <span class="n">material</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;mixture&quot;</span>
            <span class="n">material</span><span class="o">.</span><span class="n">refDens</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># generic density. Will cancel out.</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;inner_radius&quot;</span><span class="p">:</span> <span class="n">innerDiameter</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span>
                <span class="s2">&quot;radius_differential&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">outerDiameter</span> <span class="o">-</span> <span class="n">innerDiameter</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span>
                <span class="s2">&quot;inner_axial&quot;</span><span class="p">:</span> <span class="n">lowerAxialZ</span><span class="p">,</span>
                <span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="n">axialSegmentHeight</span><span class="p">,</span>
                <span class="s2">&quot;inner_theta&quot;</span><span class="p">:</span> <span class="n">lowerTheta</span><span class="p">,</span>
                <span class="s2">&quot;azimuthal_differential&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">upperTheta</span> <span class="o">-</span> <span class="n">lowerTheta</span><span class="p">),</span>
                <span class="s2">&quot;mult&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                <span class="s2">&quot;Tinput&quot;</span><span class="p">:</span> <span class="n">newBlockTemp</span><span class="p">,</span>
                <span class="s2">&quot;Thot&quot;</span><span class="p">:</span> <span class="n">newBlockTemp</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">nuc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">blueprints</span><span class="o">.</span><span class="n">allNuclidesInProblem</span><span class="p">:</span>
                <span class="n">material</span><span class="o">.</span><span class="n">setMassFrac</span><span class="p">(</span><span class="n">nuc</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

            <span class="n">newComponent</span> <span class="o">=</span> <span class="n">components</span><span class="o">.</span><span class="n">DifferentialRadialSegment</span><span class="p">(</span>
                <span class="s2">&quot;mixture&quot;</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="o">**</span><span class="n">dims</span>
            <span class="p">)</span>
            <span class="n">newBlock</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axMesh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">axialSegmentHeight</span> <span class="o">/</span> <span class="n">BLOCK_AXIAL_MESH_SPACING</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">newBlock</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">zbottom</span> <span class="o">=</span> <span class="n">lowerAxialZ</span>
            <span class="n">newBlock</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span> <span class="o">=</span> <span class="n">upperAxialZ</span>

            <span class="n">newBlock</span><span class="o">.</span><span class="n">setLumpedFissionProducts</span><span class="p">(</span><span class="n">lfp</span><span class="p">)</span>

            <span class="c1"># Assign the new block cross section type and burn up group</span>
            <span class="n">newBlock</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="n">newBlockType</span><span class="p">)</span>
            <span class="n">newXsType</span><span class="p">,</span> <span class="n">newBuGroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_createBlendedXSID</span><span class="p">(</span><span class="n">newBlock</span><span class="p">)</span>
            <span class="n">newBlock</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">xsType</span> <span class="o">=</span> <span class="n">newXsType</span>
            <span class="n">newBlock</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buGroup</span> <span class="o">=</span> <span class="n">newBuGroup</span>

            <span class="c1"># Update the block dimensions and set the block densities</span>
            <span class="n">newComponent</span><span class="o">.</span><span class="n">updateDims</span><span class="p">()</span>  <span class="c1"># ugh.</span>
            <span class="n">newBlock</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">axialSegmentHeight</span>
            <span class="n">newBlock</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>
            <span class="n">newBlock</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newComponent</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nuc</span><span class="p">,</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">newBlockAtoms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">newBlock</span><span class="o">.</span><span class="n">setNumberDensity</span><span class="p">(</span><span class="n">nuc</span><span class="p">,</span> <span class="n">atoms</span> <span class="o">/</span> <span class="n">newBlockVol</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_writeRadialThetaZoneInfo</span><span class="p">(</span><span class="n">axialIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axialSegmentHeight</span><span class="p">,</span> <span class="n">newBlock</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_checkVolumeConservation</span><span class="p">(</span><span class="n">newBlock</span><span class="p">)</span>

            <span class="n">newAssembly</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newBlock</span><span class="p">)</span>
            <span class="n">lowerAxialZ</span> <span class="o">=</span> <span class="n">upperAxialZ</span>

        <span class="n">newAssembly</span><span class="o">.</span><span class="n">calculateZCoords</span><span class="p">()</span>  <span class="c1"># builds mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newAssembly</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">outerDiameter</span>

    <span class="k">def</span> <span class="nf">_calcRadialRingVolume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lowerZ</span><span class="p">,</span> <span class="n">upperZ</span><span class="p">,</span> <span class="n">radialIndex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the total volume of a list of assemblies within a ring between two axial heights.&quot;&quot;&quot;</span>
        <span class="n">ringVolume</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">assem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assemsInRadialZone</span><span class="p">[</span><span class="n">radialIndex</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">heightHere</span> <span class="ow">in</span> <span class="n">assem</span><span class="o">.</span><span class="n">getBlocksBetweenElevations</span><span class="p">(</span><span class="n">lowerZ</span><span class="p">,</span> <span class="n">upperZ</span><span class="p">):</span>
                <span class="n">ringVolume</span> <span class="o">+=</span> <span class="n">b</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span> <span class="o">*</span> <span class="n">heightHere</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ringVolume</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ring volume of ring </span><span class="si">{}</span><span class="s2"> is 0.0&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">radialIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ringVolume</span>

    <span class="k">def</span> <span class="nf">_checkVolumeConservation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newBlock</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the volume fractions of each hex block within the homogenized RZT block.&quot;&quot;&quot;</span>
        <span class="n">newBlockVolumeFraction</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">hexBlock</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blockMap</span><span class="p">[</span><span class="n">newBlock</span><span class="p">]:</span>
            <span class="n">newBlockVolumeFraction</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blockVolFracs</span><span class="p">[</span><span class="n">newBlock</span><span class="p">][</span><span class="n">hexBlock</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">newBlockVolumeFraction</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.00001</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The volume fraction of block </span><span class="si">{}</span><span class="s2"> is </span><span class="si">{}</span><span class="s2"> and not 1.0. An error occurred when &quot;</span>
                <span class="s2">&quot;converting the reactor geometry.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">newBlock</span><span class="p">,</span> <span class="n">newBlockVolumeFraction</span>
                <span class="p">)</span>
            <span class="p">)</span>

<div class="viewcode-block" id="HexToRZThetaConverter.createHomogenizedRZTBlock"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.HexToRZThetaConverter.createHomogenizedRZTBlock">[docs]</a>    <span class="k">def</span> <span class="nf">createHomogenizedRZTBlock</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">homBlock</span><span class="p">,</span> <span class="n">lowerAxialZ</span><span class="p">,</span> <span class="n">upperAxialZ</span><span class="p">,</span> <span class="n">radialThetaZoneAssems</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the homogenized RZT block by computing the average atoms in the zone.</span>

<span class="sd">        Additional calculations are performed to determine the homogenized block type, the block</span>
<span class="sd">        average temperature, and the volume fraction of each hex block that is in the new</span>
<span class="sd">        homogenized block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">homBlockXsTypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">numHexBlockByType</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="n">homBlockAtoms</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">homBlockVolume</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">homBlockTemperature</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">assem</span> <span class="ow">in</span> <span class="n">radialThetaZoneAssems</span><span class="p">:</span>
            <span class="n">blocksHere</span> <span class="o">=</span> <span class="n">assem</span><span class="o">.</span><span class="n">getBlocksBetweenElevations</span><span class="p">(</span><span class="n">lowerAxialZ</span><span class="p">,</span> <span class="n">upperAxialZ</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">heightHere</span> <span class="ow">in</span> <span class="n">blocksHere</span><span class="p">:</span>
                <span class="n">homBlockXsTypes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">xsType</span><span class="p">)</span>
                <span class="n">numHexBlockByType</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">blockVolumeHere</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span> <span class="o">*</span> <span class="n">heightHere</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">blockVolumeHere</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Geometry conversion failed. Block </span><span class="si">{}</span><span class="s2"> has zero volume&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">homBlockVolume</span> <span class="o">+=</span> <span class="n">blockVolumeHere</span>
                <span class="n">homBlockTemperature</span> <span class="o">+=</span> <span class="n">b</span><span class="o">.</span><span class="n">getAverageTempInC</span><span class="p">()</span> <span class="o">*</span> <span class="n">blockVolumeHere</span>

                <span class="n">numDensities</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">nucName</span><span class="p">,</span> <span class="n">nDen</span> <span class="ow">in</span> <span class="n">numDensities</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">homBlockAtoms</span><span class="p">[</span><span class="n">nucName</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nDen</span> <span class="o">*</span> <span class="n">blockVolumeHere</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">blockMap</span><span class="p">[</span><span class="n">homBlock</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">blockVolFracs</span><span class="p">[</span><span class="n">homBlock</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">blockVolumeHere</span>
        <span class="c1"># Notify if blocks with different xs types are being homogenized. May be undesired behavior.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">homBlockXsTypes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Blocks </span><span class="si">{}</span><span class="s2"> with dissimilar XS IDs are being homogenized in </span><span class="si">{}</span><span class="s2"> between axial heights&quot;</span>
                <span class="s2">&quot; </span><span class="si">{}</span><span class="s2"> cm and </span><span class="si">{}</span><span class="s2"> cm. &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">blockMap</span><span class="p">[</span><span class="n">homBlock</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="p">,</span>
                    <span class="n">lowerAxialZ</span><span class="p">,</span>
                    <span class="n">upperAxialZ</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strictHomogenization</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="n">msg</span> <span class="o">+</span> <span class="s2">&quot;Modify mesh converter settings before proceeding.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">homBlockType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getHomogenizedBlockType</span><span class="p">(</span><span class="n">numHexBlockByType</span><span class="p">)</span>
        <span class="n">homBlockTemperature</span> <span class="o">=</span> <span class="n">homBlockTemperature</span> <span class="o">/</span> <span class="n">homBlockVolume</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blockMap</span><span class="p">[</span><span class="n">homBlock</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blockVolFracs</span><span class="p">[</span><span class="n">homBlock</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">blockVolFracs</span><span class="p">[</span><span class="n">homBlock</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="n">homBlockVolume</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">homBlockAtoms</span><span class="p">,</span> <span class="n">homBlockType</span><span class="p">,</span> <span class="n">homBlockTemperature</span><span class="p">,</span> <span class="n">homBlockVolume</span></div>

    <span class="k">def</span> <span class="nf">_getHomogenizedBlockType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numHexBlockByType</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the homogenized block mixture type based on the frequency of hex block types that</span>
<span class="sd">        were merged together.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        self._BLOCK_MIXTURE_TYPE_EXCLUSIONS:</span>
<span class="sd">            The normal function of this method is to assign the mixture name based on the number of</span>
<span class="sd">            occurrences of the block type. This list stops that and assigns the mixture based on the</span>
<span class="sd">            first occurrence. (i.e. if the mixture has a set of blocks but it comes across one with</span>
<span class="sd">            the name of &#39;control&#39; the process will stop and the new mixture type will be set to</span>
<span class="sd">            &#39;mixture control&#39;.</span>

<span class="sd">        self._BLOCK_MIXTURE_TYPE_MAP:</span>
<span class="sd">            A dictionary that provides the name of blocks that are condensed together</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">assignedMixtureBlockType</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Find the most common block type out of the types in the block mixture type exclusions list</span>
        <span class="n">excludedBlockTypesInBlock</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">x</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BLOCK_MIXTURE_TYPE_EXCLUSIONS</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">numHexBlockByType</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">excludedBlockTypesInBlock</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">blockType</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BLOCK_MIXTURE_TYPE_EXCLUSIONS</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">blockType</span> <span class="ow">in</span> <span class="n">excludedBlockTypesInBlock</span><span class="p">:</span>
                    <span class="n">assignedMixtureBlockType</span> <span class="o">=</span> <span class="s2">&quot;mixture &quot;</span> <span class="o">+</span> <span class="n">blockType</span>
                    <span class="k">return</span> <span class="n">assignedMixtureBlockType</span>

        <span class="c1"># Assign block type by most common hex block type</span>
        <span class="n">mostCommonHexBlockType</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">numHexBlockByType</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span>
            <span class="mi">0</span>
        <span class="p">]</span>  <span class="c1"># sort needed for tie break</span>

        <span class="k">for</span> <span class="n">mixtureType</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_BLOCK_MIXTURE_TYPE_MAP</span><span class="p">):</span>
            <span class="n">validBlockTypesInMixture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BLOCK_MIXTURE_TYPE_MAP</span><span class="p">[</span><span class="n">mixtureType</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">validBlockType</span> <span class="ow">in</span> <span class="n">validBlockTypesInMixture</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">validBlockType</span> <span class="ow">in</span> <span class="n">mostCommonHexBlockType</span><span class="p">:</span>
                    <span class="n">assignedMixtureBlockType</span> <span class="o">=</span> <span class="n">mixtureType</span>
                    <span class="k">return</span> <span class="n">assignedMixtureBlockType</span>

        <span class="n">assignedMixtureBlockType</span> <span class="o">=</span> <span class="s2">&quot;mixture structure&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The mixture type for this homogenized block </span><span class="si">{</span><span class="n">mostCommonHexBlockType</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;was not determined and is defaulting to </span><span class="si">{</span><span class="n">assignedMixtureBlockType</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">assignedMixtureBlockType</span>

    <span class="k">def</span> <span class="nf">_createBlendedXSID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newBlock</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the blended XS id using the most common XS id in the hexIdList.&quot;&quot;&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">hexBlock</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span> <span class="k">for</span> <span class="n">hexBlock</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blockMap</span><span class="p">[</span><span class="n">newBlock</span><span class="p">]]</span>
        <span class="n">xsTypeList</span><span class="p">,</span> <span class="n">buGroupList</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">ids</span><span class="p">)</span>

        <span class="n">xsType</span><span class="p">,</span> <span class="n">_count</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">xsTypeList</span><span class="p">)</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">buGroup</span><span class="p">,</span> <span class="n">_count</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">buGroupList</span><span class="p">)</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">xsType</span><span class="p">,</span> <span class="n">buGroup</span>

    <span class="k">def</span> <span class="nf">_writeRadialThetaZoneHeader</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">radIdx</span><span class="p">,</span> <span class="n">lowerRing</span><span class="p">,</span> <span class="n">upperRing</span><span class="p">,</span> <span class="n">thIdx</span><span class="p">,</span> <span class="n">lowerTheta</span><span class="p">,</span> <span class="n">upperTheta</span>
    <span class="p">):</span>
        <span class="n">radialAssemType</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_currentRadialZoneType</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currentRadialZoneType</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="p">)</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Creating: Radial Zone </span><span class="si">{}</span><span class="s2">, Theta Zone </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">radIdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">thIdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">radialAssemType</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> Hex Rings: [</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">), Theta Revolutions: [</span><span class="si">{:.2f}</span><span class="s2">, </span><span class="si">{:.2f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="mi">9</span> <span class="o">*</span> <span class="n">STR_SPACE</span><span class="p">,</span>
                <span class="n">lowerRing</span><span class="p">,</span>
                <span class="n">upperRing</span><span class="p">,</span>
                <span class="n">lowerTheta</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">RAD_TO_REV</span><span class="p">,</span>
                <span class="n">upperTheta</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">RAD_TO_REV</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> Axial Zone - Axial Height (cm) Block Number Block Type             XS ID : &quot;</span>
            <span class="s2">&quot;Original Hex Block XS ID(s)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">9</span> <span class="o">*</span> <span class="n">STR_SPACE</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> ---------- - ----------------- ------------ ---------------------- ----- : &quot;</span>
            <span class="s2">&quot;---------------------------&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">9</span> <span class="o">*</span> <span class="n">STR_SPACE</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_writeRadialThetaZoneInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axIdx</span><span class="p">,</span> <span class="n">axialSegmentHeight</span><span class="p">,</span> <span class="n">blockObj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a summary of the mapping between the converted reactor block ids to the hex</span>
<span class="sd">        reactor block ids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_newBlockNum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">hexBlockXsIds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hexBlock</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blockMap</span><span class="p">[</span><span class="n">blockObj</span><span class="p">]:</span>
            <span class="n">hexBlockXsIds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hexBlock</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">())</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{:&lt;10}</span><span class="s2"> - </span><span class="si">{:&lt;17.3f}</span><span class="s2"> </span><span class="si">{:&lt;12}</span><span class="s2"> </span><span class="si">{:&lt;22}</span><span class="s2"> </span><span class="si">{:&lt;5}</span><span class="s2"> : </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="mi">9</span> <span class="o">*</span> <span class="n">STR_SPACE</span><span class="p">,</span>
                <span class="n">axIdx</span><span class="p">,</span>
                <span class="n">axialSegmentHeight</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_newBlockNum</span><span class="p">,</span>
                <span class="n">blockObj</span><span class="o">.</span><span class="n">getType</span><span class="p">(),</span>
                <span class="n">blockObj</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">(),</span>
                <span class="n">hexBlockXsIds</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expandSourceReactorGeometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expansion of the reactor geometry to build the R-Z-Theta core model.&quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Expanding source reactor core to a full core model&quot;</span><span class="p">)</span>
        <span class="n">reactorExpander</span> <span class="o">=</span> <span class="n">ThirdCoreHexToFullCoreChanger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cs</span><span class="p">)</span>
        <span class="n">reactorExpander</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">summarizeReactorStats</span><span class="p">()</span>

<div class="viewcode-block" id="HexToRZThetaConverter.plotConvertedReactor"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.HexToRZThetaConverter.plotConvertedReactor">[docs]</a>    <span class="k">def</span> <span class="nf">plotConvertedReactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fNameBase</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate plots for the converted RZT reactor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fNameBase : str, optional</span>
<span class="sd">            A name that will form the basis of the N plots that are generated by this method. Will</span>
<span class="sd">            get split on extension and have numbers added. Should be like ``coreMap.png``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        XTView can be used to view the RZT reactor but this is useful to examine the conversion of</span>
<span class="sd">        the hex-z reactor to the rzt reactor.</span>

<span class="sd">        This makes plots of each individual theta mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Generating plot(s) of the converted </span><span class="si">{}</span><span class="s2"> reactor&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">geomType</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">figs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">colConv</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">ColorConverter</span><span class="p">()</span>
        <span class="n">colGen</span> <span class="o">=</span> <span class="n">plotting</span><span class="o">.</span><span class="n">colorGenerator</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">blockColors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">thetaMesh</span><span class="p">,</span> <span class="n">radialMesh</span><span class="p">,</span> <span class="n">axialMesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getReactorMeshCoordinates</span><span class="p">()</span>
        <span class="n">innerTheta</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">outerTheta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thetaMesh</span><span class="p">):</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
            <span class="n">innerRadius</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">outerRadius</span> <span class="ow">in</span> <span class="n">radialMesh</span><span class="p">:</span>
                <span class="n">innerAxial</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">outerAxial</span> <span class="ow">in</span> <span class="n">axialMesh</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getBlockAtMeshPoint</span><span class="p">(</span>
                        <span class="n">innerTheta</span><span class="p">,</span>
                        <span class="n">outerTheta</span><span class="p">,</span>
                        <span class="n">innerRadius</span><span class="p">,</span>
                        <span class="n">outerRadius</span><span class="p">,</span>
                        <span class="n">innerAxial</span><span class="p">,</span>
                        <span class="n">outerAxial</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">blockType</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span>
                    <span class="n">blockColor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getBlockColor</span><span class="p">(</span>
                        <span class="n">colConv</span><span class="p">,</span> <span class="n">colGen</span><span class="p">,</span> <span class="n">blockColors</span><span class="p">,</span> <span class="n">blockType</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">blockColor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">blockColors</span><span class="p">[</span><span class="n">blockType</span><span class="p">]</span> <span class="o">=</span> <span class="n">blockColor</span>
                    <span class="n">blockPatch</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">innerRadius</span><span class="p">,</span> <span class="n">innerAxial</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">outerRadius</span> <span class="o">-</span> <span class="n">innerRadius</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">outerAxial</span> <span class="o">-</span> <span class="n">innerAxial</span><span class="p">),</span>
                        <span class="n">facecolor</span><span class="o">=</span><span class="n">blockColors</span><span class="p">[</span><span class="n">blockType</span><span class="p">],</span>
                        <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">blockPatch</span><span class="p">)</span>
                    <span class="n">innerAxial</span> <span class="o">=</span> <span class="n">outerAxial</span>
                <span class="n">innerRadius</span> <span class="o">=</span> <span class="n">outerRadius</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> Core Map from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{:.4f}</span><span class="s2"> revolutions&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">geomType</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>
                    <span class="n">innerTheta</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">RAD_TO_REV</span><span class="p">,</span>
                    <span class="n">outerTheta</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">RAD_TO_REV</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">y</span><span class="o">=</span><span class="mf">1.03</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">+</span> <span class="n">radialMesh</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">+</span> <span class="n">axialMesh</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;major&quot;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">label</span><span class="o">.</span><span class="n">set_rotation</span><span class="p">(</span><span class="mi">270</span><span class="p">)</span>
            <span class="n">handles</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">blockType</span><span class="p">,</span> <span class="n">blockColor</span> <span class="ow">in</span> <span class="n">blockColors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span>
                    <span class="p">[],</span> <span class="p">[],</span> <span class="n">color</span><span class="o">=</span><span class="n">blockColor</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">blockType</span>
                <span class="p">)</span>
                <span class="n">handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">get_label</span><span class="p">())</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Radial Mesh (cm)&quot;</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">labelpad</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Axial Mesh (cm)&quot;</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">labelpad</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fNameBase</span><span class="p">:</span>
                <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fNameBase</span><span class="p">)</span>
                <span class="n">fName</span> <span class="o">=</span> <span class="n">root</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">ext</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fName</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">figs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
            <span class="n">innerTheta</span> <span class="o">=</span> <span class="n">outerTheta</span>

        <span class="k">return</span> <span class="n">figs</span></div>

    <span class="k">def</span> <span class="nf">_getReactorMeshCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">thetaMesh</span><span class="p">,</span> <span class="n">radialMesh</span><span class="p">,</span> <span class="n">axialMesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">findAllMeshPoints</span><span class="p">(</span>
            <span class="n">applySubMesh</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">thetaMesh</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">radialMesh</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">axialMesh</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">thetaMesh</span><span class="p">,</span> <span class="n">radialMesh</span><span class="p">,</span> <span class="n">axialMesh</span>

    <span class="k">def</span> <span class="nf">_getBlockAtMeshPoint</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">innerTheta</span><span class="p">,</span> <span class="n">outerTheta</span><span class="p">,</span> <span class="n">innerRadius</span><span class="p">,</span> <span class="n">outerRadius</span><span class="p">,</span> <span class="n">innerAxial</span><span class="p">,</span> <span class="n">outerAxial</span>
    <span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">():</span>
            <span class="n">blockMidTh</span><span class="p">,</span> <span class="n">blockMidR</span><span class="p">,</span> <span class="n">blockMidZ</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">(</span>
                <span class="n">nativeCoords</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">blockMidTh</span> <span class="o">&gt;=</span> <span class="n">innerTheta</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">blockMidTh</span> <span class="o">&lt;=</span> <span class="n">outerTheta</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">blockMidR</span> <span class="o">&gt;=</span> <span class="n">innerRadius</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">blockMidR</span> <span class="o">&lt;=</span> <span class="n">outerRadius</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">blockMidZ</span> <span class="o">&gt;=</span> <span class="n">innerAxial</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">blockMidZ</span> <span class="o">&lt;=</span> <span class="n">outerAxial</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">b</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;No block found between (</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">), (</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">), (</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Last block had TRZ= </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">innerTheta</span><span class="p">,</span>
                <span class="n">outerTheta</span><span class="p">,</span>
                <span class="n">innerRadius</span><span class="p">,</span>
                <span class="n">outerRadius</span><span class="p">,</span>
                <span class="n">innerAxial</span><span class="p">,</span>
                <span class="n">outerAxial</span><span class="p">,</span>
                <span class="n">blockMidTh</span><span class="p">,</span>
                <span class="n">blockMidR</span><span class="p">,</span>
                <span class="n">blockMidZ</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_getBlockColor</span><span class="p">(</span><span class="n">colConverter</span><span class="p">,</span> <span class="n">colGenerator</span><span class="p">,</span> <span class="n">blockColors</span><span class="p">,</span> <span class="n">blockType</span><span class="p">):</span>
        <span class="n">nextColor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">blockType</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">blockColors</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;fuel&quot;</span> <span class="ow">in</span> <span class="n">blockType</span><span class="p">:</span>
                <span class="n">nextColor</span> <span class="o">=</span> <span class="s2">&quot;tomato&quot;</span>
            <span class="k">elif</span> <span class="s2">&quot;structure&quot;</span> <span class="ow">in</span> <span class="n">blockType</span><span class="p">:</span>
                <span class="n">nextColor</span> <span class="o">=</span> <span class="s2">&quot;lightgrey&quot;</span>
            <span class="k">elif</span> <span class="s2">&quot;radial shield&quot;</span> <span class="ow">in</span> <span class="n">blockType</span><span class="p">:</span>
                <span class="n">nextColor</span> <span class="o">=</span> <span class="s2">&quot;lightgrey&quot;</span>
            <span class="k">elif</span> <span class="s2">&quot;duct&quot;</span> <span class="ow">in</span> <span class="n">blockType</span><span class="p">:</span>
                <span class="n">nextColor</span> <span class="o">=</span> <span class="s2">&quot;grey&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">nextColor</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">colGenerator</span><span class="p">)</span>
                        <span class="n">colConverter</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">nextColor</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">continue</span>
        <span class="k">return</span> <span class="n">nextColor</span>

<div class="viewcode-block" id="HexToRZThetaConverter.reset"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.HexToRZThetaConverter.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clear out attribute data, including holding the state of the converted reactor core model.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshConverter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radialMeshConversionType</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axialMeshConversionType</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_previousRadialZoneAssemTypes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_currentRadialZoneType</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assemsInRadialZone</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_newBlockNum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blockMap</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blockVolFracs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convReactor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="HexToRZConverter"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.HexToRZConverter">[docs]</a><span class="k">class</span> <span class="nc">HexToRZConverter</span><span class="p">(</span><span class="n">HexToRZThetaConverter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new reactor with R-Z coordinates from the Hexagonal-Z reactor.</span>

<span class="sd">    This is a subclass of the HexToRZThetaConverter. See the HexToRZThetaConverter for</span>
<span class="sd">    explanation and setup of the converterSettings.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_GEOMETRY_TYPE</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="o">.</span><span class="n">RZ</span></div>


<div class="viewcode-block" id="ThirdCoreHexToFullCoreChanger"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.ThirdCoreHexToFullCoreChanger">[docs]</a><span class="k">class</span> <span class="nc">ThirdCoreHexToFullCoreChanger</span><span class="p">(</span><span class="n">GeometryChanger</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change third-core models to full core in place.</span>

<span class="sd">    Does not generate a new reactor object.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; converter = ThirdCoreHexToFullCoreChanger()</span>
<span class="sd">    &gt;&gt;&gt; converter.convert(myReactor)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">EXPECTED_INPUT_SYMMETRY</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">SymmetryType</span><span class="p">(</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">THIRD_CORE</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">PERIODIC</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">GeometryChanger</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listOfVolIntegratedParamsToScale</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_scaleBlockVolIntegratedParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;up&quot;</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;down&quot;</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span>

        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfVolIntegratedParamsToScale</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                <span class="c1"># some params like volume-integrated mg flux are lists</span>
                <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>

<div class="viewcode-block" id="ThirdCoreHexToFullCoreChanger.convert"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.ThirdCoreHexToFullCoreChanger.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the conversion.</span>

<span class="sd">        .. impl:: Convert a one-third-core geometry to a full-core geometry.</span>
<span class="sd">            :id: I_ARMI_THIRD_TO_FULL_CORE0</span>
<span class="sd">            :implements: R_ARMI_THIRD_TO_FULL_CORE</span>

<span class="sd">            This method first checks if the input reactor is already full core. If full-core</span>
<span class="sd">            symmetry is detected, the input reactor is returned. If not, it then verifies that the</span>
<span class="sd">            input reactor has the expected one-third core symmetry and HEX geometry.</span>

<span class="sd">            Upon conversion, it loops over the assembly vector of the source one-third core model,</span>
<span class="sd">            copies and rotates each source assembly to create new assemblies, and adds them on the</span>
<span class="sd">            full-core grid. For the center assembly, it modifies its parameters.</span>

<span class="sd">            Finally, it sets the domain type to full core.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sourceReactor : Reactor object</span>
<span class="sd">            The reactor to convert.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span> <span class="o">=</span> <span class="n">r</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">isFullCore</span><span class="p">:</span>
            <span class="c1"># already full core from geometry file. No need to copy symmetry over.</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span>
                <span class="s2">&quot;Detected that full core reactor already exists. Cannot expand.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">EXPECTED_INPUT_SYMMETRY</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">geomType</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="o">.</span><span class="n">HEX</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;ThirdCoreHexToFullCoreChanger requires the input to have third core hex geometry. &quot;</span>
                <span class="s2">&quot;Geometry received was </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">geomType</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">edgeChanger</span> <span class="o">=</span> <span class="n">EdgeAssemblyChanger</span><span class="p">()</span>
        <span class="n">edgeChanger</span><span class="o">.</span><span class="n">removeEdgeAssemblies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="p">)</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Expanding to full core geometry&quot;</span><span class="p">)</span>

        <span class="c1"># store a copy of the 1/3 geometry grid, so that we can use it to find symmetric</span>
        <span class="c1"># locations, while the core has a full-core grid so that it doesnt yell at us</span>
        <span class="c1"># for adding stuff outside of the first 1/3</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">)</span>

        <span class="c1"># Set the core grid&#39;s symmetry early, since the core uses it for error checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">SymmetryType</span><span class="p">(</span>
            <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">FULL_CORE</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">NO_SYMMETRY</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">():</span>
            <span class="c1"># make extras and add them too. since the input is assumed to be 1/3 core.</span>
            <span class="n">otherLocs</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getSymmetricEquivalents</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">thisZone</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">zones</span><span class="o">.</span><span class="n">findZoneItIsIn</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">zones</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">otherLocs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">otherLocs</span><span class="p">:</span>
                <span class="n">newAssem</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="n">newAssem</span><span class="o">.</span><span class="n">makeUnique</span><span class="p">()</span>
                <span class="n">newAssem</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                    <span class="n">newAssem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">thisZone</span><span class="p">:</span>
                    <span class="n">thisZone</span><span class="o">.</span><span class="n">addLoc</span><span class="p">(</span><span class="n">newAssem</span><span class="o">.</span><span class="n">getLocation</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_newAssembliesAdded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newAssem</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;001-001&quot;</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Modifying parameters in central assembly </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2"> to convert from 1/3 to full core&quot;</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfVolIntegratedParamsToScale</span><span class="p">:</span>
                    <span class="c1"># populate the list with all parameters that are VOLUME_INTEGRATED</span>
                    <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">listOfVolIntegratedParamsToScale</span><span class="p">,</span>
                        <span class="n">_</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="n">_generateListOfParamsToScale</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="p">,</span> <span class="n">paramsToScaleSubset</span><span class="o">=</span><span class="p">[]</span>
                    <span class="p">)</span>

                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_scaleBlockVolIntegratedParams</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">)</span>

        <span class="c1"># set domain after expanding, because it isnt actually full core until it&#39;s</span>
        <span class="c1"># full core; setting the domain causes the core to clear its caches.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">SymmetryType</span><span class="p">(</span>
            <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">FULL_CORE</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">NO_SYMMETRY</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ThirdCoreHexToFullCoreChanger.restorePreviousGeometry"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.ThirdCoreHexToFullCoreChanger.restorePreviousGeometry">[docs]</a>    <span class="k">def</span> <span class="nf">restorePreviousGeometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Undo the changes made by convert by going back to 1/3 core.</span>

<span class="sd">        .. impl:: Restore a one-third-core geometry to a full-core geometry.</span>
<span class="sd">            :id: I_ARMI_THIRD_TO_FULL_CORE1</span>
<span class="sd">            :implements: R_ARMI_THIRD_TO_FULL_CORE</span>

<span class="sd">            This method is a reverse process of the method ``convert``. It converts the full-core</span>
<span class="sd">            reactor model back to the original one-third core reactor model by removing the added</span>
<span class="sd">            assemblies and changing the parameters of the center assembly from full core to one</span>
<span class="sd">            third core.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sourceReactor</span>

        <span class="c1"># remove the assemblies that were added when the conversion happened.</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_newAssembliesAdded</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_newAssembliesAdded</span><span class="p">:</span>
                <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">removeAssembly</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">discharge</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">SymmetryType</span><span class="o">.</span><span class="n">fromAny</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">EXPECTED_INPUT_SYMMETRY</span>
            <span class="p">)</span>

            <span class="c1"># change the central assembly params back to 1/3</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblyWithStringLocation</span><span class="p">(</span><span class="s2">&quot;001-001&quot;</span><span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Modifying parameters in central assembly </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2"> to revert from full to 1/3 core&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scaleBlockVolIntegratedParams</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="EdgeAssemblyChanger"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.EdgeAssemblyChanger">[docs]</a><span class="k">class</span> <span class="nc">EdgeAssemblyChanger</span><span class="p">(</span><span class="n">GeometryChanger</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add/remove &quot;edge assemblies&quot; for Finite difference or MCNP cases.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">        edgeChanger = EdgeAssemblyChanger()</span>
<span class="sd">        edgeChanger.removeEdgeAssemblies(reactor.core)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="EdgeAssemblyChanger.addEdgeAssemblies"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.EdgeAssemblyChanger.addEdgeAssemblies">[docs]</a>    <span class="k">def</span> <span class="nf">addEdgeAssemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">core</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the assemblies on the 120 degree symmetric line to 1/3 symmetric cases.</span>

<span class="sd">        Needs to be called before a finite difference (DIF3D, DIFNT) or MCNP calculation.</span>

<span class="sd">        .. impl:: Add assemblies along the 120-degree line to a reactor.</span>
<span class="sd">            :id: I_ARMI_ADD_EDGE_ASSEMS0</span>
<span class="sd">            :implements: R_ARMI_ADD_EDGE_ASSEMS</span>

<span class="sd">            Edge assemblies on the 120-degree symmetric line of a one-third core reactor model are</span>
<span class="sd">            added because they are needed for DIF3D-finite difference or MCNP models. This is done</span>
<span class="sd">            by copying the assemblies from the lower boundary and placing them in their reflective</span>
<span class="sd">            positions on the upper boundary of the symmetry line.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reactor : Reactor</span>
<span class="sd">            Reactor to modify</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        removeEdgeAssemblies : removes the edge assemblies</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">isFullCore</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_newAssembliesAdded</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span>
                <span class="s2">&quot;Skipping addition of edge assemblies because they are already there&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">assembliesOnLowerBoundary</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">getAssembliesOnSymmetryLine</span><span class="p">(</span>
            <span class="n">grids</span><span class="o">.</span><span class="n">BOUNDARY_0_DEGREES</span>
        <span class="p">)</span>
        <span class="n">assembliesOnUpperBoundary</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assembliesOnLowerBoundary</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>  <span class="c1"># symmetry factors of these assemblies will change since they are now half assems.</span>
            <span class="n">a2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">a2</span><span class="o">.</span><span class="n">makeUnique</span><span class="p">()</span>
            <span class="n">assembliesOnUpperBoundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">assembliesOnUpperBoundary</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;No edge assemblies to add&quot;</span><span class="p">)</span>

        <span class="c1"># Move the assemblies into their reflective position on symmetry line 3</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assembliesOnUpperBoundary</span><span class="p">:</span>
            <span class="c1"># loc will now be either an empty set [], or two different locations</span>
            <span class="c1"># in our case, we only want the first of the two locations</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getSymmetricEquivalents</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">locs</span><span class="p">:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">spatialLocator</span><span class="p">):</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;Edge assembly already exists in </span><span class="si">{0}</span><span class="s2">. Not adding.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>
                <span class="c1"># add the copied assembly to the reactor list</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Adding edge assembly </span><span class="si">{0}</span><span class="s2"> to </span><span class="si">{1}</span><span class="s2"> to the reactor&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">a</span><span class="p">,</span> <span class="n">spatialLocator</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">core</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">spatialLocator</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_newAssembliesAdded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="n">parameters</span><span class="o">.</span><span class="n">ALL_DEFINITIONS</span><span class="o">.</span><span class="n">resetAssignmentFlag</span><span class="p">(</span>
            <span class="n">SINCE_LAST_GEOMETRY_TRANSFORMATION</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="EdgeAssemblyChanger.removeEdgeAssemblies"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.EdgeAssemblyChanger.removeEdgeAssemblies">[docs]</a>    <span class="k">def</span> <span class="nf">removeEdgeAssemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">core</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the edge assemblies in preparation for the nodal diffusion approximation.</span>

<span class="sd">        This makes use of the assemblies knowledge of if it is in a region that it needs to be</span>
<span class="sd">        removed.</span>

<span class="sd">        .. impl:: Remove assemblies along the 120-degree line from a reactor.</span>
<span class="sd">            :id: I_ARMI_ADD_EDGE_ASSEMS1</span>
<span class="sd">            :implements: R_ARMI_ADD_EDGE_ASSEMS</span>

<span class="sd">            This method is the reverse process of the method ``addEdgeAssemblies``. It is needed for</span>
<span class="sd">            the DIF3D-Nodal calculation. It removes the assemblies on the 120-degree symmetry line.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        addEdgeAssemblies : adds the edge assemblies</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">isFullCore</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">assembliesOnLowerBoundary</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">getAssembliesOnSymmetryLine</span><span class="p">(</span>
            <span class="n">grids</span><span class="o">.</span><span class="n">BOUNDARY_0_DEGREES</span>
        <span class="p">)</span>
        <span class="c1"># Don&#39;t use newAssembliesAdded b/c this may be BOL cleaning of a fresh case that has edge</span>
        <span class="c1"># assems.</span>
        <span class="n">edgeAssemblies</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">getAssembliesOnSymmetryLine</span><span class="p">(</span><span class="n">grids</span><span class="o">.</span><span class="n">BOUNDARY_120_DEGREES</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">edgeAssemblies</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Removing edge assembly </span><span class="si">{}</span><span class="s2"> from </span><span class="si">{}</span><span class="s2"> from the reactor without discharging&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">core</span><span class="o">.</span><span class="n">removeAssembly</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">discharge</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edgeAssemblies</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assembliesOnLowerBoundary</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>  <span class="c1"># clear cached area since symmetry factor will change</span>
            <span class="c1"># Reset the SINCE_LAST_GEOMETRY_TRANSFORMATION flag, so that subsequent geometry</span>
            <span class="c1"># conversions don&#39;t erroneously think they&#39;ve been changed inside this geometry</span>
            <span class="c1"># conversion</span>
            <span class="n">pDefs</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">ALL_DEFINITIONS</span><span class="o">.</span><span class="n">unchanged_since</span><span class="p">(</span><span class="n">NEVER</span><span class="p">)</span>
            <span class="n">pDefs</span><span class="o">.</span><span class="n">setAssignmentFlag</span><span class="p">(</span><span class="n">SINCE_LAST_GEOMETRY_TRANSFORMATION</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No edge assemblies to remove.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div>

<div class="viewcode-block" id="EdgeAssemblyChanger.scaleParamsRelatedToSymmetry"><a class="viewcode-back" href="../../../../.apidocs/armi.reactor.converters.geometryConverters.html#armi.reactor.converters.geometryConverters.EdgeAssemblyChanger.scaleParamsRelatedToSymmetry">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">scaleParamsRelatedToSymmetry</span><span class="p">(</span><span class="n">reactor</span><span class="p">,</span> <span class="n">paramsToScaleSubset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scale volume-dependent params like power to account for cut-off edges.</span>

<span class="sd">        These params are at half their full hex value. Scale them right before deleting their</span>
<span class="sd">        symmetric identicals. The two operations (scaling them and then removing others) is</span>
<span class="sd">        identical to combining two half-assemblies into a full one.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.converters.geometryConverter.EdgeAssemblyChanger.removeEdgeAssemblies</span>
<span class="sd">        armi.reactor.blocks.HexBlock.getSymmetryFactor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
            <span class="s2">&quot;Scaling edge-assembly parameters to account for full hexes instead of two halves&quot;</span>
        <span class="p">)</span>
        <span class="n">completeListOfParamsToScale</span> <span class="o">=</span> <span class="n">_generateListOfParamsToScale</span><span class="p">(</span>
            <span class="n">reactor</span><span class="p">,</span> <span class="n">paramsToScaleSubset</span>
        <span class="p">)</span>
        <span class="n">symmetricAssems</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">reactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssembliesOnSymmetryLine</span><span class="p">(</span><span class="n">grids</span><span class="o">.</span><span class="n">BOUNDARY_0_DEGREES</span><span class="p">),</span>
            <span class="n">reactor</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssembliesOnSymmetryLine</span><span class="p">(</span><span class="n">grids</span><span class="o">.</span><span class="n">BOUNDARY_120_DEGREES</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">symmetricAssems</span><span class="p">):</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;No edge-assemblies found to scale parameters for.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">aSymmetric</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">symmetricAssems</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">bSymmetric</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">aSymmetric</span><span class="p">):</span>
                <span class="n">_scaleParamsInBlock</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bSymmetric</span><span class="p">,</span> <span class="n">completeListOfParamsToScale</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_generateListOfParamsToScale</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">paramsToScaleSubset</span><span class="p">):</span>
    <span class="n">fluxParamsToScale</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getFirstBlock</span><span class="p">()</span>
        <span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="o">.</span><span class="n">inCategory</span><span class="p">(</span><span class="n">Category</span><span class="o">.</span><span class="n">fluxQuantities</span><span class="p">)</span>
        <span class="o">.</span><span class="n">inCategory</span><span class="p">(</span><span class="n">Category</span><span class="o">.</span><span class="n">multiGroupQuantities</span><span class="p">)</span>
        <span class="o">.</span><span class="n">names</span>
    <span class="p">)</span>
    <span class="n">listOfVolumeIntegratedParamsToScale</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getFirstBlock</span><span class="p">()</span>
        <span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="o">.</span><span class="n">atLocation</span><span class="p">(</span><span class="n">ParamLocation</span><span class="o">.</span><span class="n">VOLUME_INTEGRATED</span><span class="p">)</span>
        <span class="o">.</span><span class="n">since</span><span class="p">(</span><span class="n">SINCE_LAST_GEOMETRY_TRANSFORMATION</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">listOfVolumeIntegratedParamsToScale</span> <span class="o">=</span> <span class="n">listOfVolumeIntegratedParamsToScale</span><span class="o">.</span><span class="n">names</span>
    <span class="k">if</span> <span class="n">paramsToScaleSubset</span><span class="p">:</span>
        <span class="n">listOfVolumeIntegratedParamsToScale</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pn</span>
            <span class="k">for</span> <span class="n">pn</span> <span class="ow">in</span> <span class="n">paramsToScaleSubset</span>
            <span class="k">if</span> <span class="n">pn</span> <span class="ow">in</span> <span class="n">listOfVolumeIntegratedParamsToScale</span>
        <span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">listOfVolumeIntegratedParamsToScale</span><span class="p">,</span> <span class="n">fluxParamsToScale</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_scaleParamsInBlock</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bSymmetric</span><span class="p">,</span> <span class="n">completeListOfParamsToScale</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Scale volume-integrated params to include their identical symmetric assemblies.&quot;&quot;&quot;</span>
    <span class="n">listOfVolumeIntegratedParamsToScale</span><span class="p">,</span> <span class="n">fluxParamsToScale</span> <span class="o">=</span> <span class="n">completeListOfParamsToScale</span>
    <span class="k">for</span> <span class="n">paramName</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="n">pn</span> <span class="k">for</span> <span class="n">pn</span> <span class="ow">in</span> <span class="n">listOfVolumeIntegratedParamsToScale</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">pn</span><span class="p">])</span>
    <span class="p">]:</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Scaling </span><span class="si">{}</span><span class="s2"> in symmetric identical assemblies&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">paramName</span><span class="p">),</span>
            <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">paramName</span> <span class="ow">in</span> <span class="n">fluxParamsToScale</span><span class="p">:</span>
            <span class="n">_scaleFluxValues</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bSymmetric</span><span class="p">,</span> <span class="n">paramName</span><span class="p">)</span>  <span class="c1"># updated volume weighted fluxes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span> <span class="o">+</span> <span class="n">bSymmetric</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_scaleFluxValues</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bSymmetric</span><span class="p">,</span> <span class="n">paramName</span><span class="p">):</span>
    <span class="n">totalVol</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span> <span class="o">+</span> <span class="n">bSymmetric</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>

    <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">f</span> <span class="o">+</span> <span class="n">fSymmetric</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">fSymmetric</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">paramName</span><span class="p">],</span> <span class="n">bSymmetric</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">paramName</span><span class="p">])</span>
    <span class="p">]</span>

    <span class="n">newTotalFlux</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">paramName</span><span class="p">])</span> <span class="o">/</span> <span class="n">totalVol</span>

    <span class="k">if</span> <span class="n">paramName</span> <span class="o">==</span> <span class="s2">&quot;mgFlux&quot;</span><span class="p">:</span>
        <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">newTotalFlux</span>
    <span class="k">elif</span> <span class="n">paramName</span> <span class="o">==</span> <span class="s2">&quot;adjMgFlux&quot;</span><span class="p">:</span>
        <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">fluxAdj</span> <span class="o">=</span> <span class="n">newTotalFlux</span>
    <span class="k">elif</span> <span class="n">paramName</span> <span class="o">==</span> <span class="s2">&quot;mgFluxGamma&quot;</span><span class="p">:</span>
        <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">fluxGamma</span> <span class="o">=</span> <span class="n">newTotalFlux</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2009-2024, TerraPower, LLC.
      <span class="lastupdated">Last updated on 2024-08-29.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>


<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>armi.reactor.blocks &mdash; ARMI 0.6.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme_fixes.css?v=2b77b304" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=e5fbc548" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-data-viewer/jsonview.bundle.css?v=f6ef2277" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/libs/html/datatables.min.css?v=4b4fd840" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/common_css/needstable.css?v=5e1b6797" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/common_css/need_links.css?v=2150a916" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/common_css/need_toggle.css?v=5c6620df" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/common_css/need_style.css?v=678fb11e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/common_css/need_core.css?v=f5b60a78" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-needs/modern.css?v=803738c0" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-test-results/common.css?v=9ec2c1d5" />

  
    <link rel="shortcut icon" href="../../../_static/armiicon_16x16.ico"/>
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=8fa8b3e9"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="../../../_static/sphinx-data-viewer/jsonview.bundle.js?v=18cd53c5"></script>
      <script src="../../../_static/sphinx-data-viewer/jsonview_loader.js?v=f7ff7e7d"></script>
      <script src="../../../_static/sphinx-needs/libs/html/datatables.min.js?v=8a4aee21"></script>
      <script src="../../../_static/sphinx-needs/libs/html/datatables_loader.js?v=a2cae175"></script>
      <script src="../../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js?v=dca66431"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ARMI
              <img src="../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../qa_docs/index.html">QA Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../.apidocs/modules.html">API Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #233C5B" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ARMI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../armi.html">armi</a></li>
          <li class="breadcrumb-item"><a href="../reactor.html">armi.reactor</a></li>
      <li class="breadcrumb-item active">armi.reactor.blocks</li>
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for armi.reactor.blocks</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Defines blocks, which are axial chunks of assemblies. They contain most of the state variables,</span>
<span class="sd">including power, flux, and homogenized number densities.</span>

<span class="sd">Assemblies are made of blocks. Blocks are made of components.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">ClassVar</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">armi</span><span class="w"> </span><span class="kn">import</span> <span class="n">nuclideBases</span><span class="p">,</span> <span class="n">runLog</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.bookkeeping</span><span class="w"> </span><span class="kn">import</span> <span class="n">report</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.nuclearDataIO</span><span class="w"> </span><span class="kn">import</span> <span class="n">xsCollections</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.physics.neutronics</span><span class="w"> </span><span class="kn">import</span> <span class="n">GAMMA</span><span class="p">,</span> <span class="n">NEUTRON</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">blockParameters</span><span class="p">,</span>
    <span class="n">components</span><span class="p">,</span>
    <span class="n">composites</span><span class="p">,</span>
    <span class="n">geometry</span><span class="p">,</span>
    <span class="n">grids</span><span class="p">,</span>
    <span class="n">parameters</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.components</span><span class="w"> </span><span class="kn">import</span> <span class="n">basicShapes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.components.basicShapes</span><span class="w"> </span><span class="kn">import</span> <span class="n">Circle</span><span class="p">,</span> <span class="n">Hexagon</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.components.complexShapes</span><span class="w"> </span><span class="kn">import</span> <span class="n">Helix</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.flags</span><span class="w"> </span><span class="kn">import</span> <span class="n">Flags</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.parameters</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParamLocation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">densityTools</span><span class="p">,</span> <span class="n">hexagon</span><span class="p">,</span> <span class="n">iterables</span><span class="p">,</span> <span class="n">units</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.utils.plotting</span><span class="w"> </span><span class="kn">import</span> <span class="n">plotBlockFlux</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.utils.units</span><span class="w"> </span><span class="kn">import</span> <span class="n">TRACE_NUMBER_DENSITY</span>

<span class="n">PIN_COMPONENTS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">CONTROL</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">PLENUM</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">SHIELD</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">PIN</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">_PitchDefiningComponent</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">components</span><span class="o">.</span><span class="n">Component</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span>


<div class="viewcode-block" id="Block">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Block</span><span class="p">(</span><span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An axial slice of an assembly.</span>

<span class="sd">    Blocks are Composite objects with extra parameter bindings, and utility methods that let them</span>
<span class="sd">    play nicely with their containing Assembly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">uniqID</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># dimension used to determine which component defines the block&#39;s pitch</span>
    <span class="n">PITCH_DIMENSION</span> <span class="o">=</span> <span class="s2">&quot;op&quot;</span>

    <span class="c1"># component type that can be considered a candidate for providing pitch</span>
    <span class="n">PITCH_COMPONENT_TYPE</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">_PitchDefiningComponent</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">pDefs</span> <span class="o">=</span> <span class="n">blockParameters</span><span class="o">.</span><span class="n">getBlockParameterDefinitions</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a new ARMI block.</span>

<span class="sd">        name : str</span>
<span class="sd">            The name of this block</span>
<span class="sd">        height : float, optional</span>
<span class="sd">            The height of the block in cm. Defaults to 1.0 so that ``getVolume`` assumes unit height.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">heightBOL</span> <span class="o">=</span> <span class="n">height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">macros</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># flag to indicated when DerivedShape children must be updated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derivedMustUpdate</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># which component to use to determine block pitch, along with its &#39;op&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># Manually set some parameters at BOL</span>
        <span class="k">for</span> <span class="n">problemParam</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;THcornTemp&quot;</span><span class="p">,</span> <span class="s2">&quot;THedgeTemp&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">problemParam</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># be warned, changing this might break unit tests on input file generations</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{type}</span><span class="s2"> </span><span class="si">{name}</span><span class="s2"> at </span><span class="si">{loc}</span><span class="s2"> XS: </span><span class="si">{xs}</span><span class="s2"> ENV GP: </span><span class="si">{env}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getType</span><span class="p">(),</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span>
            <span class="n">xs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">xsType</span><span class="p">,</span>
            <span class="n">env</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">envGroup</span><span class="p">,</span>
            <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getLocation</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom deepcopy behavior to prevent duplication of macros and _lumpedFissionProducts.</span>

<span class="sd">        We detach the recursive links to the parent and the reactor to prevent blocks carrying large</span>
<span class="sd">        independent copies of stale reactors in memory. If you make a new block, you must add it to</span>
<span class="sd">        an assembly and a reactor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add self to memo to prevent child objects from duplicating the parent block</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

        <span class="c1"># use __getstate__ and __setstate__ pickle-methods to initialize</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>  <span class="c1"># __getstate__ removes parent</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;macros&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;_lumpedFissionProducts&quot;</span><span class="p">]</span>
        <span class="n">b</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>

        <span class="c1"># assign macros and LFP</span>
        <span class="n">b</span><span class="o">.</span><span class="n">macros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">macros</span>
        <span class="n">b</span><span class="o">.</span><span class="n">_lumpedFissionProducts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lumpedFissionProducts</span>

        <span class="k">return</span> <span class="n">b</span>

<div class="viewcode-block" id="Block.createHomogenizedCopy">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.createHomogenizedCopy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">createHomogenizedCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pinSpatialLocators</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a copy of a block.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Used to implement a copy function for specific block types that can be much faster than a</span>
<span class="sd">        deepcopy by glossing over details that may be unnecessary in certain contexts.</span>

<span class="sd">        This base class implementation is just a deepcopy of the block, in full detail (not</span>
<span class="sd">        homogenized).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.reactors</span><span class="w"> </span><span class="kn">import</span> <span class="n">Core</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAncestor</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Core</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">c</span>

<div class="viewcode-block" id="Block.makeName">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.makeName">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">makeName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemNum</span><span class="p">,</span> <span class="n">axialIndex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a standard block from assembly number.</span>

<span class="sd">        This also sets the block-level assembly-num param.</span>

<span class="sd">        Once, we used a axial-character suffix to represent the axial index, but this is inherently limited so we</span>
<span class="sd">        switched to a numerical name. The axial suffix needs can be brought in to plugins that require them.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; makeName(120, 5)</span>
<span class="sd">        &#39;B0120-005&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span> <span class="o">=</span> <span class="n">assemNum</span>
        <span class="k">return</span> <span class="s2">&quot;B</span><span class="si">{0:04d}</span><span class="s2">-</span><span class="si">{1:03d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">assemNum</span><span class="p">,</span> <span class="n">axialIndex</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.getSmearDensity">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getSmearDensity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getSmearDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the smear density of pins in this block.</span>

<span class="sd">        Smear density is the area of the fuel divided by the area of the space available for fuel inside the cladding.</span>
<span class="sd">        Other space filled with solid materials is not considered available. If all the area is fuel, it has 100% smear</span>
<span class="sd">        density. Lower smear density allows more room for swelling.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        This requires circular fuel and circular cladding. Designs that vary from this will be wrong. It may make sense</span>
<span class="sd">        in the future to put this somewhere a bit more design specific.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This only considers circular objects. If you have a cladding that is not a circle, it will be ignored.</span>

<span class="sd">        Negative areas can exist for void gaps in the fuel pin. A negative area in a gap represents overlap area between</span>
<span class="sd">        two solid components. To account for this additional space within the pin cladding the abs(negativeArea) is</span>
<span class="sd">        added to the inner cladding area.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cold : bool, optional</span>
<span class="sd">            If false, returns the smear density at hot temperatures</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The smear density as a fraction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fuels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fuels</span><span class="p">:</span>
            <span class="c1"># smear density is not computed for non-fuel blocks</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">():</span>
            <span class="c1"># smear density is only defined for pinned blocks</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="n">circles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponentsOfShape</span><span class="p">(</span><span class="n">components</span><span class="o">.</span><span class="n">Circle</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">circles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot get smear density of </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">. There are no circular components.&quot;</span><span class="p">)</span>

        <span class="n">clads</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">circles</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">clads</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot get smear density of </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">. There are no clad components.&quot;</span><span class="p">)</span>

        <span class="c1"># Compute component areas</span>
        <span class="n">innerCladdingArea</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">clad</span> <span class="ow">in</span> <span class="n">clads</span>
        <span class="p">)</span>
        <span class="n">sortedClads</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">clads</span><span class="p">)</span>
        <span class="n">sortedCompsInsideClad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSortedComponentsInsideOfComponent</span><span class="p">(</span><span class="n">sortedClads</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">computeSmearDensity</span><span class="p">(</span><span class="n">innerCladdingArea</span><span class="p">,</span> <span class="n">sortedCompsInsideClad</span><span class="p">,</span> <span class="n">cold</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.computeSmearDensity">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.computeSmearDensity">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">computeSmearDensity</span><span class="p">(</span><span class="n">innerCladdingArea</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sortedCompsInsideClad</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">components</span><span class="o">.</span><span class="n">Component</span><span class="p">],</span> <span class="n">cold</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the smear density for a sorted list of components.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        innerCladdingArea : float</span>
<span class="sd">            Circular area inside the cladding.</span>
<span class="sd">        sortedCompsInsideClad : list</span>
<span class="sd">            A sorted list of Components inside the cladding.</span>
<span class="sd">        cold : bool</span>
<span class="sd">            If false, returns the smear density at hot temperatures</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The smear density as a fraction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fuelComponentArea</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">unmovableComponentArea</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">negativeArea</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sortedCompsInsideClad</span><span class="p">:</span>
            <span class="n">componentArea</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getArea</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isFuel</span><span class="p">():</span>
                <span class="n">fuelComponentArea</span> <span class="o">+=</span> <span class="n">componentArea</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">):</span>
                <span class="c1"># this is another component&#39;s clad; don&#39;t count it towards unmoveable area</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">([</span><span class="n">Flags</span><span class="o">.</span><span class="n">SLUG</span><span class="p">,</span> <span class="n">Flags</span><span class="o">.</span><span class="n">DUMMY</span><span class="p">]):</span>
                <span class="c1"># this flag designates that this clad/slug combination isn&#39;t fuel and shouldn&#39;t be in the average</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">containsSolidMaterial</span><span class="p">():</span>
                    <span class="n">unmovableComponentArea</span> <span class="o">+=</span> <span class="n">componentArea</span>
                <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">containsVoidMaterial</span><span class="p">()</span> <span class="ow">and</span> <span class="n">componentArea</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cold</span><span class="p">:</span>  <span class="c1"># will error out soon</span>
                        <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> with id </span><span class="si">{}</span><span class="s2"> and od </span><span class="si">{}</span><span class="s2"> has negative area at cold dimensions&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">c</span><span class="p">,</span>
                                <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                                <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">negativeArea</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">componentArea</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cold</span> <span class="ow">and</span> <span class="n">negativeArea</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Negative component areas found. Check the cold dimensions are properly aligned and no components &quot;</span>
                <span class="s2">&quot;overlap.&quot;</span>
            <span class="p">)</span>

        <span class="n">innerCladdingArea</span> <span class="o">+=</span> <span class="n">negativeArea</span>  <span class="c1"># See note 2 of self.getSmearDensity</span>
        <span class="n">totalMovableArea</span> <span class="o">=</span> <span class="n">innerCladdingArea</span> <span class="o">-</span> <span class="n">unmovableComponentArea</span>
        <span class="k">if</span> <span class="n">totalMovableArea</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fuelComponentArea</span> <span class="o">/</span> <span class="n">totalMovableArea</span></div>


<div class="viewcode-block" id="Block.autoCreateSpatialGrids">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.autoCreateSpatialGrids">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">autoCreateSpatialGrids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">systemSpatialGrid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a spatialGrid for a Block.</span>

<span class="sd">        Blocks do not always have a spatialGrid from Blueprints, but some Blocks can have their</span>
<span class="sd">        spatialGrids inferred based on the multiplicity of their components. This would add the</span>
<span class="sd">        ability to create a spatialGrid for a Block and give its children the corresponding</span>
<span class="sd">        spatialLocators if certain conditions are met.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        systemSpatialGrid : Grid, optional</span>
<span class="sd">            Spatial Grid of the system-level parent of this Assembly that contains this Block.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the multiplicities of the block are not only 1 or N or if generated ringNumber leads</span>
<span class="sd">            to more positions than necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="n">systemSpatialGrid</span></div>


<div class="viewcode-block" id="Block.assignPinIndices">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.assignPinIndices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assignPinIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="Block.getMgFlux">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getMgFlux">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getMgFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the multigroup neutron flux in [n/cm^2/s].</span>

<span class="sd">        The first entry is the first energy group (fastest neutrons). Each additional</span>
<span class="sd">        group is the next energy group, as set in the ISOTXS library.</span>

<span class="sd">        It is stored integrated over volume on self.p.mgFlux</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adjoint : bool, optional</span>
<span class="sd">            Return adjoint flux instead of real</span>

<span class="sd">        average : bool, optional</span>
<span class="sd">            If true, will return average flux between latest and previous. Doesn&#39;t work</span>
<span class="sd">            for pin detailed yet</span>

<span class="sd">        volume: float, optional</span>
<span class="sd">            If average=True, the volume-integrated flux is divided by volume before being returned.</span>
<span class="sd">            The user may specify a volume, or the function will obtain the block volume directly.</span>

<span class="sd">        gamma : bool, optional</span>
<span class="sd">            Whether to return the neutron flux or the gamma flux.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        flux : multigroup neutron flux in [n/cm^2/s]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">composites</span><span class="o">.</span><span class="n">ArmiObject</span><span class="o">.</span><span class="n">getMgFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="n">adjoint</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">average</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">lastMgFlux</span><span class="p">):</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>
            <span class="n">lastFlux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">lastMgFlux</span> <span class="o">/</span> <span class="n">volume</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="p">(</span><span class="n">flux</span> <span class="o">+</span> <span class="n">lastFlux</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">return</span> <span class="n">flux</span></div>


<div class="viewcode-block" id="Block.setPinMgFluxes">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setPinMgFluxes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setPinMgFluxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fluxes</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the pin-detailed multi-group neutron flux.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fluxes : np.ndarray</span>
<span class="sd">            The block-level pin multigroup fluxes. ``fluxes[i, g]`` represents the flux in group g for</span>
<span class="sd">            pin ``i`` located at ``self.getPinLocations()[i]``. Flux units are the standard n/cm^2/s.</span>
<span class="sd">        adjoint : bool, optional</span>
<span class="sd">            Whether to set real or adjoint data.</span>
<span class="sd">        gamma : bool, optional</span>
<span class="sd">            Whether to set gamma or neutron data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">gamma</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">adjoint</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Adjoint gamma flux is currently unsupported.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinMgFluxesGamma</span> <span class="o">=</span> <span class="n">fluxes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">adjoint</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinMgFluxesAdj</span> <span class="o">=</span> <span class="n">fluxes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinMgFluxes</span> <span class="o">=</span> <span class="n">fluxes</span></div>


<div class="viewcode-block" id="Block.getMicroSuffix">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getMicroSuffix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getMicroSuffix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the microscopic library suffix (e.g. &#39;AB&#39;) for this block.</span>

<span class="sd">        DIF3D and MC2 are limited to 6 character nuclide labels. ARMI by convention uses the first 4</span>
<span class="sd">        for nuclide name (e.g. U235, PU39, etc.) and then uses the 5th character for cross-section</span>
<span class="sd">        type and the 6th for burnup group. This allows a variety of XS sets to be built modeling</span>
<span class="sd">        substantially different blocks.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The single-letter use for xsType and envGroup limit users to 52 groups of each. ARMI will</span>
<span class="sd">        allow 2-letter xsType designations if and only if the `envGroup` setting has length 1 (i.e.</span>
<span class="sd">        no burnup/temp groups are defined). This is useful for high-fidelity XS modeling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">envGroup</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">env</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get MicroXS suffix because </span><span class="si">{0}</span><span class="s2"> in </span><span class="si">{1}</span><span class="s2"> does not have a environment(env) group&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">xsType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">xsType</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xsType</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xsType</span> <span class="o">+</span> <span class="n">env</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">xsType</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">env</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">):</span>
            <span class="c1"># default is &quot;A&quot; so if we got an off default 2 char, there is no way to resolve.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Use of non-default env groups is not allowed with multi-character xs groups!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ignore env group, multi Char XS type to support assigning 2 chars in blueprints</span>
            <span class="k">return</span> <span class="n">xsType</span></div>


<div class="viewcode-block" id="Block.getHeight">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getHeight">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the block height.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">height</span></div>


<div class="viewcode-block" id="Block.setHeight">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setHeight">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modifiedHeight</span><span class="p">,</span> <span class="n">conserveMass</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">adjustList</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a new height of the block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        modifiedHeight : float</span>
<span class="sd">            The height of the block in cm</span>

<span class="sd">        conserveMass : bool, optional</span>
<span class="sd">            Conserve mass of nuclides in ``adjustList``.</span>

<span class="sd">        adjustList : list, optional</span>
<span class="sd">            Nuclides that will be conserved in conserving mass in the block. It is recommended to</span>
<span class="sd">            pass a list of all nuclides in the block.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        There is a coupling between block heights, the parent assembly axial mesh, and the</span>
<span class="sd">        ztop/zbottom/z params of the sibling blocks. When you set a height, all those things are</span>
<span class="sd">        invalidated. Thus, this method has to go through and update them via</span>
<span class="sd">        ``parent.calculateZCoords``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.reactors.Core.updateAxialMesh</span>
<span class="sd">            May need to be called after this.</span>
<span class="sd">        armi.reactor.assemblies.Assembly.calculateZCoords</span>
<span class="sd">            Recalculates z-coords, automatically called by this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">originalHeight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>  <span class="c1"># get before modifying</span>
        <span class="k">if</span> <span class="n">modifiedHeight</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot set height of block </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> to height of </span><span class="si">{</span><span class="n">modifiedHeight</span><span class="si">}</span><span class="s2"> cm&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">modifiedHeight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">conserveMass</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">originalHeight</span> <span class="o">!=</span> <span class="n">modifiedHeight</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">adjustList</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nuclides in ``adjustList`` must be provided to conserve mass.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">adjustDensity</span><span class="p">(</span><span class="n">originalHeight</span> <span class="o">/</span> <span class="n">modifiedHeight</span><span class="p">,</span> <span class="n">adjustList</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">calculateZCoords</span><span class="p">()</span></div>


<div class="viewcode-block" id="Block.getWettedPerimeter">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getWettedPerimeter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getWettedPerimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Block.getFlowAreaPerPin">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getFlowAreaPerPin">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getFlowAreaPerPin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the flowing coolant area of the block in cm^2, normalized to the number of pins in the block.</span>

<span class="sd">        NumPins looks for max number of fuel, clad, control, etc.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.blocks.Block.getNumPins</span>
<span class="sd">            figures out numPins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">COOLANT</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">getArea</span><span class="p">()</span> <span class="o">/</span> <span class="n">numPins</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Block </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> has 0 pins (fuel, clad, control, shield, etc.). Thus, its flow area &quot;</span>
                <span class="s2">&quot;per pin is undefined.&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Block.getHydraulicDiameter">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getHydraulicDiameter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getHydraulicDiameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Block.adjustUEnrich">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.adjustUEnrich">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjustUEnrich</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newEnrich</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust U-235/U-238 mass ratio to a mass enrichment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newEnrich : float</span>
<span class="sd">            New U-235 enrichment in mass fraction</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        completeInitialLoading must be run because adjusting the enrichment actually changes the</span>
<span class="sd">        mass slightly and you can get negative burnups, which you do not want.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fuels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fuels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fuel</span> <span class="ow">in</span> <span class="n">fuels</span><span class="p">:</span>
                <span class="n">fuel</span><span class="o">.</span><span class="n">adjustMassEnrichment</span><span class="p">(</span><span class="n">newEnrich</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no fuel in this block</span>
            <span class="n">tU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensity</span><span class="p">(</span><span class="s2">&quot;U235&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensity</span><span class="p">(</span><span class="s2">&quot;U238&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tU</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setNumberDensity</span><span class="p">(</span><span class="s2">&quot;U235&quot;</span><span class="p">,</span> <span class="n">tU</span> <span class="o">*</span> <span class="n">newEnrich</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setNumberDensity</span><span class="p">(</span><span class="s2">&quot;U238&quot;</span><span class="p">,</span> <span class="n">tU</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">newEnrich</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">completeInitialLoading</span><span class="p">()</span></div>


<div class="viewcode-block" id="Block.getLocation">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getLocation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representation of the location.</span>

<span class="sd">        .. impl:: Location of a block is retrievable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_POSI0</span>
<span class="sd">            :implements: R_ARMI_BLOCK_POSI</span>

<span class="sd">            If the block does not have its ``core`` attribute set, if the block&#39;s parent does not</span>
<span class="sd">            have a ``spatialGrid`` attribute, or if the block does not have its location defined by</span>
<span class="sd">            its ``spatialLocator`` attribute, return a string indicating that it is outside of the</span>
<span class="sd">            core.</span>

<span class="sd">            Otherwise, use the :py:class:`~armi.reactor.grids.Grid.getLabel` static method to</span>
<span class="sd">            convert the block&#39;s indices into a string like &quot;XXX-YYY-ZZZ&quot;. For hexagonal geometry,</span>
<span class="sd">            &quot;XXX&quot; is the zero-padded hexagonal core ring, &quot;YYY&quot; is the zero-padded position in that</span>
<span class="sd">            ring, and &quot;ZZZ&quot; is the zero-padded block axial index from the bottom of the core.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getLabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;ExCore&quot;</span></div>


<div class="viewcode-block" id="Block.coords">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.coords">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinates of the block.</span>

<span class="sd">        .. impl:: Coordinates of a block are queryable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_POSI1</span>
<span class="sd">            :implements: R_ARMI_BLOCK_POSI</span>

<span class="sd">            Calls to the :py:meth:`~armi.reactor.grids.locations.IndexLocation.getGlobalCoordinates`</span>
<span class="sd">            method of the block&#39;s ``spatialLocator`` attribute, which recursively calls itself on</span>
<span class="sd">            all parents of the block to get the coordinates of the block&#39;s centroid in 3D cartesian</span>
<span class="sd">            space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span></div>


<div class="viewcode-block" id="Block.setBuLimitInfo">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setBuLimitInfo">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setBuLimitInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets burnup limit based on igniter, feed, etc.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buRate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># might be cycle 1 or a non-burning block</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">timeToLimit</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">timeLimit</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buLimit</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBu</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buRate</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">residence</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">timeToLimit</span> <span class="o">=</span> <span class="p">(</span><span class="n">timeLimit</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">residence</span><span class="p">)</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">DAYS_PER_YEAR</span></div>


<div class="viewcode-block" id="Block.getMaxArea">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getMaxArea">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getMaxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Block.getArea">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getArea">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getArea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the area of a block for a full core or a 1/3 core model.</span>

<span class="sd">        Area is consistent with the area in the model, so if you have a central assembly in a 1/3</span>
<span class="sd">        symmetric model, this will return 1/3 of the total area of the physical assembly. This way,</span>
<span class="sd">        if you take the sum of the areas in the core (or count the atoms in the core, etc.), you</span>
<span class="sd">        will have the proper number after multiplying by the model symmetry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cold : bool</span>
<span class="sd">            flag to indicate that cold (as input) dimensions are required</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This might not work for a 1/6 core model (due to symmetry line issues).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        area : float (cm^2)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.blocks.Block.getMaxArea</span>
<span class="sd">            return the full area of the physical assembly disregarding model symmetry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this caching requires that you clear the cache every time you adjust anything including</span>
        <span class="c1"># temperature and dimensions.</span>
        <span class="n">area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getCached</span><span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">area</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">area</span>

        <span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">myArea</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getArea</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">+=</span> <span class="n">myArea</span>
        <span class="n">fullArea</span> <span class="o">=</span> <span class="n">a</span>

        <span class="c1"># correct the fullHexArea by the symmetry factor this factor determines if the hex has been</span>
        <span class="c1"># clipped by symmetry lines</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">fullArea</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSymmetryFactor</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_setCache</span><span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">,</span> <span class="n">area</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">area</span></div>


<div class="viewcode-block" id="Block.getVolume">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getVolume">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getVolume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the volume of a block.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        volume : float</span>
<span class="sd">            Block or component volume in cm^3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use symmetryFactor in case the assembly is sitting on a boundary and needs to be cut in half, etc.</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vol</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSymmetryFactor</span><span class="p">()</span></div>


<div class="viewcode-block" id="Block.getSymmetryFactor">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getSymmetryFactor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getSymmetryFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a scaling factor due to symmetry on the area of the block or its components.</span>

<span class="sd">        Takes into account assemblies that are bisected or trisected by symmetry lines</span>

<span class="sd">        In 1/3 symmetric cases, the central assembly is 1/3 a full area. If edge assemblies are</span>
<span class="sd">        included in a model, the symmetry factor along both edges for overhanging assemblies should</span>
<span class="sd">        be 2.0. However, ARMI runs in most scenarios with those assemblies on the 120-edge removed,</span>
<span class="sd">        so the symmetry factor should generally be just 1.0.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.converters.geometryConverter.EdgeAssemblyChanger.scaleParamsRelatedToSymmetry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.0</span></div>


<div class="viewcode-block" id="Block.adjustDensity">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.adjustDensity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">adjustDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">adjustList</span><span class="p">,</span> <span class="n">returnMass</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjusts the total density of each nuclide in adjustList by frac.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frac : float</span>
<span class="sd">            The fraction of the current density that will remain after this operation</span>

<span class="sd">        adjustList : list</span>
<span class="sd">            List of nuclide names that will be adjusted.</span>

<span class="sd">        returnMass : bool</span>
<span class="sd">            If true, will return mass difference.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mass : float</span>
<span class="sd">            Mass difference in grams. If you subtract mass, mass will be negative.</span>
<span class="sd">            If returnMass is False (default), this will always be zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updateDetailedNdens</span><span class="p">(</span><span class="n">frac</span><span class="p">,</span> <span class="n">adjustList</span><span class="p">)</span>

        <span class="n">mass</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">returnMass</span><span class="p">:</span>
            <span class="c1"># do this with a flag to enable faster operation when mass is not needed.</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>

        <span class="n">numDensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNuclideNumberDensities</span><span class="p">(</span><span class="n">adjustList</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nuclideName</span><span class="p">,</span> <span class="n">dens</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">adjustList</span><span class="p">,</span> <span class="n">numDensities</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dens</span><span class="p">:</span>
                <span class="c1"># don&#39;t modify zeros.</span>
                <span class="k">continue</span>
            <span class="n">newDens</span> <span class="o">=</span> <span class="n">dens</span> <span class="o">*</span> <span class="n">frac</span>
            <span class="c1"># add a little so components remember</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setNumberDensity</span><span class="p">(</span><span class="n">nuclideName</span><span class="p">,</span> <span class="n">newDens</span> <span class="o">+</span> <span class="n">TRACE_NUMBER_DENSITY</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">returnMass</span><span class="p">:</span>
                <span class="n">mass</span> <span class="o">+=</span> <span class="n">densityTools</span><span class="o">.</span><span class="n">getMassInGrams</span><span class="p">(</span><span class="n">nuclideName</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">newDens</span> <span class="o">-</span> <span class="n">dens</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mass</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_updateDetailedNdens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">adjustList</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update detailed number density which is used by hi-fi depleters such as ORIGEN.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This will perturb all number densities so it is assumed that if one of the active densities</span>
<span class="sd">        is perturbed, all of htem are perturbed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">detailedNDens</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># BOL assems get expanded to a reference so the first check is needed so it won&#39;t call</span>
            <span class="c1"># .blueprints on None since BOL assems don&#39;t have a core/r</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">nuc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">blueprints</span><span class="o">.</span><span class="n">activeNuclides</span> <span class="k">for</span> <span class="n">nuc</span> <span class="ow">in</span> <span class="n">adjustList</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">detailedNDens</span> <span class="o">*=</span> <span class="n">frac</span>
            <span class="c1"># Other power densities do not need to be updated as they are calculated in the global</span>
            <span class="c1"># flux interface, which occurs after axial expansion on the interface stack.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pdensDecay</span> <span class="o">*=</span> <span class="n">frac</span>

<div class="viewcode-block" id="Block.completeInitialLoading">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.completeInitialLoading">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">completeInitialLoading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bolBlock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does some BOL bookkeeping to track things like BOL HM density for burnup tracking.</span>

<span class="sd">        This should run after this block is loaded up at BOC (called from Reactor.initialLoading).</span>

<span class="sd">        The original purpose of this was to get the moles HM at BOC for the moles Pu/moles HM at BOL</span>
<span class="sd">        calculation.</span>

<span class="sd">        This also must be called after modifying something like the smear density or zr fraction in</span>
<span class="sd">        an optimization case. In ECPT cases, a BOL block must be passed or else the burnup will try</span>
<span class="sd">        to get based on a pre-burned value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bolBlock : Block, optional</span>
<span class="sd">            A BOL-state block of this block type, required for perturbed equilibrium cases.</span>
<span class="sd">            Must have the same enrichment as this block!</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hmDens : float</span>
<span class="sd">            The heavy metal number density of this block.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Reactor.importGeom</span>
<span class="sd">        depletion._updateBlockParametersAfterDepletion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bolBlock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bolBlock</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">hmDens</span> <span class="o">=</span> <span class="n">bolBlock</span><span class="o">.</span><span class="n">getHMDens</span><span class="p">()</span>  <span class="c1"># total homogenized heavy metal number density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">nHMAtBOL</span> <span class="o">=</span> <span class="n">hmDens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHMMoles</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">puFrac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPuMoles</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOL</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOL</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="mf">0.0</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># non-pinned reactors (or ones without cladding) will not use smear density</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">smearDensity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSmearDensity</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">enrichmentBOL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFissileMassEnrich</span><span class="p">()</span>
        <span class="n">massHmBOL</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">hmMass</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">getHMMass</span><span class="p">()</span>
            <span class="n">massHmBOL</span> <span class="o">+=</span> <span class="n">hmMass</span>
            <span class="c1"># Components have the following parameters but not every composite will massHmBOL,</span>
            <span class="c1"># molesHmBOL, puFrac, enrichmentBOL</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">components</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
                <span class="n">child</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">massHmBOL</span> <span class="o">=</span> <span class="n">hmMass</span>
                <span class="n">child</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOL</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">getHMMoles</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOL</span><span class="p">:</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">enrichmentBOL</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">getFissileMassEnrich</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">massHmBOL</span> <span class="o">=</span> <span class="n">massHmBOL</span>

        <span class="k">return</span> <span class="n">hmDens</span></div>


<div class="viewcode-block" id="Block.setB10VolParam">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setB10VolParam">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setB10VolParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heightHot</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the b.p.initialB10ComponentVol param according to the volume of boron-10 containing components.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        heightHot : Boolean</span>
<span class="sd">            True if self.height() is cold height</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># exclude fuel components since they could have slight B10 impurity and</span>
        <span class="c1"># this metric is not relevant for fuel.</span>
        <span class="n">b10Comps</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">getNumberDensity</span><span class="p">(</span><span class="s2">&quot;B10&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">isFuel</span><span class="p">()]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">b10Comps</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># get the highest density comp dont want to sum all because some comps might have very small</span>
        <span class="c1"># impurities of boron and adding this volume won&#39;t be conservative for captures per cc.</span>
        <span class="n">b10Comp</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">b10Comps</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">getNumberDensity</span><span class="p">(</span><span class="s2">&quot;B10&quot;</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b10Comps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;More than one boron10-containing component found in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">. Only </span><span class="si">{</span><span class="n">b10Comp</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;will be considered for calculation of initialB10ComponentVol Since adding &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;multiple volumes is not conservative for captures. All compos found </span><span class="si">{</span><span class="n">b10Comps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isFuel</span><span class="p">():</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> has both fuel and initial b10. b10 volume may not be conserved with axial expansion.&quot;</span><span class="p">,</span>
                <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># calc volume of boron components</span>
        <span class="n">coldArea</span> <span class="o">=</span> <span class="n">b10Comp</span><span class="o">.</span><span class="n">getArea</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">coldFactor</span> <span class="o">=</span> <span class="n">b10Comp</span><span class="o">.</span><span class="n">getThermalExpansionFactor</span><span class="p">()</span> <span class="k">if</span> <span class="n">heightHot</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">coldHeight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span> <span class="o">/</span> <span class="n">coldFactor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">initialB10ComponentVol</span> <span class="o">=</span> <span class="n">coldArea</span> <span class="o">*</span> <span class="n">coldHeight</span></div>


<div class="viewcode-block" id="Block.replaceBlockWithBlock">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.replaceBlockWithBlock">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">replaceBlockWithBlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bReplacement</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace the current block with the replacementBlock.</span>

<span class="sd">        Typically used in the insertion of control rods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paramsToSkip</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="o">.</span><span class="n">inCategory</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">Category</span><span class="o">.</span><span class="n">retainOnReplacement</span><span class="p">)</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

        <span class="n">tempBlock</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">bReplacement</span><span class="p">)</span>
        <span class="n">oldParams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">newParams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">tempBlock</span><span class="o">.</span><span class="n">p</span>
        <span class="k">for</span> <span class="n">paramName</span> <span class="ow">in</span> <span class="n">paramsToSkip</span><span class="p">:</span>
            <span class="n">newParams</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldParams</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span>

        <span class="c1"># update synchronization information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assigned</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span>
        <span class="n">paramDefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span>
        <span class="k">for</span> <span class="n">paramName</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">newParams</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="n">paramsToSkip</span><span class="p">:</span>
            <span class="n">paramDefs</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span><span class="o">.</span><span class="n">assigned</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span>

        <span class="n">newComponents</span> <span class="o">=</span> <span class="n">tempBlock</span><span class="o">.</span><span class="n">getChildren</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setChildren</span><span class="p">(</span><span class="n">newComponents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span></div>


<div class="viewcode-block" id="Block.plotFlux">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.plotFlux">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plotFlux</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="n">fName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bList2</span><span class="o">=</span><span class="p">[]):</span>
        <span class="c1"># Block.plotFlux has been moved to utils.plotting as plotBlockFlux, which is a better fit.</span>
        <span class="c1"># We don&#39;t want to remove the plotFlux function in the Block namespace yet in case client</span>
        <span class="c1"># code is depending on this function existing here. This is just a simple pass-through</span>
        <span class="c1"># function that passes the arguments along to the actual implementation in its new location.</span>
        <span class="n">plotBlockFlux</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="n">fName</span><span class="p">,</span> <span class="n">bList</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">adjoint</span><span class="p">,</span> <span class="n">bList2</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_updatePitchComponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the component that defines the pitch.</span>

<span class="sd">        Given a Component, compare it to the current component that defines the pitch of the Block.</span>
<span class="sd">        If bigger, replace it. We need different implementations of this to support different logic</span>
<span class="sd">        for determining the form of pitch and the concept of &quot;larger&quot;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        CartesianBlock._updatePitchComponent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Some block types don&#39;t have a clearly defined pitch (e.g. ThRZ)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">PITCH_COMPONENT_TYPE</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PITCH_COMPONENT_TYPE</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">componentPitch</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PITCH_DIMENSION</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">parameters</span><span class="o">.</span><span class="n">UnknownParameterError</span><span class="p">:</span>
            <span class="c1"># some components dont have the appropriate parameter</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">componentPitch</span> <span class="ow">and</span> <span class="p">(</span><span class="n">componentPitch</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">componentPitch</span><span class="p">)</span>

<div class="viewcode-block" id="Block.add">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">derivedMustUpdate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBuByPin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBuByPin</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mult</span><span class="p">:</span>
                <span class="c1"># this may be a little wasteful, but we can fix it later...</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBuByPin</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mult</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># maybe adding a Composite of components rather than a single</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updatePitchComponent</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.removeAll">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.removeAll">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">removeAll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recomputeAreaFractions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">recomputeAreaFractions</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">recomputeAreaFractions</span><span class="p">:</span>  <span class="c1"># only do this once</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeFractions</span><span class="p">()</span></div>


<div class="viewcode-block" id="Block.remove">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.remove">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">recomputeAreaFractions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLargestComponent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PITCH_DIMENSION</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_updatePitchComponent</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">recomputeAreaFractions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeFractions</span><span class="p">()</span></div>


<div class="viewcode-block" id="Block.getComponentsThatAreLinkedTo">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getComponentsThatAreLinkedTo">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getComponentsThatAreLinkedTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine which dimensions of which components are linked to a specific dimension of a</span>
<span class="sd">        particular component.</span>

<span class="sd">        Useful for breaking fuel components up into individuals and making sure anything that was</span>
<span class="sd">        linked to the fuel mult (like the cladding mult) stays correct.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        comp : Component</span>
<span class="sd">            The component that the results are linked to</span>
<span class="sd">        dim : str</span>
<span class="sd">            The name of the dimension that the results are linked to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        linkedComps : list</span>
<span class="sd">            A list of (components,dimName) that are linked to this component, dim.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">linked</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">dimName</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">dimensionIsLinked</span><span class="p">(</span><span class="n">dimName</span><span class="p">):</span>
                    <span class="n">requiredComponent</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">requiredComponent</span> <span class="ow">is</span> <span class="n">comp</span> <span class="ow">and</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="n">linked</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">dimName</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">linked</span></div>


<div class="viewcode-block" id="Block.getComponentsInLinkedOrder">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getComponentsInLinkedOrder">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getComponentsInLinkedOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">componentList</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of the components in order of their linked-dimension dependencies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        components : list, optional</span>
<span class="sd">            A list of components to consider. If None, this block&#39;s components will be used.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This means that components other components are linked to come first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">componentList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">componentList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">()</span>
        <span class="n">cList</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">componentList</span><span class="p">)</span>
        <span class="n">orderedComponents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Loop through the components until there are none left.</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">cList</span><span class="p">:</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">cList</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>  <span class="c1"># take first item in list</span>
            <span class="n">cleared</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># innocent until proven guilty</span>
            <span class="c1"># loop through all dimensions in this component to determine its dependencies</span>
            <span class="k">for</span> <span class="n">dimName</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">candidate</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">candidate</span><span class="o">.</span><span class="n">dimensionIsLinked</span><span class="p">(</span><span class="n">dimName</span><span class="p">):</span>
                    <span class="c1"># In linked dimensions, val = (component, dimName)</span>
                    <span class="n">requiredComponent</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">requiredComponent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">orderedComponents</span><span class="p">:</span>
                        <span class="c1"># this component depends on one that is not in the ordered list yet.</span>
                        <span class="c1"># do not add it.</span>
                        <span class="n">cleared</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>  <span class="c1"># short circuit. One failed lookup is enough to flag this component as dirty.</span>
            <span class="k">if</span> <span class="n">cleared</span><span class="p">:</span>
                <span class="c1"># this candidate is free of dependencies and is ready to be added.</span>
                <span class="n">orderedComponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">counter</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">cList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;The component </span><span class="si">{0}</span><span class="s2"> in </span><span class="si">{1}</span><span class="s2"> contains a dimension that is linked to another component, &quot;</span>
                    <span class="s2">&quot; but the required component is not present in the block. They may also be other dependency fails. &quot;</span>
                    <span class="s2">&quot;The component dims are </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">,</span> <span class="n">cList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot locate linked component.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orderedComponents</span></div>


<div class="viewcode-block" id="Block.getSortedComponentsInsideOfComponent">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getSortedComponentsInsideOfComponent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getSortedComponentsInsideOfComponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of components inside of the given component sorted from innermost to outermost.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        component : object</span>
<span class="sd">            Component to look inside of.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you just want sorted components in this block, use ``sorted(self)``. This will never</span>
<span class="sd">        include any ``DerivedShape`` objects. Since they have a derived area they don&#39;t have a well-</span>
<span class="sd">        defined dimension. For now we just ignore them. If they are desired in the future some</span>
<span class="sd">        knowledge of their dimension will be required while they are being derived.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sortedComponents</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">componentIndex</span> <span class="o">=</span> <span class="n">sortedComponents</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
        <span class="n">sortedComponents</span> <span class="o">=</span> <span class="n">sortedComponents</span><span class="p">[:</span><span class="n">componentIndex</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sortedComponents</span></div>


<div class="viewcode-block" id="Block.getNumPins">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getNumPins">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getNumPins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of pins in this block.</span>

<span class="sd">        .. impl:: Get the number of pins in a block.</span>
<span class="sd">            :id: I_ARMI_BLOCK_NPINS</span>
<span class="sd">            :implements: R_ARMI_BLOCK_NPINS</span>

<span class="sd">            Uses some simple criteria to infer the number of pins in the block.</span>

<span class="sd">            For every flag in the module list :py:data:`~armi.reactor.blocks.PIN_COMPONENTS`, loop</span>
<span class="sd">            over all components of that type in the block. If the component is an instance of</span>
<span class="sd">            :py:class:`~armi.reactor.components.basicShapes.Circle`, add its multiplicity to a list,</span>
<span class="sd">            and sum that list over all components with each given flag.</span>

<span class="sd">            After looping over all possibilities, return the maximum value returned from the process</span>
<span class="sd">            above, or if no compatible components were found, return zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nPins</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">sum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">))</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">basicShapes</span><span class="o">.</span><span class="n">Circle</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">(</span><span class="n">compType</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">compType</span> <span class="ow">in</span> <span class="n">PIN_COMPONENTS</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">nPins</span> <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="n">nPins</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.mergeWithBlock">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.mergeWithBlock">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mergeWithBlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">otherBlock</span><span class="p">,</span> <span class="n">fraction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turns this block into a mixture of this block and some other block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        otherBlock : Block</span>
<span class="sd">            The block to mix this block with. The other block will not be modified.</span>

<span class="sd">        fraction : float</span>
<span class="sd">            Fraction of the other block to mix in with this block. If 0.1 is passed in, this block</span>
<span class="sd">            will become 90% what it originally was and 10% what the other block is.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This merges on a high level (using number densities). Components will not be merged.</span>

<span class="sd">        This is used e.g. for inserting a control block partially to get a very tight criticality</span>
<span class="sd">        control. In this case, a control block would be merged with a duct block. It is also used</span>
<span class="sd">        when a control rod is specified as a certain length but that length does not fit exactly</span>
<span class="sd">        into a full block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numDensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">()</span>
        <span class="n">otherBlockDensities</span> <span class="o">=</span> <span class="n">otherBlock</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">()</span>
        <span class="n">newDensities</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Make sure to hit all nuclides in union of blocks</span>
        <span class="k">for</span> <span class="n">nucName</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">numDensities</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">otherBlockDensities</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">newDensities</span><span class="p">[</span><span class="n">nucName</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">fraction</span><span class="p">)</span> <span class="o">*</span> <span class="n">numDensities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">nucName</span><span class="p">,</span> <span class="mf">0.0</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">fraction</span> <span class="o">*</span> <span class="n">otherBlockDensities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">nucName</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setNumberDensities</span><span class="p">(</span><span class="n">newDensities</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.getComponentAreaFrac">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getComponentAreaFrac">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getComponentAreaFrac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the area fraction of the specified component(s) among all components in the block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or list of Flags</span>
<span class="sd">            Component types to look up</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; b.getComponentAreaFrac(Flags.CLAD)</span>
<span class="sd">        0.15</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The area fraction of the component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tFrac</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeFractions</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">tFrac</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tFrac</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No component </span><span class="si">{</span><span class="n">typeSpec</span><span class="si">}</span><span class="s2"> exists on </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">, so area fraction is zero.&quot;</span><span class="p">,</span>
                <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">typeSpec</span><span class="si">}</span><span class="s2"> areaFrac is zero&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="Block.verifyBlockDims">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.verifyBlockDims">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">verifyBlockDims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Optional dimension checking.&quot;&quot;&quot;</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="Block.getDim">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getDim">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getDim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">dimName</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search through blocks in this assembly and find the first component of compName.</span>
<span class="sd">        Then, look on that component for dimName.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or list of Flags</span>
<span class="sd">            Component name, e.g. Flags.FUEL, Flags.CLAD, Flags.COOLANT, ...</span>
<span class="sd">        dimName : str</span>
<span class="sd">            Dimension name, e.g. &#39;od&#39;, ...</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dimVal : float</span>
<span class="sd">            The dimension in cm.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; getDim(Flags.WIRE,&#39;od&#39;)</span>
<span class="sd">        0.01</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="n">dimName</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot get Dimension because Flag not found: </span><span class="si">{</span><span class="n">typeSpec</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.getPinCenterFlatToFlat">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPinCenterFlatToFlat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getPinCenterFlatToFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the flat-to-flat distance between the centers of opposing pins in the outermost ring.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>  <span class="c1"># no geometry can be assumed</span></div>


<div class="viewcode-block" id="Block.getWireWrapCladGap">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getWireWrapCladGap">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getWireWrapCladGap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the gap between the wire wrap and the clad.&quot;&quot;&quot;</span>
        <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="n">wire</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span>
        <span class="n">wireOuterRadius</span> <span class="o">=</span> <span class="n">wire</span><span class="o">.</span><span class="n">getBoundingCircleOuterDiameter</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">wireInnerRadius</span> <span class="o">=</span> <span class="n">wireOuterRadius</span> <span class="o">-</span> <span class="n">wire</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="n">cladOuterRadius</span> <span class="o">=</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">return</span> <span class="n">wireInnerRadius</span> <span class="o">-</span> <span class="n">cladOuterRadius</span></div>


<div class="viewcode-block" id="Block.getPlenumPin">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPlenumPin">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getPlenumPin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the plenum pin if it exists.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">GAP</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isPlenumPin</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">c</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Block.isPlenumPin">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.isPlenumPin">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">isPlenumPin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if the specified component is a plenum pin.&quot;&quot;&quot;</span>
        <span class="c1"># This assumes that anything with the GAP flag will have a valid &#39;id&#39; dimension.</span>
        <span class="n">cIsCenterGapGap</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">components</span><span class="o">.</span><span class="n">Component</span><span class="p">)</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">GAP</span><span class="p">)</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">([</span><span class="n">Flags</span><span class="o">.</span><span class="n">PLENUM</span><span class="p">,</span> <span class="n">Flags</span><span class="o">.</span><span class="n">ACLP</span><span class="p">])</span> <span class="ow">and</span> <span class="n">cIsCenterGapGap</span></div>


<div class="viewcode-block" id="Block.getPitch">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPitch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">returnComp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the center-to-center hex pitch of this block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        returnComp : bool, optional</span>
<span class="sd">            If true, will return the component that has the maximum pitch as well</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pitch : float or None</span>
<span class="sd">            Hex pitch in cm, if well-defined. If there is no clear component for determining pitch, returns None</span>
<span class="sd">        component : Component or None</span>
<span class="sd">            Component that has the max pitch, if returnComp == True. If no component is found to define the pitch,</span>
<span class="sd">            returns None.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The block stores a reference to the component that defines the pitch, making the assumption that while the</span>
<span class="sd">        dimensions can change, the component containing the largest dimension will not. This lets us skip the search for</span>
<span class="sd">        largest component. We still need to ask the largest component for its current dimension in case its temperature</span>
<span class="sd">        changed, or was otherwise modified.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        setPitch : sets pitch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> has no valid pitch defining component&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># ask component for dimensions, since they could have changed due to temperature</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getPitchData</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="n">returnComp</span> <span class="k">else</span> <span class="n">p</span></div>


<div class="viewcode-block" id="Block.hasPinPitch">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.hasPinPitch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">hasPinPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if the block has enough information to calculate pin pitch.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Block.getPinPitch">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPinPitch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getPinPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return sub-block pitch in blocks.</span>

<span class="sd">        This assumes the spatial grid is defined by unit steps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">pitch</span></div>


<div class="viewcode-block" id="Block.getDimensions">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getDimensions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return dimensional values of the specified dimension.&quot;&quot;&quot;</span>
        <span class="n">dimVals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dimVal</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">parameters</span><span class="o">.</span><span class="n">ParameterError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">dimVal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dimVals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dimVal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dimVals</span></div>


<div class="viewcode-block" id="Block.getLargestComponent">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getLargestComponent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getLargestComponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the component with the largest dimension of the specified type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dimension: str</span>
<span class="sd">            The name of the dimension to find the largest component of.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        largestComponent: armi.reactor.components.Component</span>
<span class="sd">            The component with the largest dimension of the specified type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">maxDim</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">largestComponent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dimVal</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">parameters</span><span class="o">.</span><span class="n">ParameterError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">dimVal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dimVal</span> <span class="o">&gt;</span> <span class="n">maxDim</span><span class="p">:</span>
                <span class="n">maxDim</span> <span class="o">=</span> <span class="n">dimVal</span>
                <span class="n">largestComponent</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">return</span> <span class="n">largestComponent</span></div>


<div class="viewcode-block" id="Block.setPitch">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setPitch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">updateBolParams</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets outer pitch to some new value.</span>

<span class="sd">        This sets the settingPitch and actually sets the dimension of the outer hexagon.</span>

<span class="sd">        During a load (importGeom), the setDimension doesn&#39;t usually do anything except set the</span>
<span class="sd">        setting See Issue 034</span>

<span class="sd">        But during a actual case modification (e.g. in an optimization sweep, then the dimension has</span>
<span class="sd">        to be set as well.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getPitch : gets the pitch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">setDimension</span><span class="p">(</span><span class="s2">&quot;op&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No pitch-defining component on block </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">updateBolParams</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">completeInitialLoading</span><span class="p">()</span></div>


<div class="viewcode-block" id="Block.getMfp">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getMfp">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getMfp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the mean free path for neutron or gammas in this block.</span>

<span class="sd">        .. math::</span>

<span class="sd">            &lt;\Sigma&gt; = \frac{\sum_E(\phi_e \Sigma_e dE)}{\sum_E (\phi_e dE)}  =</span>
<span class="sd">            \frac{\sum_E(\phi_e N \sum_{\text{type}}(\sigma_e)  dE}{\sum_E (\phi_e dE))}</span>

<span class="sd">        Block macro is the sum of macros of all nuclides.</span>

<span class="sd">        phi_g = flux*dE already in multigroup method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mfp, mfpAbs, diffusionLength : tuple(float, float float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMgFlux</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">flux</span><span class="p">]</span>
        <span class="n">mfpNumerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>
        <span class="n">absMfpNumerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>
        <span class="n">transportNumerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>

        <span class="n">numDensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">nucName</span><span class="p">,</span> <span class="n">nDen</span> <span class="ow">in</span> <span class="n">numDensities</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">nucMc</span> <span class="o">=</span> <span class="n">nuclideBases</span><span class="o">.</span><span class="n">byName</span><span class="p">[</span><span class="n">nucName</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">gamma</span><span class="p">:</span>
                <span class="n">micros</span> <span class="o">=</span> <span class="n">lib</span><span class="p">[</span><span class="n">nucMc</span><span class="p">]</span><span class="o">.</span><span class="n">gammaXS</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">micros</span> <span class="o">=</span> <span class="n">lib</span><span class="p">[</span><span class="n">nucMc</span><span class="p">]</span><span class="o">.</span><span class="n">micros</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">micros</span><span class="o">.</span><span class="n">total</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># 0th order</span>
            <span class="n">transport</span> <span class="o">=</span> <span class="n">micros</span><span class="o">.</span><span class="n">transport</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># 0th order, [bn]</span>
            <span class="n">absorb</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">micros</span><span class="o">.</span><span class="n">getAbsorptionXS</span><span class="p">())</span>
            <span class="n">mfpNumerator</span> <span class="o">+=</span> <span class="n">nDen</span> <span class="o">*</span> <span class="n">total</span>  <span class="c1"># [cm]</span>
            <span class="n">absMfpNumerator</span> <span class="o">+=</span> <span class="n">nDen</span> <span class="o">*</span> <span class="n">absorb</span>
            <span class="n">transportNumerator</span> <span class="o">+=</span> <span class="n">nDen</span> <span class="o">*</span> <span class="n">transport</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
        <span class="n">mfp</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">mfpNumerator</span> <span class="o">*</span> <span class="n">flux</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span><span class="p">)</span>
        <span class="n">sigmaA</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">absMfpNumerator</span> <span class="o">*</span> <span class="n">flux</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="n">sigmaTr</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">transportNumerator</span> <span class="o">*</span> <span class="n">flux</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="n">diffusionCoeff</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">sigmaTr</span><span class="p">)</span>
        <span class="n">mfpAbs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sigmaA</span>
        <span class="n">diffusionLength</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diffusionCoeff</span> <span class="o">/</span> <span class="n">sigmaA</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mfp</span><span class="p">,</span> <span class="n">mfpAbs</span><span class="p">,</span> <span class="n">diffusionLength</span></div>


<div class="viewcode-block" id="Block.setAreaFractionsReport">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setAreaFractionsReport">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setAreaFractionsReport</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">frac</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeFractions</span><span class="p">():</span>
            <span class="n">report</span><span class="o">.</span><span class="n">setData</span><span class="p">(</span>
                <span class="n">c</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span>
                <span class="p">[</span><span class="s2">&quot;</span><span class="si">{0:10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getArea</span><span class="p">()),</span> <span class="s2">&quot;</span><span class="si">{0:10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">frac</span><span class="p">)],</span>
                <span class="n">report</span><span class="o">.</span><span class="n">BLOCK_AREA_FRACS</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># return the group the information went to</span>
        <span class="k">return</span> <span class="n">report</span><span class="o">.</span><span class="n">ALL</span><span class="p">[</span><span class="n">report</span><span class="o">.</span><span class="n">BLOCK_AREA_FRACS</span><span class="p">]</span></div>


<div class="viewcode-block" id="Block.getBlocks">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getBlocks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getBlocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns all the block(s) included in this block its implemented so that methods</span>
<span class="sd">        could iterate over reactors, assemblies or single blocks without checking to see what the</span>
<span class="sd">        type of the reactor-family object is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span></div>


<div class="viewcode-block" id="Block.updateComponentDims">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.updateComponentDims">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">updateComponentDims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method updates all the dimensions of the components.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is VERY useful for defining a ThRZ core out of differentialRadialSegements whose</span>
<span class="sd">        dimensions are connected together some of these dimensions are derivative and can be updated</span>
<span class="sd">        by changing dimensions in a Parameter Component or other linked components</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.components.DifferentialRadialSegment.updateDims</span>
<span class="sd">        armi.reactor.components.Parameters</span>
<span class="sd">        armi.physics.optimize.OptimizationInterface.modifyCase (look up &#39;ThRZReflectorThickness&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponentsInLinkedOrder</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">updateDims</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> has no updatedDims method -- skipping&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">))</span></div>


<div class="viewcode-block" id="Block.getIntegratedMgFlux">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getIntegratedMgFlux">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getIntegratedMgFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the volume integrated multigroup neutron tracklength in [n-cm/s].</span>

<span class="sd">        The first entry is the first energy group (fastest neutrons). Each additional group is the</span>
<span class="sd">        next energy group, as set in the ISOTXS library.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adjoint : bool, optional</span>
<span class="sd">            Return adjoint flux instead of real</span>

<span class="sd">        gamma : bool, optional</span>
<span class="sd">            Whether to return the neutron flux or the gamma flux.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        integratedFlux : np.ndarray</span>
<span class="sd">            multigroup neutron tracklength in [n-cm/s]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">adjoint</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gamma</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Adjoint gamma flux is currently unsupported.&quot;</span><span class="p">)</span>
            <span class="n">integratedFlux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">adjMgFlux</span>
        <span class="k">elif</span> <span class="n">gamma</span><span class="p">:</span>
            <span class="n">integratedFlux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFluxGamma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">integratedFlux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">integratedFlux</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.getLumpedFissionProductCollection">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getLumpedFissionProductCollection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getLumpedFissionProductCollection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get collection of LFP objects. Will work for global or block-level LFP models.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lfps : LumpedFissionProduct</span>
<span class="sd">            lfpName keys , lfp object values</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.physics.neutronics.fissionProductModel.lumpedFissionProduct.LumpedFissionProduct : LFP object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">composites</span><span class="o">.</span><span class="n">ArmiObject</span><span class="o">.</span><span class="n">getLumpedFissionProductCollection</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.rotate">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.rotate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rad</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function for rotating a block&#39;s spatially varying variables by a specified angle (radians).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rad: float</span>
<span class="sd">            Number (in radians) specifying the angle of counter clockwise rotation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Block.setAxialExpTargetComp">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setAxialExpTargetComp">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setAxialExpTargetComp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targetComponent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the targetComponent for the axial expansion changer.</span>

<span class="sd">        .. impl:: Set the target axial expansion components on a given block.</span>
<span class="sd">            :id: I_ARMI_MANUAL_TARG_COMP</span>
<span class="sd">            :implements: R_ARMI_MANUAL_TARG_COMP</span>

<span class="sd">            Sets the ``axialExpTargetComponent`` parameter on the block to the name of the Component</span>
<span class="sd">            which is passed in. This is then used by the</span>
<span class="sd">            :py:class:`~armi.reactor.converters.axialExpansionChanger.AxialExpansionChanger`</span>
<span class="sd">            class during axial expansion.</span>

<span class="sd">            This method is typically called from within</span>
<span class="sd">            :py:meth:`~armi.reactor.blueprints.blockBlueprint.BlockBlueprint.construct` during the</span>
<span class="sd">            process of building a Block from the blueprints.</span>

<span class="sd">        Parameter</span>
<span class="sd">        ---------</span>
<span class="sd">        targetComponent: :py:class:`Component &lt;armi.reactor.components.component.Component&gt;` object</span>
<span class="sd">            Component specified to be target component for axial expansion changer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axialExpTargetComponent</span> <span class="o">=</span> <span class="n">targetComponent</span><span class="o">.</span><span class="n">name</span></div>


<div class="viewcode-block" id="Block.getPinLocations">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPinLocations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getPinLocations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">grids</span><span class="o">.</span><span class="n">IndexLocation</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Produce all the index locations for pins in the block.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list[grids.IndexLocation]</span>
<span class="sd">            Integer locations where pins can be found in the block.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Only components with ``Flags.CLAD`` are considered to define a pin&#39;s location.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`getPinCoordinates` - companion for this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">clad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterChildrenWithFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">,</span> <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span><span class="p">):</span>
                <span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">items</span></div>


<div class="viewcode-block" id="Block.getPinCoordinates">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPinCoordinates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getPinCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the local centroid coordinates of any pins in this block.</span>

<span class="sd">        The pins must have a CLAD-flagged component for this to work.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        localCoords : numpy.ndarray</span>
<span class="sd">            ``(N, 3)`` array of coordinates for pins locations. ``localCoords[i]`` contains a triplet of</span>
<span class="sd">            the x, y, z location for pin ``i``. Ordered according to how they are listed as children</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`getPinLocations` - companion for this method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinLocations</span><span class="p">()</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">location</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">()</span> <span class="k">for</span> <span class="n">location</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.getTotalEnergyGenerationConstants">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getTotalEnergyGenerationConstants">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getTotalEnergyGenerationConstants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the total energy generation group constants for a block.</span>

<span class="sd">        Gives the total energy generation rates when multiplied by the multigroup flux.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        totalEnergyGenConstant: np.ndarray</span>
<span class="sd">            Total (fission + capture) energy generation group constants (Joules/cm)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFissionEnergyGenerationConstants</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCaptureEnergyGenerationConstants</span><span class="p">()</span></div>


<div class="viewcode-block" id="Block.getFissionEnergyGenerationConstants">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getFissionEnergyGenerationConstants">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getFissionEnergyGenerationConstants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the fission energy generation group constants for a block.</span>

<span class="sd">        Gives the fission energy generation rates when multiplied by the multigroup flux.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fissionEnergyGenConstant: np.ndarray</span>
<span class="sd">            Energy generation group constants (Joules/cm)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError:</span>
<span class="sd">            Reports if a cross section library is not assigned to a reactor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot compute energy generation group constants without a library. Please ensure a library exists.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">xsCollections</span><span class="o">.</span><span class="n">computeFissionEnergyGenerationConstants</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Block.getCaptureEnergyGenerationConstants">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getCaptureEnergyGenerationConstants">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getCaptureEnergyGenerationConstants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the capture energy generation group constants for a block.</span>

<span class="sd">        Gives the capture energy generation rates when multiplied by the multigroup flux.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fissionEnergyGenConstant: np.ndarray</span>
<span class="sd">            Energy generation group constants (Joules/cm)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError:</span>
<span class="sd">            Reports if a cross section library is not assigned to a reactor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot compute energy generation group constants without a library. Please ensure a library exists.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">xsCollections</span><span class="o">.</span><span class="n">computeCaptureEnergyGenerationConstants</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Block.getNeutronEnergyDepositionConstants">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getNeutronEnergyDepositionConstants">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getNeutronEnergyDepositionConstants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the neutron energy deposition group constants for a block.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        energyDepConstants: np.ndarray</span>
<span class="sd">            Neutron energy generation group constants (in Joules/cm)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError:</span>
<span class="sd">            Reports if a cross section library is not assigned to a reactor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get neutron energy deposition group constants without &quot;</span>
                <span class="s2">&quot;a library. Please ensure a library exists.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">xsCollections</span><span class="o">.</span><span class="n">computeNeutronEnergyDepositionConstants</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Block.getGammaEnergyDepositionConstants">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getGammaEnergyDepositionConstants">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getGammaEnergyDepositionConstants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the gamma energy deposition group constants for a block.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        energyDepConstants: np.ndarray</span>
<span class="sd">            Energy generation group constants (in Joules/cm)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError:</span>
<span class="sd">            Reports if a cross section library is not assigned to a reactor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get gamma energy deposition group constants without a library. Please ensure a library exists.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">xsCollections</span><span class="o">.</span><span class="n">computeGammaEnergyDepositionConstants</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Block.getBoronMassEnrich">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getBoronMassEnrich">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getBoronMassEnrich</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return B-10 mass fraction.&quot;&quot;&quot;</span>
        <span class="n">b10</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s2">&quot;B10&quot;</span><span class="p">)</span>
        <span class="n">b11</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s2">&quot;B11&quot;</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">b11</span> <span class="o">+</span> <span class="n">b10</span>
        <span class="k">if</span> <span class="n">total</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">b10</span> <span class="o">/</span> <span class="n">total</span></div>


<div class="viewcode-block" id="Block.getUraniumMassEnrich">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getUraniumMassEnrich">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getUraniumMassEnrich</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns fissile mass fraction of uranium.&quot;&quot;&quot;</span>
        <span class="n">totalU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">totalU</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="n">fissileU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMass</span><span class="p">([</span><span class="s2">&quot;U233&quot;</span><span class="p">,</span> <span class="s2">&quot;U235&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fissileU</span> <span class="o">/</span> <span class="n">totalU</span></div>


<div class="viewcode-block" id="Block.getInputHeight">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getInputHeight">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getInputHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine the input height from blueprints.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Height for this block pulled from the blueprints.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If no ancestor of this block contains the input blueprints. Blueprints are usually</span>
<span class="sd">            stored on the reactor object, which is typically an ancestor of the block</span>
<span class="sd">            (block -&gt; assembly -&gt; core -&gt; reactor). However, this may be the case when creating</span>
<span class="sd">            blocks from scratch in testing where the entire composite tree may not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ancestorWithBp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAncestor</span><span class="p">(</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;blueprints&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ancestorWithBp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">ancestorWithBp</span><span class="o">.</span><span class="n">blueprints</span>
            <span class="n">assemDesign</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">assemDesigns</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">getType</span><span class="p">()]</span>
            <span class="n">heights</span> <span class="o">=</span> <span class="n">assemDesign</span><span class="o">.</span><span class="n">height</span>
            <span class="n">myIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">heights</span><span class="p">[</span><span class="n">myIndex</span><span class="p">]</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No ancestor of </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> has blueprints&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Block.sort">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.sort">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sort the children on this block.</span>

<span class="sd">        If there is a spatial grid, the previous pin indices on the components</span>
<span class="sd">        is now invalid because the ordering of :meth:`getPinLocations` has maybe</span>
<span class="sd">        changed since the ordering of components has changed. Reassign the pin</span>
<span class="sd">        indices via :meth:`assignPinIndices` accordingly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assignPinIndices</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="HexBlock">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HexBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a Block shaped like a hexagon.</span>

<span class="sd">    .. impl:: ARMI has the ability to create hex shaped blocks.</span>
<span class="sd">        :id: I_ARMI_BLOCK_HEX</span>
<span class="sd">        :implements: R_ARMI_BLOCK_HEX</span>

<span class="sd">        This class defines hexagonal-shaped Blocks. It inherits functionality from the parent class,</span>
<span class="sd">        Block, and defines hexagonal-specific methods including, but not limited to, querying pin</span>
<span class="sd">        pitch, pin linear power densities, hydraulic diameter, and retrieving inner and outer pitch.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">PITCH_COMPONENT_TYPE</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">_PitchDefiningComponent</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">components</span><span class="o">.</span><span class="n">Hexagon</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="n">Block</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

<div class="viewcode-block" id="HexBlock.coords">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.coords">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinates of the block.</span>

<span class="sd">        .. impl:: Coordinates of a block are queryable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_POSI2</span>
<span class="sd">            :implements: R_ARMI_BLOCK_POSI</span>

<span class="sd">            Calls to the :py:meth:`~armi.reactor.grids.locations.IndexLocation.getGlobalCoordinates`</span>
<span class="sd">            method of the block&#39;s ``spatialLocator`` attribute, which recursively calls itself on</span>
<span class="sd">            all parents of the block to get the coordinates of the block&#39;s centroid in 3D cartesian</span>
<span class="sd">            space.</span>

<span class="sd">            Will additionally adjust the x and y coordinates based on the block parameters</span>
<span class="sd">            ``displacementX`` and ``displacementY``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">displacementX</span> <span class="o">*</span> <span class="mf">100.0</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">displacementY</span> <span class="o">*</span> <span class="mf">100.0</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">FLOAT_DIMENSION_DECIMALS</span><span class="p">),</span>
            <span class="nb">round</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">FLOAT_DIMENSION_DECIMALS</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HexBlock.createHomogenizedCopy">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.createHomogenizedCopy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">createHomogenizedCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pinSpatialLocators</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new homogenized copy of a block that is less expensive than a full deepcopy.</span>

<span class="sd">        .. impl:: Block compositions can be homogenized.</span>
<span class="sd">            :id: I_ARMI_BLOCK_HOMOG</span>
<span class="sd">            :implements: R_ARMI_BLOCK_HOMOG</span>

<span class="sd">            This method creates and returns a homogenized representation of itself in the form of a</span>
<span class="sd">            new Block. The homogenization occurs in the following manner. A single Hexagon Component</span>
<span class="sd">            is created and added to the new Block. This Hexagon Component is given the</span>
<span class="sd">            :py:class:`armi.materials.mixture._Mixture` material and a volume averaged temperature</span>
<span class="sd">            (``getAverageTempInC``). The number densities of the original Block are also stored on</span>
<span class="sd">            this new Component (:need:`I_ARMI_CMP_GET_NDENS`). Several parameters from the original</span>
<span class="sd">            block are copied onto the homogenized block (e.g., macros, lumped fission products,</span>
<span class="sd">            burnup group, number of pins, and spatial grid).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This can be used to improve performance when a new copy of a reactor needs to be built, but</span>
<span class="sd">        the full detail of the block (including component geometry, material, number density, etc.)</span>
<span class="sd">        is not required for the targeted physics solver being applied to the new reactor model.</span>

<span class="sd">        The main use case is for the uniform mesh converter (UMC). Frequently, a deterministic</span>
<span class="sd">        neutronics solver will require a uniform mesh reactor, which is produced by the UMC. Many</span>
<span class="sd">        deterministic solvers for fast spectrum reactors will also treat the individual blocks as</span>
<span class="sd">        homogenized mixtures. Since the neutronics solver does not need to know about the geometric</span>
<span class="sd">        and material details of the individual child components within a block, we can save</span>
<span class="sd">        significant effort while building the uniform mesh reactor with the UMC by omitting this</span>
<span class="sd">        detailed data and only providing the necessary level of detail for the uniform mesh reactor:</span>
<span class="sd">        number densities on each block.</span>

<span class="sd">        Individual components within a block can have different temperatures, and this can affect</span>
<span class="sd">        cross sections. This temperature variation is captured by the lattice physics module. As</span>
<span class="sd">        long as temperature distribution is correctly captured during cross section generation, it</span>
<span class="sd">        does not need to be transferred to the neutronics solver directly through this copy</span>
<span class="sd">        operation.</span>

<span class="sd">        If you make a new block, you must add it to an assembly and a reactor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        b : A homogenized block containing a single Hexagon Component that contains an average</span>
<span class="sd">            temperature and the number densities from the original block.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.converters.uniformMesh.UniformMeshGeometryConverter.makeAssemWithUniformMesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span> <span class="n">height</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">())</span>
        <span class="n">b</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getType</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flags</span><span class="p">)</span>

        <span class="c1"># assign macros and LFP</span>
        <span class="n">b</span><span class="o">.</span><span class="n">macros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">macros</span>
        <span class="n">b</span><span class="o">.</span><span class="n">_lumpedFissionProducts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lumpedFissionProducts</span>
        <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">envGroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">envGroup</span>

        <span class="n">hexComponent</span> <span class="o">=</span> <span class="n">Hexagon</span><span class="p">(</span>
            <span class="s2">&quot;homogenizedHex&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_Mixture&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getAverageTempInC</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getAverageTempInC</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">hexComponent</span><span class="o">.</span><span class="n">setNumberDensities</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">())</span>
        <span class="n">b</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">hexComponent</span><span class="p">)</span>

        <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">nPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">nPins</span>
        <span class="k">if</span> <span class="n">pinSpatialLocators</span><span class="p">:</span>
            <span class="c1"># create a null component with cladding flags and spatialLocator from source block&#39;s</span>
            <span class="c1"># clad components in case pin locations need to be known for physics solver</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">):</span>
                <span class="n">cladComponents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">clad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cladComponents</span><span class="p">):</span>
                    <span class="n">pinComponent</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;voidPin</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;Void&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getAverageTempInC</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getAverageTempInC</span><span class="p">(),</span>
                        <span class="mf">0.0</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">pinComponent</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="s2">&quot;pin&quot;</span><span class="p">,</span> <span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
                    <span class="n">pinComponent</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pinComponent</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">,</span> <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pinComponent</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)):</span>
                            <span class="n">i1</span><span class="o">.</span><span class="n">associate</span><span class="p">(</span><span class="n">i2</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
                    <span class="n">pinComponent</span><span class="o">.</span><span class="n">setDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">,</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">))</span>
                    <span class="n">b</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pinComponent</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span>

        <span class="k">return</span> <span class="n">b</span></div>


<div class="viewcode-block" id="HexBlock.getMaxArea">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getMaxArea">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getMaxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the max area of this block if it was totally full.&quot;&quot;&quot;</span>
        <span class="n">pitch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPitch</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pitch</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">area</span><span class="p">(</span><span class="n">pitch</span><span class="p">)</span></div>


<div class="viewcode-block" id="HexBlock.getDuctIP">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getDuctIP">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getDuctIP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the duct IP dimension.&quot;&quot;&quot;</span>
        <span class="n">duct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">duct</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;ip&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="HexBlock.getDuctOP">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getDuctOP">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getDuctOP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the duct OP dimension.&quot;&quot;&quot;</span>
        <span class="n">duct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">duct</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;op&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="HexBlock.initializePinLocations">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.initializePinLocations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">initializePinLocations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize pin locations.</span>

<span class="sd">        Deprecated. Use :meth:`assignPinIndices` to additionally update component parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># stacklevel=2 means the warning traceback, file, and line numbers will reflect the caller</span>
        <span class="c1"># of this method, not this method itself.</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;HexBlock.initializePinLocations is deprecated. Please use assignPinIndices&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assignPinIndices</span><span class="p">()</span></div>


<div class="viewcode-block" id="HexBlock.setPinPowers">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.setPinPowers">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setPinPowers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">powers</span><span class="p">,</span> <span class="n">powerKeySuffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the pin linear power densities of this block.</span>

<span class="sd">        The linear densities are represented by the ``linPowByPin`` parameter.</span>

<span class="sd">        It is expected that the ordering of ``powers`` is consistent with :meth:`getPinLocations`.</span>
<span class="sd">        That helps ensure alignment with component-level look ups like</span>
<span class="sd">        :meth:`~armi.reactor.components.Circle.getPinIndices`.</span>

<span class="sd">        The ``linPowByPin`` parameter can be directly assigned to instead of using this method if the</span>
<span class="sd">        multiplicity of the pins in the block is equal to the number of pins in the block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        powers : list of floats, required</span>
<span class="sd">            The block-level pin linear power densities. ``powers[i]`` represents the average linear</span>
<span class="sd">            power density of pin ``i`` location at ``self.getPinLocations()[i]``.</span>
<span class="sd">            The units of linear power density is watts/cm (i.e., watts produced per cm of pin length).</span>
<span class="sd">        powerKeySuffix: str, optional</span>
<span class="sd">            Must be either an empty string, :py:const:`NEUTRON &lt;armi.physics.neutronics.const.NEUTRON&gt;`,</span>
<span class="sd">            or :py:const:`GAMMA &lt;armi.physics.neutronics.const.GAMMA&gt;`. Defaults to empty string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numPins</span> <span class="ow">or</span> <span class="n">numPins</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">powers</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid power data for </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">numPins</span><span class="si">}</span><span class="s2"> pins. Got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">powers</span><span class="p">)</span><span class="si">}</span><span class="s2"> entries in powers: </span><span class="si">{</span><span class="n">powers</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">powerKey</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;linPowByPin</span><span class="si">{</span><span class="n">powerKeySuffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">powerKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">powers</span>

        <span class="c1"># If using the *powerKeySuffix* parameter, we also need to set total power, which is sum of</span>
        <span class="c1"># neutron and gamma powers. We assume that a solo gamma calculation to set total power does</span>
        <span class="c1"># not make sense.</span>
        <span class="k">if</span> <span class="n">powerKeySuffix</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">powerKeySuffix</span> <span class="o">==</span> <span class="n">GAMMA</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;linPowByPin</span><span class="si">{</span><span class="n">NEUTRON</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Neutron power has not been set yet. Cannot set total power for </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="k">raise</span> <span class="ne">UnboundLocalError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">linPowByPin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;linPowByPin</span><span class="si">{</span><span class="n">NEUTRON</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">powerKey</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">linPowByPin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">powerKey</span><span class="p">]</span></div>


<div class="viewcode-block" id="HexBlock.rotate">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.rotate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rad</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates a block&#39;s spatially varying parameters by a specified angle in the counter-clockwise</span>
<span class="sd">        direction.</span>

<span class="sd">        The parameters must have a ParamLocation of either CORNERS or EDGES and must be a Python</span>
<span class="sd">        list of length 6 in order to be eligible for rotation; all parameters that do not meet these</span>
<span class="sd">        two criteria are not rotated.</span>

<span class="sd">        .. impl:: Rotating a hex block updates parameters on the boundary, the orientation</span>
<span class="sd">            parameter, and the spatial coordinates on contained objects.</span>
<span class="sd">            :id: I_ARMI_ROTATE_HEX_BLOCK</span>
<span class="sd">            :implements: R_ARMI_ROTATE_HEX</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rad: float, required</span>
<span class="sd">            Angle of counter-clockwise rotation in units of radians. Rotations must be in 60-degree</span>
<span class="sd">            increments (i.e., PI/3, 2 * PI/3, PI, 4 * PI/3, 5 * PI/3, and 2 * PI).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rotNum</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">rad</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">60</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rotateChildLocations</span><span class="p">(</span><span class="n">rad</span><span class="p">,</span> <span class="n">rotNum</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">orientation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">orientation</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rotNum</span> <span class="o">*</span> <span class="mf">60.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rotateBoundaryParameters</span><span class="p">(</span><span class="n">rotNum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rotateDisplacement</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_rotateChildLocations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radians</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">rotNum</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update spatial locators for children.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">locationRotator</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">rotateIndex</span><span class="p">,</span> <span class="n">rotations</span><span class="o">=</span><span class="n">rotNum</span><span class="p">)</span>
        <span class="n">rotationMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">),</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">)],</span>
                <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">)],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">,</span> <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span><span class="p">):</span>
                <span class="n">newLocations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">locationRotator</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">))</span>
                <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">newLocations</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">,</span> <span class="n">grids</span><span class="o">.</span><span class="n">CoordinateLocation</span><span class="p">):</span>
                <span class="n">oldCoords</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">()</span>
                <span class="n">newXY</span> <span class="o">=</span> <span class="n">rotationMatrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">oldCoords</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">newLocation</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">CoordinateLocation</span><span class="p">(</span><span class="n">newXY</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">newXY</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">oldCoords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">newLocation</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">,</span> <span class="n">grids</span><span class="o">.</span><span class="n">IndexLocation</span><span class="p">):</span>
                <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">locationRotator</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2"> on </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> has an invalid spatial locator for rotation: </span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rotateBoundaryParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotNum</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rotate any parameters defined on the corners or edge of bounding hexagon.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rotNum : int</span>
<span class="sd">            Rotation number between zero and five, inclusive, specifying how many rotations have</span>
<span class="sd">            taken place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="o">.</span><span class="n">atLocation</span><span class="p">(</span><span class="n">ParamLocation</span><span class="o">.</span><span class="n">CORNERS</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>
        <span class="n">names</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="o">.</span><span class="n">atLocation</span><span class="p">(</span><span class="n">ParamLocation</span><span class="o">.</span><span class="n">EDGES</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">original</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                    <span class="c1"># Rotate by making the -rotNum item be first</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">iterables</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="o">-</span><span class="n">rotNum</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Hasn&#39;t been defined yet, no warning needed.</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;No rotation method defined for spatial parameters that aren&#39;t defined &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;once per hex edge/corner. No rotation performed on </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="c1"># this is a scalar and there shouldn&#39;t be any rotation.</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">original</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># param is not set yet. no rotations as well.</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;b.rotate() method received unexpected data type for </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> on block </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;expected list, np.ndarray, int, or float. received </span><span class="si">{</span><span class="n">original</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rotateDisplacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rad</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="c1"># This specifically uses the .get() functionality to avoid an error if this parameter does</span>
        <span class="c1"># not exist.</span>
        <span class="n">dispx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;displacementX&quot;</span><span class="p">)</span>
        <span class="n">dispy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;displacementY&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dispx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dispy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">displacementX</span> <span class="o">=</span> <span class="n">dispx</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">-</span> <span class="n">dispy</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">displacementY</span> <span class="o">=</span> <span class="n">dispx</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">dispy</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span>

<div class="viewcode-block" id="HexBlock.verifyBlockDims">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.verifyBlockDims">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">verifyBlockDims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform some checks on this type of block before it is assembled.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wireComp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Quiet because None case is checked for below</span>
            <span class="n">ductComps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">)</span>
            <span class="n">cladComp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Quiet because None case is checked for below</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># there are probably more that one clad/wire, so we really dont know what this block looks like</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Block design </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is too complicated to verify dimensions. Make sure they are correct!&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># check wire wrap in contact with clad</span>
        <span class="k">if</span> <span class="n">cladComp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">wireComp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wwCladGap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getWireWrapCladGap</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">wwCladGap</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;The gap between wire wrap and clad in block </span><span class="si">{}</span><span class="s2"> was </span><span class="si">{}</span><span class="s2"> cm. Expected 0.0.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wwCladGap</span><span class="p">),</span>
                    <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># check clad duct overlap</span>
        <span class="n">pinToDuctGap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinToDuctGap</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Allow for some tolerance; user input precision may lead to slight negative gaps</span>
        <span class="k">if</span> <span class="n">pinToDuctGap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pinToDuctGap</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.005</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Gap between pins and duct is </span><span class="si">{0:.4f}</span><span class="s2"> cm in </span><span class="si">{1}</span><span class="s2">. Make more room.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pinToDuctGap</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">pinToDuctGap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># only produce a warning if pin or clad are found, but not all of pin, clad and duct. We</span>
            <span class="c1"># may need to tune this logic a bit</span>
            <span class="n">ductComp</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">ductComps</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cladComp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">wireComp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">[</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="n">wireComp</span><span class="p">,</span> <span class="n">cladComp</span><span class="p">,</span> <span class="n">ductComp</span><span class="p">)]</span>
            <span class="p">):</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Some component was missing in </span><span class="si">{}</span><span class="s2"> so pin-to-duct gap not calculated&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>


<div class="viewcode-block" id="HexBlock.getPinToDuctGap">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getPinToDuctGap">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getPinToDuctGap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance in cm between the outer most pin and the duct in a block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cold : boolean</span>
<span class="sd">            Determines whether the results should be cold or hot dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pinToDuctGap : float</span>
<span class="sd">            Returns the diameteral gap between the outer most pins in a hex pack to the duct inner</span>
<span class="sd">            face to face in cm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wire</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Quiet because None case is checked for below</span>
        <span class="n">ducts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">))</span>
        <span class="n">duct</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ducts</span><span class="p">):</span>
            <span class="n">duct</span> <span class="o">=</span> <span class="n">ducts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">duct</span><span class="p">,</span> <span class="n">components</span><span class="o">.</span><span class="n">Hexagon</span><span class="p">):</span>
                <span class="c1"># getPinCenterFlatToFlat only works for hexes</span>
                <span class="c1"># inner most duct might be circle or some other shape</span>
                <span class="n">duct</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">duct</span><span class="p">,</span> <span class="n">components</span><span class="o">.</span><span class="n">HoledHexagon</span><span class="p">):</span>
                <span class="c1"># has no ip and is circular on inside so following</span>
                <span class="c1"># code will not work</span>
                <span class="n">duct</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Quiet because None case is checked for below</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="n">duct</span><span class="p">,</span> <span class="n">wire</span><span class="p">,</span> <span class="n">clad</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># NOTE: If nRings was a None, this could be for a non-hex packed fuel assembly see thermal</span>
        <span class="c1"># hydraulic design basis for description of equation</span>
        <span class="n">pinCenterFlatToFlat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinCenterFlatToFlat</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="n">pinOuterFlatToFlat</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pinCenterFlatToFlat</span> <span class="o">+</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">wire</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">ductMarginToContact</span> <span class="o">=</span> <span class="n">duct</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;ip&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">-</span> <span class="n">pinOuterFlatToFlat</span>
        <span class="n">pinToDuctGap</span> <span class="o">=</span> <span class="n">ductMarginToContact</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="k">return</span> <span class="n">pinToDuctGap</span></div>


<div class="viewcode-block" id="HexBlock.getRotationNum">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getRotationNum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getRotationNum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get index 0 through 5 indicating number of rotations counterclockwise around the z-axis.&quot;&quot;&quot;</span>
        <span class="c1"># assume rotation only in Z</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">orientation</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mf">360.0</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span></div>


<div class="viewcode-block" id="HexBlock.setRotationNum">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.setRotationNum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setRotationNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotNum</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set orientation based on a number 0 through 5 indicating number of rotations</span>
<span class="sd">        counterclockwise around the z-axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">orientation</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">60.0</span> <span class="o">*</span> <span class="n">rotNum</span></div>


<div class="viewcode-block" id="HexBlock.getSymmetryFactor">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getSymmetryFactor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getSymmetryFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a factor between 1 and N where 1/N is how much cut-off by symmetry lines this mesh</span>
<span class="sd">        cell is.</span>

<span class="sd">        Reactor-level meshes have symmetry information so we have a reactor for this to work. That&#39;s</span>
<span class="sd">        why it&#39;s not implemented on the grid/locator level.</span>

<span class="sd">        When edge-assemblies are included on both edges (i.e. MCNP or DIF3D-FD 1/3-symmetric cases),</span>
<span class="sd">        the edge assemblies have symmetry factors of 2.0. Otherwise (DIF3D-nodal) there&#39;s a full</span>
<span class="sd">        assembly on the bottom edge (overhanging) and no assembly at the top edge so the ones at the</span>
<span class="sd">        bottom are considered full (symmetryFactor=1).</span>

<span class="sd">        If this block is not in any grid at all, then there can be no symmetry so return 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">symmetry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">symmetry</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">THIRD_CORE</span> <span class="ow">and</span> <span class="n">symmetry</span><span class="o">.</span><span class="n">boundary</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">PERIODIC</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># central location</span>
                <span class="k">return</span> <span class="mf">3.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">symmetryLine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">overlapsWhichSymmetryLine</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="c1"># detect if upper edge assemblies are included. Doing this is the only way to know</span>
                <span class="c1"># definitively whether or not the edge assemblies are half-assems or full. Seeing</span>
                <span class="c1"># the first one is the easiest way to detect them. Check it last in the and</span>
                <span class="c1"># statement so we don&#39;t waste time doing it.</span>
                <span class="n">upperEdgeLoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">symmetryLine</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="n">grids</span><span class="o">.</span><span class="n">BOUNDARY_0_DEGREES</span><span class="p">,</span>
                    <span class="n">grids</span><span class="o">.</span><span class="n">BOUNDARY_120_DEGREES</span><span class="p">,</span>
                <span class="p">]</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">upperEdgeLoc</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="mf">2.0</span>
        <span class="k">return</span> <span class="mf">1.0</span></div>


<div class="viewcode-block" id="HexBlock.autoCreateSpatialGrids">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.autoCreateSpatialGrids">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">autoCreateSpatialGrids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">systemSpatialGrid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a block without a spatialGrid, create a spatialGrid and give its children the</span>
<span class="sd">        corresponding spatialLocators (if it is a simple block).</span>

<span class="sd">        In this case, a simple block would be one that has either multiplicity of components equal</span>
<span class="sd">        to 1 or N but no other multiplicities. Also, this should only happen when N fits exactly</span>
<span class="sd">        into a given number of hex rings. Otherwise, do not create a grid for this block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        systemSpatialGrid : Grid, optional</span>
<span class="sd">            Spatial Grid of the system-level parent of this Assembly that contains this Block.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When a hex grid has another hex grid nested inside it, the nested grid has the opposite</span>
<span class="sd">        orientation (corners vs flats up). This method takes care of that.</span>

<span class="sd">        If components inside this block are multiplicity 1, they get a single locator at the center</span>
<span class="sd">        of the grid cell. If the multiplicity is greater than 1, all the components are added to a</span>
<span class="sd">        multiIndexLocation on the hex grid.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the multiplicities of the block are not only 1 or N or if generated ringNumber leads</span>
<span class="sd">            to more positions than necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># not necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Check multiplicities</span>
        <span class="n">mults</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">()}</span>

        <span class="c1"># Do some validation: Should we try to create a spatial grid?</span>
        <span class="n">multz</span> <span class="o">=</span> <span class="p">{</span><span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mults</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">multz</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mf">1.0</span> <span class="ow">in</span> <span class="n">multz</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Block </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> does not need a spatial grid: multiplicities are all 1.&quot;</span><span class="p">,</span>
                <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">multz</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="mf">1.0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">multz</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Could not create a spatialGrid for block </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">, multiplicities are not </span><span class="se">{{</span><span class="s2">1, N</span><span class="se">}}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;they are </span><span class="si">{</span><span class="n">mults</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># build the grid, from pitch and orientation</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">systemSpatialGrid</span><span class="p">,</span> <span class="n">grids</span><span class="o">.</span><span class="n">HexGrid</span><span class="p">):</span>
            <span class="n">cornersUp</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">systemSpatialGrid</span><span class="o">.</span><span class="n">cornersUp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cornersUp</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">HexGrid</span><span class="o">.</span><span class="n">fromPitch</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getPinPitch</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">numRings</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">armiObject</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">cornersUp</span><span class="o">=</span><span class="n">cornersUp</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">ringNumber</span> <span class="o">=</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numRingsToHoldNumCells</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">())</span>
        <span class="n">numLocations</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ringNumber</span><span class="p">):</span>
            <span class="n">numLocations</span> <span class="o">=</span> <span class="n">numLocations</span> <span class="o">+</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numPositionsInRing</span><span class="p">(</span><span class="n">ring</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numLocations</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot create spatialGrid, number of locations in rings </span><span class="si">{}</span><span class="s2"> not equal to pin number </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">numLocations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># set the spatial position of the sub-block components</span>
        <span class="n">spatialLocators</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ringNumber</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">getPositionsInRing</span><span class="p">(</span><span class="n">ring</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getIndicesFromRingAndPos</span><span class="p">(</span><span class="n">ring</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">spatialLocators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># finally, fill the spatial grid, and put the sub-block components on it</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="n">grid</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">spatialLocators</span>
                <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">CoordinateLocation</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span></div>


<div class="viewcode-block" id="HexBlock.assignPinIndices">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.assignPinIndices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assignPinIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign pin indices for pin components on the block.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">locations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinLocations</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">locations</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">ijGetter</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;j&quot;</span><span class="p">)</span>
        <span class="n">allIJ</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">ijGetter</span><span class="p">,</span> <span class="n">locations</span><span class="p">))</span>
        <span class="c1"># Flags for components that we want to set this parameter</span>
        <span class="c1"># Usually things are linked to one of these &quot;important&quot; flags, like</span>
        <span class="c1"># a cladding component having linked dimensions to a fuel component</span>
        <span class="n">primaryFlags</span> <span class="o">=</span> <span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span> <span class="n">Flags</span><span class="o">.</span><span class="n">CONTROL</span><span class="p">,</span> <span class="n">Flags</span><span class="o">.</span><span class="n">SHIELD</span><span class="p">)</span>
        <span class="n">withPinIndices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">components</span><span class="o">.</span><span class="n">Component</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterChildrenWithFlags</span><span class="p">(</span><span class="n">primaryFlags</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setPinIndices</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ijGetter</span><span class="p">,</span> <span class="n">allIJ</span><span class="p">):</span>
                <span class="n">withPinIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="c1"># Iterate over every other thing on the grid and make sure</span>
        <span class="c1"># 1) it share a lattice site with something that has pin indices, or</span>
        <span class="c1"># 2) it itself declares the pin indices</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinIndices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Does anything with pin indices share this lattice site?</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">withPinIndices</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setPinIndices</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ijGetter</span><span class="p">,</span> <span class="n">allIJ</span><span class="p">):</span>
                <span class="n">withPinIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_setPinIndices</span><span class="p">(</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">components</span><span class="o">.</span><span class="n">Component</span><span class="p">,</span> <span class="n">ijGetter</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">grids</span><span class="o">.</span><span class="n">IndexLocation</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">allIJ</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="n">localLocations</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">localLocations</span><span class="p">,</span> <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span><span class="p">):</span>
            <span class="n">localIJ</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">ijGetter</span><span class="p">,</span> <span class="n">localLocations</span><span class="p">))</span>
        <span class="c1"># CoordinateLocations do not live on the grid, by definition</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">localLocations</span><span class="p">,</span> <span class="n">grids</span><span class="o">.</span><span class="n">CoordinateLocation</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">localLocations</span><span class="p">,</span> <span class="n">grids</span><span class="o">.</span><span class="n">IndexLocation</span><span class="p">):</span>
            <span class="n">localIJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">ijGetter</span><span class="p">(</span><span class="n">localLocations</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">localIndices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">allIJ</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">localIJ</span><span class="p">))</span>
        <span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinIndices</span> <span class="o">=</span> <span class="n">localIndices</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="HexBlock.getPinCenterFlatToFlat">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getPinCenterFlatToFlat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getPinCenterFlatToFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the flat-to-flat distance between the centers of opposing pins in the outermost ring.&quot;&quot;&quot;</span>
        <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="n">nRings</span> <span class="o">=</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numRingsToHoldNumCells</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">))</span>
        <span class="n">pinPitch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinPitch</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="n">pinCenterCornerToCorner</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nRings</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pinPitch</span>
        <span class="n">pinCenterFlatToFlat</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">pinCenterCornerToCorner</span>
        <span class="k">return</span> <span class="n">pinCenterFlatToFlat</span></div>


<div class="viewcode-block" id="HexBlock.hasPinPitch">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.hasPinPitch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">hasPinPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if the block has enough information to calculate pin pitch.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HexBlock.getPinPitch">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getPinPitch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getPinPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the pin pitch in cm.</span>

<span class="sd">        Assumes that the pin pitch is defined entirely by contacting cladding tubes and wire wraps.</span>
<span class="sd">        Grid spacers not yet supported.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cold : boolean</span>
<span class="sd">            Determines whether the dimensions should be cold or hot</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pinPitch : float</span>
<span class="sd">            pin pitch in cm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Quiet because None case is checked for below</span>
            <span class="n">wire</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Quiet because None case is checked for below</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Block </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> has multiple clad and wire components, so pin pitch is not well-defined.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">wire</span> <span class="ow">and</span> <span class="n">clad</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">+</span> <span class="n">wire</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot get pin pitch in </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> because it does not have a wire and a clad&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="HexBlock.getWettedPerimeter">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getWettedPerimeter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getWettedPerimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the total wetted perimeter of the block in cm.&quot;&quot;&quot;</span>
        <span class="c1"># flags pertaining to hexagon components where the interior of the hexagon is wetted</span>
        <span class="n">wettedHollowHexagonComponentFlags</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">,</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">GRID_PLATE</span><span class="p">,</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">INLET_NOZZLE</span><span class="p">,</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">HANDLING_SOCKET</span><span class="p">,</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">DEPLETABLE</span><span class="p">,</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">GRID_PLATE</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">DEPLETABLE</span><span class="p">,</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">INLET_NOZZLE</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">DEPLETABLE</span><span class="p">,</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">HANDLING_SOCKET</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">DEPLETABLE</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># flags pertaining to circular pin components where the exterior of the circle is wetted</span>
        <span class="n">wettedPinComponentFlags</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">,</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># flags pertaining to components where both the interior and exterior are wetted</span>
        <span class="n">wettedHollowComponentFlags</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">INNER</span><span class="p">,</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">INNER</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">DEPLETABLE</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># obtain all wetted components based on type</span>
        <span class="n">wettedHollowHexagonComponents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">wettedHollowHexagonComponentFlags</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">wettedHollowHexagonComponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">wettedPinComponents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">wettedPinComponentFlags</span><span class="p">:</span>
            <span class="n">comps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
            <span class="n">wettedPinComponents</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span>

        <span class="n">wettedHollowCircleComponents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">wettedHollowHexComponents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">wettedHollowComponentFlags</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Hexagon</span><span class="p">):</span>
                <span class="n">wettedHollowHexComponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wettedHollowCircleComponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># calculate wetted perimeters according to their geometries</span>
        <span class="c1"># hollow hexagon = 6 * ip / sqrt(3)</span>
        <span class="n">wettedHollowHexagonPerimeter</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">wettedHollowHexagonComponents</span><span class="p">:</span>
            <span class="n">wettedHollowHexagonPerimeter</span> <span class="o">+=</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;ip&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="mf">0.0</span>

        <span class="c1"># solid circle = NumPins * pi * (Comp Diam + Wire Diam)</span>
        <span class="n">wettedPinPerimeter</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">wettedPinComponents</span><span class="p">:</span>
            <span class="n">correctionFactor</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Helix</span><span class="p">):</span>
                <span class="c1"># account for the helical wire wrap</span>
                <span class="n">correctionFactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span>
                    <span class="mf">1.0</span><span class="p">,</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;helixDiameter&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;axialPitch&quot;</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="n">compWettedPerim</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">correctionFactor</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">wettedPinPerimeter</span> <span class="o">+=</span> <span class="n">compWettedPerim</span>

        <span class="c1"># hollow circle = (id + od) * pi</span>
        <span class="n">wettedHollowCirclePerimeter</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">wettedHollowCircleComponents</span><span class="p">:</span>
            <span class="n">wettedHollowCirclePerimeter</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="n">wettedHollowCirclePerimeter</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># hollow hexagon = 6 * (ip + op) / sqrt(3)</span>
        <span class="n">wettedHollowHexPerimeter</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">wettedHollowHexComponents</span><span class="p">:</span>
            <span class="n">wettedHollowHexPerimeter</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;ip&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;op&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="n">wettedHollowHexPerimeter</span> <span class="o">*=</span> <span class="mi">6</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">wettedHollowHexagonPerimeter</span> <span class="o">+</span> <span class="n">wettedPinPerimeter</span> <span class="o">+</span> <span class="n">wettedHollowCirclePerimeter</span> <span class="o">+</span> <span class="n">wettedHollowHexPerimeter</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HexBlock.getFlowArea">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getFlowArea">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getFlowArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the total flowing coolant area of the block in cm^2.&quot;&quot;&quot;</span>
        <span class="n">area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">COOLANT</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">getArea</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">INTERDUCTCOOLANT</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">area</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">getArea</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">area</span></div>


<div class="viewcode-block" id="HexBlock.getHydraulicDiameter">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getHydraulicDiameter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getHydraulicDiameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the hydraulic diameter in this block in cm.</span>

<span class="sd">        Hydraulic diameter is 4A/P where A is the flow area and P is the wetted perimeter. In a hex</span>
<span class="sd">        assembly, the wetted perimeter includes the cladding, the wire wrap, and the inside of the</span>
<span class="sd">        duct. The flow area is the inner area of the duct minus the area of the pins and the wire.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFlowArea</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getWettedPerimeter</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="CartesianBlock">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CartesianBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
    <span class="n">PITCH_DIMENSION</span> <span class="o">=</span> <span class="s2">&quot;widthOuter&quot;</span>
    <span class="n">PITCH_COMPONENT_TYPE</span> <span class="o">=</span> <span class="n">components</span><span class="o">.</span><span class="n">Rectangle</span>

<div class="viewcode-block" id="CartesianBlock.getMaxArea">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock.getMaxArea">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getMaxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get area of this block if it were totally full.&quot;&quot;&quot;</span>
        <span class="n">xw</span><span class="p">,</span> <span class="n">yw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPitch</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">xw</span> <span class="o">*</span> <span class="n">yw</span></div>


<div class="viewcode-block" id="CartesianBlock.setPitch">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock.setPitch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">updateBolParams</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Directly setting the pitch of a cartesian block is currently not supported.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="CartesianBlock.getSymmetryFactor">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock.getSymmetryFactor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getSymmetryFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a factor between 1 and N where 1/N is how much cut-off by symmetry lines this mesh</span>
<span class="sd">        cell is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">isThroughCenterAssembly</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># central location</span>
                    <span class="k">return</span> <span class="mf">4.0</span>
                <span class="k">elif</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># edge location</span>
                    <span class="k">return</span> <span class="mf">2.0</span>

        <span class="k">return</span> <span class="mf">1.0</span></div>


<div class="viewcode-block" id="CartesianBlock.getPinCenterFlatToFlat">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock.getPinCenterFlatToFlat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getPinCenterFlatToFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the flat-to-flat distance between the centers of opposing pins in the outermost ring.&quot;&quot;&quot;</span>
        <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="n">nRings</span> <span class="o">=</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numRingsToHoldNumCells</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">))</span>
        <span class="n">pinPitch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinPitch</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nRings</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pinPitch</span></div>
</div>



<div class="viewcode-block" id="ThRZBlock">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ThRZBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
<div class="viewcode-block" id="ThRZBlock.getMaxArea">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.getMaxArea">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getMaxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the area of the Theta-R-Z block if it was totally full.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot get max area of a TRZ block. Fully specify your geometry.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ThRZBlock.radialInner">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.radialInner">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">radialInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a smallest radius of all the components.&quot;&quot;&quot;</span>
        <span class="n">innerRadii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;inner_radius&quot;</span><span class="p">)</span>
        <span class="n">smallestInner</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">innerRadii</span><span class="p">)</span> <span class="k">if</span> <span class="n">innerRadii</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">smallestInner</span></div>


<div class="viewcode-block" id="ThRZBlock.radialOuter">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.radialOuter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">radialOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a largest radius of all the components.&quot;&quot;&quot;</span>
        <span class="n">outerRadii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;outer_radius&quot;</span><span class="p">)</span>
        <span class="n">largestOuter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">outerRadii</span><span class="p">)</span> <span class="k">if</span> <span class="n">outerRadii</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">largestOuter</span></div>


<div class="viewcode-block" id="ThRZBlock.thetaInner">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.thetaInner">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">thetaInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a smallest theta of all the components.&quot;&quot;&quot;</span>
        <span class="n">innerTheta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;inner_theta&quot;</span><span class="p">)</span>
        <span class="n">smallestInner</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">innerTheta</span><span class="p">)</span> <span class="k">if</span> <span class="n">innerTheta</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">smallestInner</span></div>


<div class="viewcode-block" id="ThRZBlock.thetaOuter">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.thetaOuter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">thetaOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a largest theta of all the components.&quot;&quot;&quot;</span>
        <span class="n">outerTheta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;outer_theta&quot;</span><span class="p">)</span>
        <span class="n">largestOuter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">outerTheta</span><span class="p">)</span> <span class="k">if</span> <span class="n">outerTheta</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">largestOuter</span></div>


<div class="viewcode-block" id="ThRZBlock.axialInner">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.axialInner">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">axialInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the lower z-coordinate.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;inner_axial&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ThRZBlock.axialOuter">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.axialOuter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">axialOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the upper z-coordinate.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;outer_axial&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ThRZBlock.verifyBlockDims">
<a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.verifyBlockDims">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">verifyBlockDims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform dimension checks related to ThetaRZ blocks.&quot;&quot;&quot;</span>
        <span class="k">return</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2009-2025, TerraPower, LLC.
      <span class="lastupdated">Last updated on 2025-09-24.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
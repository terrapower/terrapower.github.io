

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>armi.reactor.blocks &mdash; ARMI 0.2.3 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_fixes.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/armiicon_16x16.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="../../../_static/assets/jsonview.bundle.js"></script>
        <script src="../../../_static/assets/jsonview_loader.js"></script>
        <script src="../../../_static/sphinx-needs/libs/html/datatables.min.js"></script>
        <script src="../../../_static/sphinx-needs/libs/html/datatables_loader.js"></script>
        <script src="../../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >
          

          
            <a href="../../../index.html" class="icon icon-home"> ARMI
          

          
            
            <img src="../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../requirements/index.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../.apidocs/modules.html">API Docs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ARMI</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../armi.html">armi</a> &raquo;</li>
        
          <li><a href="../reactor.html">armi.reactor</a> &raquo;</li>
        
      <li>armi.reactor.blocks</li>
    
    
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for armi.reactor.blocks</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Defines blocks, which are axial chunks of assemblies. They contain</span>
<span class="sd">most of the state variables, including power, flux, and homogenized number densities.</span>

<span class="sd">Assemblies are made of blocks.</span>

<span class="sd">Blocks are made of components.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">ClassVar</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">composites</span>
<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">runLog</span>
<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">settings</span>
<span class="kn">from</span> <span class="nn">armi.nucDirectory</span> <span class="kn">import</span> <span class="n">nucDir</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">geometry</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">parameters</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">blockParameters</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">grids</span>
<span class="kn">from</span> <span class="nn">armi.reactor.flags</span> <span class="kn">import</span> <span class="n">Flags</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">components</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">units</span>
<span class="kn">from</span> <span class="nn">armi.utils.plotting</span> <span class="kn">import</span> <span class="n">plotBlockFlux</span>
<span class="kn">from</span> <span class="nn">armi.bookkeeping</span> <span class="kn">import</span> <span class="n">report</span>
<span class="kn">from</span> <span class="nn">armi.physics</span> <span class="kn">import</span> <span class="n">constants</span>
<span class="kn">from</span> <span class="nn">armi.utils.units</span> <span class="kn">import</span> <span class="n">TRACE_NUMBER_DENSITY</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">hexagon</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">densityTools</span>
<span class="kn">from</span> <span class="nn">armi.physics.neutronics</span> <span class="kn">import</span> <span class="n">NEUTRON</span>
<span class="kn">from</span> <span class="nn">armi.physics.neutronics</span> <span class="kn">import</span> <span class="n">GAMMA</span>
<span class="kn">from</span> <span class="nn">armi.reactor.parameters</span> <span class="kn">import</span> <span class="n">ParamLocation</span>

<span class="n">PIN_COMPONENTS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">CONTROL</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">PLENUM</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">SHIELD</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">PIN</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">_PitchDefiningComponent</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">components</span><span class="o">.</span><span class="n">Component</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span>


<div class="viewcode-block" id="Block"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block">[docs]</a><span class="k">class</span> <span class="nc">Block</span><span class="p">(</span><span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A homogenized axial slab of material.</span>

<span class="sd">    Blocks are stacked together to form assemblies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">uniqID</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># dimension used to determine which component defines the block&#39;s pitch</span>
    <span class="n">PITCH_DIMENSION</span> <span class="o">=</span> <span class="s2">&quot;op&quot;</span>

    <span class="c1"># component type that can be considered a candidate for providing pitch</span>
    <span class="n">PITCH_COMPONENT_TYPE</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">_PitchDefiningComponent</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">pDefs</span> <span class="o">=</span> <span class="n">blockParameters</span><span class="o">.</span><span class="n">getBlockParameterDefinitions</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a new ARMI block</span>

<span class="sd">        name : str</span>
<span class="sd">            The name of this block</span>

<span class="sd">        height : float, optional</span>
<span class="sd">            The height of the block in cm. Defaults to 1.0 so that</span>
<span class="sd">            `getVolume` assumes unit height.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">heightBOL</span> <span class="o">=</span> <span class="n">height</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">macros</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axialExpTargetComponent</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># flag to indicated when DerivedShape children must be updated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derivedMustUpdate</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># which component to use to determine block pitch, along with its &#39;op&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># TODO: what&#39;s causing these to have wrong values at BOL?</span>
        <span class="k">for</span> <span class="n">problemParam</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;THcornTemp&quot;</span><span class="p">,</span> <span class="s2">&quot;THedgeTemp&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">problemParam</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">problemParam</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="s2">&quot;residence&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bondRemoved&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fluence&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fastFluence&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fastFluencePeak&quot;</span><span class="p">,</span>
            <span class="s2">&quot;displacementX&quot;</span><span class="p">,</span>
            <span class="s2">&quot;displacementY&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fluxAdj&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bu&quot;</span><span class="p">,</span>
            <span class="s2">&quot;buRate&quot;</span><span class="p">,</span>
            <span class="s2">&quot;eqRegion&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fissileFraction&quot;</span><span class="p">,</span>
        <span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">problemParam</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># be warned, changing this might break unit tests on input file generations</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{type}</span><span class="s2"> </span><span class="si">{name}</span><span class="s2"> at </span><span class="si">{loc}</span><span class="s2"> XS: </span><span class="si">{xs}</span><span class="s2"> BU GP: </span><span class="si">{bu}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getType</span><span class="p">(),</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span>
            <span class="n">xs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">xsType</span><span class="p">,</span>
            <span class="n">bu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buGroup</span><span class="p">,</span>
            <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getLocation</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom deepcopy behavior to prevent duplication of macros and _lumpedFissionProducts.</span>

<span class="sd">        We detach the recursive links to the parent and the reactor to prevent blocks carrying large</span>
<span class="sd">        independent copies of stale reactors in memory. If you make a new block, you must add it to</span>
<span class="sd">        an assembly and a reactor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add self to memo to prevent child objects from duplicating the parent block</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

        <span class="c1"># use __getstate__ and __setstate__ pickle-methods to initialize</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>  <span class="c1"># __getstate__ removes parent</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;macros&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;_lumpedFissionProducts&quot;</span><span class="p">]</span>
        <span class="n">b</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>

        <span class="c1"># assign macros and LFP</span>
        <span class="n">b</span><span class="o">.</span><span class="n">macros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">macros</span>
        <span class="n">b</span><span class="o">.</span><span class="n">_lumpedFissionProducts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lumpedFissionProducts</span>

        <span class="k">return</span> <span class="n">b</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">armi.reactor.reactors</span> <span class="kn">import</span> <span class="n">Core</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAncestor</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Core</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Look through the ancestors of the Block to find a Reactor, and return it.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Typical hierarchy: Reactor &lt;- Core &lt;- Assembly &lt;- Block</span>
<span class="sd">        A block should only have a reactor through a parent assembly.</span>
<span class="sd">        It may make sense to try to factor out usage of ``b.r``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        core.parent : armi.reactor.reactors.Reactor</span>
<span class="sd">            ARMI reactor object that is an ancestor of the block.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the parent of the block&#39;s ``core`` is not an ``armi.reactor.reactors.Reactor``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">armi.reactor.reactors</span> <span class="kn">import</span> <span class="n">Reactor</span>

        <span class="n">core</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span>
        <span class="k">if</span> <span class="n">core</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAncestor</span><span class="p">(</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Reactor</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">Reactor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Parent of Block (</span><span class="si">{}</span><span class="s2">) core is not a Reactor. Got </span><span class="si">{}</span><span class="s2"> instead&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">core</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">parent</span>

<div class="viewcode-block" id="Block.makeName"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.makeName">[docs]</a>    <span class="k">def</span> <span class="nf">makeName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemNum</span><span class="p">,</span> <span class="n">axialIndex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a standard block from assembly number.</span>

<span class="sd">        This also sets the block-level assembly-num param.</span>

<span class="sd">        Once, we used a axial-character suffix to represent the axial</span>
<span class="sd">        index, but this is inherently limited so we switched to a numerical</span>
<span class="sd">        name. The axial suffix needs can be brought in in plugins that require</span>
<span class="sd">        them.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; makeName(120, 5)</span>
<span class="sd">        &#39;B0120-005&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span> <span class="o">=</span> <span class="n">assemNum</span>
        <span class="k">return</span> <span class="s2">&quot;B</span><span class="si">{0:04d}</span><span class="s2">-</span><span class="si">{1:03d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">assemNum</span><span class="p">,</span> <span class="n">axialIndex</span><span class="p">)</span></div>

<div class="viewcode-block" id="Block.getSmearDensity"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getSmearDensity">[docs]</a>    <span class="k">def</span> <span class="nf">getSmearDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the smear density of pins in this block.</span>

<span class="sd">        Smear density is the area of the fuel divided by the area of the space available</span>
<span class="sd">        for fuel inside the cladding. Other space filled with solid materials is not</span>
<span class="sd">        considered available. If all the area is fuel, it has 100% smear density. Lower</span>
<span class="sd">        smear density allows more room for swelling.</span>

<span class="sd">        .. warning:: This requires circular fuel and circular cladding. Designs that vary</span>
<span class="sd">            from this will be wrong. It may make sense in the future to put this somewhere a</span>
<span class="sd">            bit more design specific.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This only considers circular objects. If you have a cladding that is not a circle,</span>
<span class="sd">        it will be ignored.</span>

<span class="sd">        Negative areas can exist for void gaps in the fuel pin. A negative area in a gap</span>
<span class="sd">        represents overlap area between two solid components. To account for this</span>
<span class="sd">        additional space within the pin cladding the abs(negativeArea) is added to the</span>
<span class="sd">        inner cladding area.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        cold : bool, optional</span>
<span class="sd">            If false, returns the smear density at hot temperatures</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smearDensity : float</span>
<span class="sd">            The smear density as a fraction</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fuels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fuels</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>  <span class="c1"># Smear density is not computed for non-fuel blocks</span>

        <span class="n">circles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponentsOfShape</span><span class="p">(</span><span class="n">components</span><span class="o">.</span><span class="n">Circle</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">circles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get smear density of </span><span class="si">{}</span><span class="s2">. There are no circular components.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">clads</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">circles</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">clads</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get smear density of </span><span class="si">{}</span><span class="s2">. There are no clad components.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Compute component areas</span>
        <span class="n">cladID</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="k">for</span> <span class="n">clad</span> <span class="ow">in</span> <span class="n">clads</span><span class="p">])</span>
        <span class="n">innerCladdingArea</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">cladID</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">fuelComponentArea</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">unmovableComponentArea</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">negativeArea</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSortedComponentsInsideOfComponent</span><span class="p">(</span><span class="n">clads</span><span class="o">.</span><span class="n">pop</span><span class="p">()):</span>
            <span class="n">componentArea</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getArea</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isFuel</span><span class="p">():</span>
                <span class="n">fuelComponentArea</span> <span class="o">+=</span> <span class="n">componentArea</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">SLUG</span><span class="p">):</span>
                <span class="c1"># this flag designates that this clad/slug combination isn&#39;t fuel and shouldn&#39;t be counted in the average</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">containsSolidMaterial</span><span class="p">():</span>
                    <span class="n">unmovableComponentArea</span> <span class="o">+=</span> <span class="n">componentArea</span>
                <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">containsVoidMaterial</span><span class="p">()</span> <span class="ow">and</span> <span class="n">componentArea</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cold</span><span class="p">:</span>  <span class="c1"># will error out soon</span>
                        <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> with id </span><span class="si">{}</span><span class="s2"> and od </span><span class="si">{}</span><span class="s2"> has negative area at cold dimensions&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">c</span><span class="p">,</span>
                                <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                                <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">negativeArea</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">componentArea</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cold</span> <span class="ow">and</span> <span class="n">negativeArea</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Negative component areas exist on </span><span class="si">{}</span><span class="s2">. Check that the cold dimensions are properly aligned &quot;</span>
                <span class="s2">&quot;and no components overlap.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">innerCladdingArea</span> <span class="o">+=</span> <span class="n">negativeArea</span>  <span class="c1"># See note 2</span>
        <span class="n">totalMovableArea</span> <span class="o">=</span> <span class="n">innerCladdingArea</span> <span class="o">-</span> <span class="n">unmovableComponentArea</span>
        <span class="n">smearDensity</span> <span class="o">=</span> <span class="n">fuelComponentArea</span> <span class="o">/</span> <span class="n">totalMovableArea</span>

        <span class="k">return</span> <span class="n">smearDensity</span></div>

<div class="viewcode-block" id="Block.autoCreateSpatialGrids"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.autoCreateSpatialGrids">[docs]</a>    <span class="k">def</span> <span class="nf">autoCreateSpatialGrids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a spatialGrid for a Block.</span>

<span class="sd">        Blocks do not always have a spatialGrid from Blueprints, but, some Blocks can have their</span>
<span class="sd">        spatialGrids inferred based on the multiplicty of their components.</span>
<span class="sd">        This would add the ability to create a spatialGrid for a Block and give its children</span>
<span class="sd">        the corresponding spatialLocators if certain conditions are met.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the multiplicities of the block are not only 1 or N or if generated ringNumber leads to more positions than necessary.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.getMgFlux"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getMgFlux">[docs]</a>    <span class="k">def</span> <span class="nf">getMgFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the multigroup neutron flux in [n/cm^2/s]</span>

<span class="sd">        The first entry is the first energy group (fastest neutrons). Each additional</span>
<span class="sd">        group is the next energy group, as set in the ISOTXS library.</span>

<span class="sd">        It is stored integrated over volume on self.p.mgFlux</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adjoint : bool, optional</span>
<span class="sd">            Return adjoint flux instead of real</span>

<span class="sd">        average : bool, optional</span>
<span class="sd">            If true, will return average flux between latest and previous. Doesn&#39;t work</span>
<span class="sd">            for pin detailed yet</span>

<span class="sd">        volume: float, optional</span>
<span class="sd">            If average=True, the volume-integrated flux is divided by volume before being returned.</span>
<span class="sd">            The user may specify a volume here, or the function will obtain the block volume directly.</span>

<span class="sd">        gamma : bool, optional</span>
<span class="sd">            Whether to return the neutron flux or the gamma flux.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        flux : multigroup neutron flux in [n/cm^2/s]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">composites</span><span class="o">.</span><span class="n">ArmiObject</span><span class="o">.</span><span class="n">getMgFlux</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="n">adjoint</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">average</span> <span class="ow">and</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">lastMgFlux</span><span class="p">):</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>
            <span class="n">lastFlux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">lastMgFlux</span> <span class="o">/</span> <span class="n">volume</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="p">(</span><span class="n">flux</span> <span class="o">+</span> <span class="n">lastFlux</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">return</span> <span class="n">flux</span></div>

<div class="viewcode-block" id="Block.setPinMgFluxes"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setPinMgFluxes">[docs]</a>    <span class="k">def</span> <span class="nf">setPinMgFluxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fluxes</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the pin-detailed multi-group neutron flux</span>

<span class="sd">        The [g][i] indexing is transposed to be a list of lists, one for each pin. This makes it</span>
<span class="sd">        simple to do depletion for each pin, etc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fluxes : 2-D list of floats</span>
<span class="sd">            The block-level pin multigroup fluxes. fluxes[g][i] represents the flux in group g for pin i.</span>
<span class="sd">            Flux units are the standard n/cm^2/s.</span>
<span class="sd">            The &quot;ARMI pin ordering&quot; is used, which is counter-clockwise from 3 o&#39;clock.</span>
<span class="sd">        adjoint : bool, optional</span>
<span class="sd">            Whether to set real or adjoint data.</span>
<span class="sd">        gamma : bool, optional</span>
<span class="sd">            Whether to set gamma or neutron data.</span>

<span class="sd">        Outputs</span>
<span class="sd">        -------</span>
<span class="sd">        self.p.pinMgFluxes : 2-D array of floats</span>
<span class="sd">            The block-level pin multigroup fluxes. pinMgFluxes[g][i] represents the flux in group g for pin i.</span>
<span class="sd">            Flux units are the standard n/cm^2/s.</span>
<span class="sd">            The &quot;ARMI pin ordering&quot; is used, which is counter-clockwise from 3 o&#39;clock.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pinFluxes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">G</span><span class="p">,</span> <span class="n">nPins</span> <span class="o">=</span> <span class="n">fluxes</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">for</span> <span class="n">pinNum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nPins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">thisPinFlux</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">):</span>
                <span class="n">pinLoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinLocation</span><span class="p">[</span><span class="n">pinNum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pinLoc</span> <span class="o">=</span> <span class="n">pinNum</span>

            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
                <span class="n">thisPinFlux</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fluxes</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">pinLoc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">pinFluxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisPinFlux</span><span class="p">)</span>

        <span class="n">pinFluxes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pinFluxes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gamma</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">adjoint</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Adjoint gamma flux is currently unsupported.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinMgFluxesGamma</span> <span class="o">=</span> <span class="n">pinFluxes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">adjoint</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinMgFluxesAdj</span> <span class="o">=</span> <span class="n">pinFluxes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinMgFluxes</span> <span class="o">=</span> <span class="n">pinFluxes</span></div>

<div class="viewcode-block" id="Block.getMicroSuffix"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getMicroSuffix">[docs]</a>    <span class="k">def</span> <span class="nf">getMicroSuffix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the microscopic library suffix (e.g. &#39;AB&#39;) for this block.</span>

<span class="sd">        DIF3D and MC2 are limited to 6 character nuclide labels. ARMI by convention uses</span>
<span class="sd">        the first 4 for nuclide name (e.g. U235, PU39, etc.) and then uses the 5th</span>
<span class="sd">        character for cross-section type and the 6th for burnup group. This allows a</span>
<span class="sd">        variety of XS sets to be built modeling substantially different blocks.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The single-letter use for xsType and buGroup limit users to 26 groups of each.</span>
<span class="sd">        ARMI will allow 2-letter xsType designations if and only if the `buGroups`</span>
<span class="sd">        setting has length 1 (i.e. no burnup groups are defined). This is useful for</span>
<span class="sd">        high-fidelity XS modeling of V&amp;V models such as the ZPPRs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buGroup</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bu</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get MicroXS suffix because </span><span class="si">{0}</span><span class="s2"> in </span><span class="si">{1}</span><span class="s2"> does not have a burnup group&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">xsType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">xsType</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xsType</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">getMasterCs</span><span class="p">()[</span><span class="s2">&quot;buGroups&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xsType</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xsType</span> <span class="o">+</span> <span class="n">bu</span></div>

<div class="viewcode-block" id="Block.getHeight"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getHeight">[docs]</a>    <span class="k">def</span> <span class="nf">getHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the block height.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">height</span></div>

<div class="viewcode-block" id="Block.setHeight"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setHeight">[docs]</a>    <span class="k">def</span> <span class="nf">setHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modifiedHeight</span><span class="p">,</span> <span class="n">conserveMass</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">adjustList</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a new height of the block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        modifiedHeight : float</span>
<span class="sd">            The height of the block in cm</span>

<span class="sd">        conserveMass : bool, optional</span>
<span class="sd">            Conserve mass of nuclides in ``adjustList``.</span>

<span class="sd">        adjustList : list, optional</span>
<span class="sd">            Nuclides that will be conserved in conserving mass in the block. It is recommended to pass a list of</span>
<span class="sd">            all nuclides in the block.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        There is a coupling between block heights, the parent assembly axial mesh,</span>
<span class="sd">        and the ztop/zbottom/z params of the sibling blocks. When you set a height,</span>
<span class="sd">        all those things are invalidated. Thus, this method has to go through and</span>
<span class="sd">        update them via ``parent.calculateZCoords``. This could be inefficient</span>
<span class="sd">        though it has not been identified as a bottleneck. Possible improvements</span>
<span class="sd">        include deriving z/ztop/zbottom on the fly and invalidating the parent mesh</span>
<span class="sd">        with some kind of flag, signaling it to recompute itself on demand.</span>
<span class="sd">        Developers can get around some of the O(N^2) scaling of this by setting</span>
<span class="sd">        ``p.height`` directly but they must know to update the dependent objects</span>
<span class="sd">        after they do that. Use with care.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.reactors.Core.updateAxialMesh</span>
<span class="sd">            May need to be called after this.</span>
<span class="sd">        armi.reactor.assemblies.Assembly.calculateZCoords</span>
<span class="sd">            Recalculates z-coords, automatically called by this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">originalHeight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>  <span class="c1"># get before modifying</span>
        <span class="k">if</span> <span class="n">modifiedHeight</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot set height of block </span><span class="si">{}</span><span class="s2"> to height of </span><span class="si">{}</span><span class="s2"> cm&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">modifiedHeight</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">modifiedHeight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">conserveMass</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">originalHeight</span> <span class="o">!=</span> <span class="n">modifiedHeight</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">adjustList</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Nuclides in ``adjustList`` must be provided to conserve mass.&quot;</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">adjustDensity</span><span class="p">(</span><span class="n">originalHeight</span> <span class="o">/</span> <span class="n">modifiedHeight</span><span class="p">,</span> <span class="n">adjustList</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">calculateZCoords</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.getWettedPerimeter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getWettedPerimeter">[docs]</a>    <span class="k">def</span> <span class="nf">getWettedPerimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Block.getFlowAreaPerPin"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getFlowAreaPerPin">[docs]</a>    <span class="k">def</span> <span class="nf">getFlowAreaPerPin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the flowing coolant area in cm^2.</span>

<span class="sd">        NumPins looks for max number of fuel, clad, control, etc.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.blocks.Block.getNumPins</span>
<span class="sd">            figures out numPins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">COOLANT</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">getArea</span><span class="p">()</span> <span class="o">/</span> <span class="n">numPins</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span>
                <span class="s2">&quot;Block </span><span class="si">{}</span><span class="s2"> has 0 pins (fuel, clad, control, shield, etc.). Thus, its flow area &quot;</span>
                <span class="s2">&quot;per pin is undefined.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Block.getHydraulicDiameter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getHydraulicDiameter">[docs]</a>    <span class="k">def</span> <span class="nf">getHydraulicDiameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Block.adjustUEnrich"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.adjustUEnrich">[docs]</a>    <span class="k">def</span> <span class="nf">adjustUEnrich</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newEnrich</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust U-235/U-238 mass ratio to a mass enrichment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newEnrich : float</span>
<span class="sd">            New U-235 enrichment in mass fraction</span>

<span class="sd">        completeInitialLoading must be run because adjusting the enrichment actually</span>
<span class="sd">        changes the mass slightly and you can get negative burnups, which you do not want.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fuels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fuels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fuel</span> <span class="ow">in</span> <span class="n">fuels</span><span class="p">:</span>
                <span class="n">fuel</span><span class="o">.</span><span class="n">adjustMassEnrichment</span><span class="p">(</span><span class="n">newEnrich</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no fuel in this block</span>
            <span class="n">tU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensity</span><span class="p">(</span><span class="s2">&quot;U235&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensity</span><span class="p">(</span><span class="s2">&quot;U238&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tU</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setNumberDensity</span><span class="p">(</span><span class="s2">&quot;U235&quot;</span><span class="p">,</span> <span class="n">tU</span> <span class="o">*</span> <span class="n">newEnrich</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setNumberDensity</span><span class="p">(</span><span class="s2">&quot;U238&quot;</span><span class="p">,</span> <span class="n">tU</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">newEnrich</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">completeInitialLoading</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.getLocation"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getLocation">[docs]</a>    <span class="k">def</span> <span class="nf">getLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string representation of the location.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getLabel</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;ExCore&quot;</span></div>

<div class="viewcode-block" id="Block.coords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotationDegreesCCW</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rotationDegreesCCW</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot get coordinates with rotation.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.setBuLimitInfo"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setBuLimitInfo">[docs]</a>    <span class="k">def</span> <span class="nf">setBuLimitInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Sets burnup limit based on igniter, feed, etc.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buRate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># might be cycle 1 or a non-burning block</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">timeToLimit</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">timeLimit</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buLimit</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBu</span>
            <span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buRate</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">residence</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">timeToLimit</span> <span class="o">=</span> <span class="p">(</span><span class="n">timeLimit</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">residence</span><span class="p">)</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">DAYS_PER_YEAR</span></div>

<div class="viewcode-block" id="Block.getMaxArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getMaxArea">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Block.getMaxVolume"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getMaxVolume">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxVolume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum volume of this object if it were totally full.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vol : float</span>
<span class="sd">            volume in cm^3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxArea</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.getArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getArea">[docs]</a>    <span class="k">def</span> <span class="nf">getArea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the area of a block for a full core or a 1/3 core model.</span>

<span class="sd">        Area is consistent with the area in the model, so if you have a central</span>
<span class="sd">        assembly in a 1/3 symmetric model, this will return 1/3 of the total</span>
<span class="sd">        area of the physical assembly. This way, if you take the sum</span>
<span class="sd">        of the areas in the core (or count the atoms in the core, etc.),</span>
<span class="sd">        you will have the proper number after multiplying by the model symmetry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cold : bool</span>
<span class="sd">            flag to indicate that cold (as input) dimensions are required</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This might not work for a 1/6 core model (due to symmetry line issues).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        area : float (cm^2)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.blocks.Block.getMaxArea</span>
<span class="sd">            return the full area of the physical assembly disregarding model symmetry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this caching requires that you clear the cache every time you adjust anything</span>
        <span class="c1"># including temperature and dimensions.</span>
        <span class="n">area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getCached</span><span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">area</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">area</span>

        <span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
            <span class="n">myArea</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getArea</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">+=</span> <span class="n">myArea</span>
        <span class="n">fullArea</span> <span class="o">=</span> <span class="n">a</span>

        <span class="c1"># correct the fullHexArea by the symmetry factor</span>
        <span class="c1"># this factor determines if the hex has been clipped by symmetry lines</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">fullArea</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSymmetryFactor</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_setCache</span><span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">,</span> <span class="n">area</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">area</span></div>

<div class="viewcode-block" id="Block.getVolume"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getVolume">[docs]</a>    <span class="k">def</span> <span class="nf">getVolume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the volume of a block.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        volume : float</span>
<span class="sd">            Block or component volume in cm^3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use symmetryFactor in case the assembly is sitting on a boundary and needs to be cut in half, etc.</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vol</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSymmetryFactor</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.getSymmetryFactor"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getSymmetryFactor">[docs]</a>    <span class="k">def</span> <span class="nf">getSymmetryFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a scaling factor due to symmetry on the area of the block or its components.</span>

<span class="sd">        Takes into account assemblies that are bisected or trisected by symmetry lines</span>

<span class="sd">        In 1/3 symmetric cases, the central assembly is 1/3 a full area.</span>
<span class="sd">        If edge assemblies are included in a model, the symmetry factor along</span>
<span class="sd">        both edges for overhanging assemblies should be 2.0. However,</span>
<span class="sd">        ARMI runs in most scenarios with those assemblies on the 120-edge removed,</span>
<span class="sd">        so the symmetry factor should generally be just 1.0.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.converters.geometryConverter.EdgeAssemblyChanger.scaleParamsRelatedToSymmetry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.0</span></div>

<div class="viewcode-block" id="Block.isOnWhichSymmetryLine"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.isOnWhichSymmetryLine">[docs]</a>    <span class="k">def</span> <span class="nf">isOnWhichSymmetryLine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Block symmetry lines are determined by the reactor, not the parent.&quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span>
        <span class="k">return</span> <span class="n">grid</span><span class="o">.</span><span class="n">overlapsWhichSymmetryLine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">())</span></div>

<div class="viewcode-block" id="Block.adjustDensity"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.adjustDensity">[docs]</a>    <span class="k">def</span> <span class="nf">adjustDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">adjustList</span><span class="p">,</span> <span class="n">returnMass</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        adjusts the total density of each nuclide in adjustList by frac.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frac : float</span>
<span class="sd">            The fraction of the current density that will remain after this operation</span>

<span class="sd">        adjustList : list</span>
<span class="sd">            List of nuclide names that will be adjusted.</span>

<span class="sd">        returnMass : bool</span>
<span class="sd">            If true, will return mass difference.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">             mass : float</span>
<span class="sd">            Mass difference in grams. If you subtract mass, mass will be negative.</span>
<span class="sd">            If returnMass is False (default), this will always be zero.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updateDetailedNdens</span><span class="p">(</span><span class="n">frac</span><span class="p">,</span> <span class="n">adjustList</span><span class="p">)</span>

        <span class="n">mass</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">returnMass</span><span class="p">:</span>
            <span class="c1"># do this with a flag to enable faster operation when mass is not needed.</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>

        <span class="n">numDensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNuclideNumberDensities</span><span class="p">(</span><span class="n">adjustList</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nuclideName</span><span class="p">,</span> <span class="n">dens</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">adjustList</span><span class="p">,</span> <span class="n">numDensities</span><span class="p">):</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">dens</span><span class="p">:</span>
                <span class="c1"># don&#39;t modify zeros.</span>
                <span class="k">continue</span>
            <span class="n">newDens</span> <span class="o">=</span> <span class="n">dens</span> <span class="o">*</span> <span class="n">frac</span>
            <span class="c1"># add a little so components remember</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setNumberDensity</span><span class="p">(</span><span class="n">nuclideName</span><span class="p">,</span> <span class="n">newDens</span> <span class="o">+</span> <span class="n">TRACE_NUMBER_DENSITY</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">returnMass</span><span class="p">:</span>
                <span class="n">mass</span> <span class="o">+=</span> <span class="n">densityTools</span><span class="o">.</span><span class="n">getMassInGrams</span><span class="p">(</span><span class="n">nuclideName</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">newDens</span> <span class="o">-</span> <span class="n">dens</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mass</span></div>

    <span class="k">def</span> <span class="nf">_updateDetailedNdens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">adjustList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update detailed number density which is used by hi-fi depleters such as ORIGEN.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This will perturb all number densities so it is assumed that if one of the active densities</span>
<span class="sd">        is perturbed, all of htem are perturbed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">detailedNDens</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># BOL assems get expanded to a reference so the first check is needed so it</span>
            <span class="c1"># won&#39;t call .blueprints on None since BOL assems don&#39;t have a core/r</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">nuc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">blueprints</span><span class="o">.</span><span class="n">activeNuclides</span> <span class="k">for</span> <span class="n">nuc</span> <span class="ow">in</span> <span class="n">adjustList</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">detailedNDens</span> <span class="o">*=</span> <span class="n">frac</span>
            <span class="c1"># Other power densities do not need to be updated as they are calculated in</span>
            <span class="c1"># the global flux interface, which occurs after axial expansion from crucible</span>
            <span class="c1"># on the interface stack.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pdensDecay</span> <span class="o">*=</span> <span class="n">frac</span>

<div class="viewcode-block" id="Block.completeInitialLoading"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.completeInitialLoading">[docs]</a>    <span class="k">def</span> <span class="nf">completeInitialLoading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bolBlock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does some BOL bookkeeping to track things like BOL HM density for burnup tracking.</span>

<span class="sd">        This should run after this block is loaded up at BOC (called from</span>
<span class="sd">        Reactor.initialLoading).</span>

<span class="sd">        The original purpose of this was to get the moles HM at BOC for the moles</span>
<span class="sd">        Pu/moles HM at BOL calculation.</span>

<span class="sd">        This also must be called after modifying something like the smear density or zr</span>
<span class="sd">        fraction in an optimization case. In ECPT cases, a BOL block must be passed or</span>
<span class="sd">        else the burnup will try to get based on a pre-burned value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bolBlock : Block, optional</span>
<span class="sd">            A BOL-state block of this block type, required for perturbed equilibrium cases.</span>
<span class="sd">            Must have the same enrichment as this block!</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hmDens : float</span>
<span class="sd">            The heavy metal number density of this block.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Reactor.importGeom</span>
<span class="sd">        depletion._updateBlockParametersAfterDepletion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bolBlock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bolBlock</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">hmDens</span> <span class="o">=</span> <span class="n">bolBlock</span><span class="o">.</span><span class="n">getHMDens</span><span class="p">()</span>  <span class="c1"># total homogenized heavy metal number density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHMMoles</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">nHMAtBOL</span> <span class="o">=</span> <span class="n">hmDens</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># non-pinned reactors (or ones without cladding) will not use smear density</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">smearDensity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSmearDensity</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">enrichmentBOL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFissileMassEnrich</span><span class="p">()</span>
        <span class="n">massHmBOL</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSymmetryFactor</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">():</span>
            <span class="n">child</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">massHmBOL</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">getHMMass</span><span class="p">()</span> <span class="o">*</span> <span class="n">sf</span>  <span class="c1"># scale to full block</span>
            <span class="n">massHmBOL</span> <span class="o">+=</span> <span class="n">child</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">massHmBOL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">massHmBOL</span> <span class="o">=</span> <span class="n">massHmBOL</span>
        <span class="k">return</span> <span class="n">hmDens</span></div>

<div class="viewcode-block" id="Block.replaceBlockWithBlock"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.replaceBlockWithBlock">[docs]</a>    <span class="k">def</span> <span class="nf">replaceBlockWithBlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bReplacement</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace the current block with the replacementBlock.</span>

<span class="sd">        Typically used in the insertion of control rods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paramsToSkip</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="o">.</span><span class="n">inCategory</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">Category</span><span class="o">.</span><span class="n">retainOnReplacement</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>
        <span class="p">)</span>

        <span class="n">tempBlock</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">bReplacement</span><span class="p">)</span>
        <span class="n">oldParams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">newParams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">tempBlock</span><span class="o">.</span><span class="n">p</span>
        <span class="k">for</span> <span class="n">paramName</span> <span class="ow">in</span> <span class="n">paramsToSkip</span><span class="p">:</span>
            <span class="n">newParams</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldParams</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span>

        <span class="c1"># update synchronization information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assigned</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span>
        <span class="n">paramDefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span>
        <span class="k">for</span> <span class="n">paramName</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">newParams</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="n">paramsToSkip</span><span class="p">:</span>
            <span class="n">paramDefs</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span><span class="o">.</span><span class="n">assigned</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span>

        <span class="n">newComponents</span> <span class="o">=</span> <span class="n">tempBlock</span><span class="o">.</span><span class="n">getChildren</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setChildren</span><span class="p">(</span><span class="n">newComponents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.plotFlux"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.plotFlux">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">plotFlux</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="n">fName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bList2</span><span class="o">=</span><span class="p">[]):</span>
        <span class="c1"># Block.plotFlux has been moved to utils.plotting as plotBlockFlux, which is a</span>
        <span class="c1"># better fit.</span>
        <span class="c1"># We don&#39;t want to remove the plotFlux function in the Block namespace yet</span>
        <span class="c1"># in case client code is depending on this function existing here. This is just</span>
        <span class="c1"># a simple pass-through function that passes the arguments along to the actual</span>
        <span class="c1"># implementation in its new location.</span>
        <span class="n">plotBlockFlux</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="n">fName</span><span class="p">,</span> <span class="n">bList</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">adjoint</span><span class="p">,</span> <span class="n">bList2</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_updatePitchComponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the component that defines the pitch.</span>

<span class="sd">        Given a Component, compare it to the current component that defines the pitch of the Block.</span>
<span class="sd">        If bigger, replace it.</span>
<span class="sd">        We need different implementations of this to support different logic for determining the</span>
<span class="sd">        form of pitch and the concept of &quot;larger&quot;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        CartesianBlock._updatePitchComponent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Some block types don&#39;t have a clearly defined pitch (e.g. ThRZ)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">PITCH_COMPONENT_TYPE</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PITCH_COMPONENT_TYPE</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">componentPitch</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PITCH_DIMENSION</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">parameters</span><span class="o">.</span><span class="n">UnknownParameterError</span><span class="p">:</span>
            <span class="c1"># some components dont have the appropriate parameter</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">componentPitch</span> <span class="ow">and</span> <span class="p">(</span><span class="n">componentPitch</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">componentPitch</span><span class="p">)</span>

<div class="viewcode-block" id="Block.add"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">derivedMustUpdate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBuByPin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBuByPin</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mult</span><span class="p">:</span>
                <span class="c1"># this may be a little wasteful, but we can fix it later...</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBuByPin</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mult</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># maybe adding a Composite of components rather than a single</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updatePitchComponent</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>

<div class="viewcode-block" id="Block.removeAll"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.removeAll">[docs]</a>    <span class="k">def</span> <span class="nf">removeAll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recomputeAreaFractions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">recomputeAreaFractions</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">recomputeAreaFractions</span><span class="p">:</span>  <span class="c1"># only do this once</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeFractions</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.remove"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">recomputeAreaFractions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLargestComponent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PITCH_DIMENSION</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_updatePitchComponent</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">recomputeAreaFractions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeFractions</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.getComponentsThatAreLinkedTo"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getComponentsThatAreLinkedTo">[docs]</a>    <span class="k">def</span> <span class="nf">getComponentsThatAreLinkedTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine which dimensions of which components are linked to a specific dimension of a particular component.</span>

<span class="sd">        Useful for breaking fuel components up into individuals and making sure</span>
<span class="sd">        anything that was linked to the fuel mult (like the cladding mult) stays correct.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        comp : Component</span>
<span class="sd">            The component that the results are linked to</span>
<span class="sd">        dim : str</span>
<span class="sd">            The name of the dimension that the results are linked to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        linkedComps : list</span>
<span class="sd">            A list of (components,dimName) that are linked to this component, dim.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">linked</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">dimName</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">dimensionIsLinked</span><span class="p">(</span><span class="n">dimName</span><span class="p">):</span>
                    <span class="n">requiredComponent</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">requiredComponent</span> <span class="ow">is</span> <span class="n">comp</span> <span class="ow">and</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="n">linked</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">dimName</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">linked</span></div>

<div class="viewcode-block" id="Block.getComponentsInLinkedOrder"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getComponentsInLinkedOrder">[docs]</a>    <span class="k">def</span> <span class="nf">getComponentsInLinkedOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">componentList</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of the components in order of their linked-dimension dependencies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        components : list, optional</span>
<span class="sd">            A list of components to consider. If None, this block&#39;s components will be used.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This means that components other components are linked to come first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">componentList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">componentList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">()</span>
        <span class="n">cList</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">componentList</span><span class="p">)</span>
        <span class="n">orderedComponents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Loop through the components until there are none left.</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">cList</span><span class="p">:</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">cList</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>  <span class="c1"># take first item in list</span>
            <span class="n">cleared</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># innocent until proven guilty</span>
            <span class="c1"># loop through all dimensions in this component to determine its dependencies</span>
            <span class="k">for</span> <span class="n">dimName</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">candidate</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">candidate</span><span class="o">.</span><span class="n">dimensionIsLinked</span><span class="p">(</span><span class="n">dimName</span><span class="p">):</span>
                    <span class="c1"># In linked dimensions, val = (component, dimName)</span>
                    <span class="n">requiredComponent</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">requiredComponent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">orderedComponents</span><span class="p">:</span>
                        <span class="c1"># this component depends on one that is not in the ordered list yet.</span>
                        <span class="c1"># do not add it.</span>
                        <span class="n">cleared</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>  <span class="c1"># short circuit. One failed lookup is enough to flag this component as dirty.</span>
            <span class="k">if</span> <span class="n">cleared</span><span class="p">:</span>
                <span class="c1"># this candidate is free of dependencies and is ready to be added.</span>
                <span class="n">orderedComponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">counter</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">cList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;The component </span><span class="si">{0}</span><span class="s2"> in </span><span class="si">{1}</span><span class="s2"> contains a dimension that is linked to another component, &quot;</span>
                    <span class="s2">&quot; but the required component is not present in the block. They may also be other dependency fails. &quot;</span>
                    <span class="s2">&quot;The component dims are </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">,</span> <span class="n">cList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot locate linked component.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orderedComponents</span></div>

<div class="viewcode-block" id="Block.getSortedComponentsInsideOfComponent"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getSortedComponentsInsideOfComponent">[docs]</a>    <span class="k">def</span> <span class="nf">getSortedComponentsInsideOfComponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of components inside of the given component sorted from innermost to outermost.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        component : object</span>
<span class="sd">            Component to look inside of.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you just want sorted components in this block, use ``sorted(self)``.</span>
<span class="sd">        This will never include any ``DerivedShape`` objects. Since they have a derived</span>
<span class="sd">        area they don&#39;t have a well-defined dimension. For now we just ignore them.</span>
<span class="sd">        If they are desired in the future some knowledge of their dimension will be</span>
<span class="sd">        required while they are being derived.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sortedComponents</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">componentIndex</span> <span class="o">=</span> <span class="n">sortedComponents</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
        <span class="n">sortedComponents</span> <span class="o">=</span> <span class="n">sortedComponents</span><span class="p">[:</span><span class="n">componentIndex</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sortedComponents</span></div>

<div class="viewcode-block" id="Block.getNumPins"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getNumPins">[docs]</a>    <span class="k">def</span> <span class="nf">getNumPins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of pins in this block.&quot;&quot;&quot;</span>
        <span class="n">nPins</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">getNumComponents</span><span class="p">(</span><span class="n">compType</span><span class="p">)</span> <span class="k">for</span> <span class="n">compType</span> <span class="ow">in</span> <span class="n">PIN_COMPONENTS</span><span class="p">]</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">nPins</span> <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="n">nPins</span><span class="p">)</span></div>

<div class="viewcode-block" id="Block.mergeWithBlock"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.mergeWithBlock">[docs]</a>    <span class="k">def</span> <span class="nf">mergeWithBlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">otherBlock</span><span class="p">,</span> <span class="n">fraction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turns this block into a mixture of this block and some other block</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        otherBlock : Block</span>
<span class="sd">            The block to mix this block with. The other block will not be modified.</span>

<span class="sd">        fraction : float</span>
<span class="sd">            Fraction of the other block to mix in with this block. If 0.1 is passed in, this block</span>
<span class="sd">            will become 90% what it originally was and 10% what the other block is.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This merges on a high level (using number densities). Components will not be merged.</span>

<span class="sd">        This is used e.g. for inserting a control block partially to get a very tight criticality</span>
<span class="sd">        control.  In this case, a control block would be merged with a duct block. It is also used</span>
<span class="sd">        when a control rod is specified as a certain length but that length does not fit exactly</span>
<span class="sd">        into a full block.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">numDensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">()</span>
        <span class="n">otherBlockDensities</span> <span class="o">=</span> <span class="n">otherBlock</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">()</span>
        <span class="n">newDensities</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Make sure to hit all nuclides in union of blocks</span>
        <span class="k">for</span> <span class="n">nucName</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">numDensities</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">otherBlockDensities</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">newDensities</span><span class="p">[</span><span class="n">nucName</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">fraction</span><span class="p">)</span> <span class="o">*</span> <span class="n">numDensities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">nucName</span><span class="p">,</span> <span class="mf">0.0</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">fraction</span> <span class="o">*</span> <span class="n">otherBlockDensities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">nucName</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setNumberDensities</span><span class="p">(</span><span class="n">newDensities</span><span class="p">)</span></div>

<div class="viewcode-block" id="Block.getComponentAreaFrac"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getComponentAreaFrac">[docs]</a>    <span class="k">def</span> <span class="nf">getComponentAreaFrac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the area fraction of the specified component(s) among all components in the block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or list of Flags</span>
<span class="sd">            Component types to look up</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>
<span class="sd">        &gt;&gt;&gt; b.getComponentAreaFrac(Flags.CLAD)</span>
<span class="sd">        0.15</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The area fraction of the component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tFrac</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeFractions</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">tFrac</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tFrac</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No component </span><span class="si">{0}</span><span class="s2"> exists on </span><span class="si">{1}</span><span class="s2">, so area fraction is zero.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">typeSpec</span><span class="p">,</span> <span class="bp">self</span>
                <span class="p">),</span>
                <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> areaFrac is zero&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="mf">0.0</span></div>

<div class="viewcode-block" id="Block.verifyBlockDims"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.verifyBlockDims">[docs]</a>    <span class="k">def</span> <span class="nf">verifyBlockDims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optional dimension checking.&quot;&quot;&quot;</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Block.getDim"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getDim">[docs]</a>    <span class="k">def</span> <span class="nf">getDim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">dimName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search through blocks in this assembly and find the first component of compName.</span>
<span class="sd">        Then, look on that component for dimName.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or list of Flags</span>
<span class="sd">            Component name, e.g. Flags.FUEL, Flags.CLAD, Flags.COOLANT, ...</span>
<span class="sd">        dimName : str</span>
<span class="sd">            Dimension name, e.g. &#39;od&#39;, ...</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dimVal : float</span>
<span class="sd">            The dimension in cm.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; getDim(Flags.WIRE,&#39;od&#39;)</span>
<span class="sd">        0.01</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="n">dimName</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot get Dimension because Flag not found: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Block.getPinCenterFlatToFlat"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPinCenterFlatToFlat">[docs]</a>    <span class="k">def</span> <span class="nf">getPinCenterFlatToFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the flat-to-flat distance between the centers of opposing pins in the outermost ring.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>  <span class="c1"># no geometry can be assumed</span></div>

<div class="viewcode-block" id="Block.getWireWrapCladGap"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getWireWrapCladGap">[docs]</a>    <span class="k">def</span> <span class="nf">getWireWrapCladGap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the gap betwen the wire wrap and the clad.&quot;&quot;&quot;</span>
        <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="n">wire</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span>
        <span class="n">wireOuterRadius</span> <span class="o">=</span> <span class="n">wire</span><span class="o">.</span><span class="n">getBoundingCircleOuterDiameter</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">wireInnerRadius</span> <span class="o">=</span> <span class="n">wireOuterRadius</span> <span class="o">-</span> <span class="n">wire</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="n">cladOuterRadius</span> <span class="o">=</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">return</span> <span class="n">wireInnerRadius</span> <span class="o">-</span> <span class="n">cladOuterRadius</span></div>

<div class="viewcode-block" id="Block.getPlenumPin"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPlenumPin">[docs]</a>    <span class="k">def</span> <span class="nf">getPlenumPin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the plenum pin if it exists.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">GAP</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isPlenumPin</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">c</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Block.isPlenumPin"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.isPlenumPin">[docs]</a>    <span class="k">def</span> <span class="nf">isPlenumPin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the specified component is a plenum pin.&quot;&quot;&quot;</span>
        <span class="c1"># This assumes that anything with the GAP flag will have a valid &#39;id&#39; dimension. If that</span>
        <span class="c1"># were not the case, then we would need to protect the call to getDimension with a</span>
        <span class="c1"># try/except</span>
        <span class="n">cIsCenterGapGap</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">components</span><span class="o">.</span><span class="n">Component</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">GAP</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">([</span><span class="n">Flags</span><span class="o">.</span><span class="n">PLENUM</span><span class="p">,</span> <span class="n">Flags</span><span class="o">.</span><span class="n">ACLP</span><span class="p">])</span> <span class="ow">and</span> <span class="n">cIsCenterGapGap</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Block.getPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPitch">[docs]</a>    <span class="k">def</span> <span class="nf">getPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">returnComp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the center-to-center hex pitch of this block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        returnComp : bool, optional</span>
<span class="sd">            If true, will return the component that has the maximum pitch as well</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pitch : float or None</span>
<span class="sd">            Hex pitch in cm, if well-defined. If there is no clear component for determining pitch,</span>
<span class="sd">            returns None</span>
<span class="sd">        component : Component or None</span>
<span class="sd">            Component that has the max pitch, if returnComp == True. If no component is found to</span>
<span class="sd">            define the pitch, returns None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The block stores a reference to the component that defines the pitch, making the assumption</span>
<span class="sd">        that while the dimensions can change, the component containing the largest dimension will</span>
<span class="sd">        not. This lets us skip the search for largest component. We still need to ask the largest</span>
<span class="sd">        component for its current dimension in case its temperature changed, or was otherwise</span>
<span class="sd">        modified.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        setPitch : sets pitch</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> has no valid pitch defining component&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># ask component for dimensions, since they could have changed,</span>
        <span class="c1"># due to temperature, for example.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getPitchData</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="n">returnComp</span> <span class="k">else</span> <span class="n">p</span></div>

<div class="viewcode-block" id="Block.hasPinPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.hasPinPitch">[docs]</a>    <span class="k">def</span> <span class="nf">hasPinPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the block has enough information to calculate pin pitch.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Block.getPinPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPinPitch">[docs]</a>    <span class="k">def</span> <span class="nf">getPinPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return sub-block pitch in blocks.</span>

<span class="sd">        This assumes the spatial grid is defined by unit steps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">pitch</span></div>

<div class="viewcode-block" id="Block.getDimensions"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getDimensions">[docs]</a>    <span class="k">def</span> <span class="nf">getDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return dimensional values of the specified dimension.&quot;&quot;&quot;</span>
        <span class="n">dimVals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dimVal</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">parameters</span><span class="o">.</span><span class="n">ParameterError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">dimVal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dimVals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dimVal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dimVals</span></div>

<div class="viewcode-block" id="Block.getLargestComponent"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getLargestComponent">[docs]</a>    <span class="k">def</span> <span class="nf">getLargestComponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the component with the largest dimension of the specified type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dimension: str</span>
<span class="sd">            The name of the dimension to find the largest component of.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        largestComponent: armi.reactor.components.Component</span>
<span class="sd">            The component with the largest dimension of the specified type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">maxDim</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">largestComponent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dimVal</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">parameters</span><span class="o">.</span><span class="n">ParameterError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">dimVal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dimVal</span> <span class="o">&gt;</span> <span class="n">maxDim</span><span class="p">:</span>
                <span class="n">maxDim</span> <span class="o">=</span> <span class="n">dimVal</span>
                <span class="n">largestComponent</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">return</span> <span class="n">largestComponent</span></div>

<div class="viewcode-block" id="Block.setPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setPitch">[docs]</a>    <span class="k">def</span> <span class="nf">setPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">updateBolParams</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets outer pitch to some new value.</span>

<span class="sd">        This sets the settingPitch and actually sets the dimension of the outer hexagon.</span>

<span class="sd">        During a load (importGeom), the setDimension doesn&#39;t usually do anything except</span>
<span class="sd">        set the setting See Issue 034</span>

<span class="sd">        But during a actual case modification (e.g. in an optimization sweep, then the dimension</span>
<span class="sd">        has to be set as well.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getPitch : gets the pitch</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">setDimension</span><span class="p">(</span><span class="s2">&quot;op&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No pitch-defining component on block </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">updateBolParams</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">completeInitialLoading</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.getMfp"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getMfp">[docs]</a>    <span class="k">def</span> <span class="nf">getMfp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the mean free path for neutron or gammas in this block.</span>

<span class="sd">        .. math::</span>

<span class="sd">            &lt;\Sigma&gt; = \frac{\sum_E(\phi_e \Sigma_e dE)}{\sum_E (\phi_e dE)}  =</span>
<span class="sd">            \frac{\sum_E(\phi_e N \sum_{\text{type}}(\sigma_e)  dE}{\sum_E (\phi_e dE))}</span>

<span class="sd">        Block macro is the sum of macros of all nuclides.</span>

<span class="sd">        phi_g = flux*dE already in multigroup method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mfp, mfpAbs, diffusionLength : tuple(float, float float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMgFlux</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">flux</span><span class="p">]</span>
        <span class="n">mfpNumerator</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>
        <span class="n">absMfpNumerator</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>
        <span class="n">transportNumerator</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>

        <span class="n">numDensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">()</span>

        <span class="c1"># vol = self.getVolume()</span>
        <span class="k">for</span> <span class="n">nucName</span><span class="p">,</span> <span class="n">nDen</span> <span class="ow">in</span> <span class="n">numDensities</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">nucMc</span> <span class="o">=</span> <span class="n">nucDir</span><span class="o">.</span><span class="n">getMc2Label</span><span class="p">(</span><span class="n">nucName</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">gamma</span><span class="p">:</span>
                <span class="n">micros</span> <span class="o">=</span> <span class="n">lib</span><span class="p">[</span><span class="n">nucMc</span><span class="p">]</span><span class="o">.</span><span class="n">gammaXS</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">micros</span> <span class="o">=</span> <span class="n">lib</span><span class="p">[</span><span class="n">nucMc</span><span class="p">]</span><span class="o">.</span><span class="n">micros</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">micros</span><span class="o">.</span><span class="n">total</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># 0th order</span>
            <span class="n">transport</span> <span class="o">=</span> <span class="n">micros</span><span class="o">.</span><span class="n">transport</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># 0th order, [bn]</span>
            <span class="n">absorb</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">micros</span><span class="o">.</span><span class="n">getAbsorptionXS</span><span class="p">())</span>
            <span class="n">mfpNumerator</span> <span class="o">+=</span> <span class="n">nDen</span> <span class="o">*</span> <span class="n">total</span>  <span class="c1"># [cm]</span>
            <span class="n">absMfpNumerator</span> <span class="o">+=</span> <span class="n">nDen</span> <span class="o">*</span> <span class="n">absorb</span>
            <span class="n">transportNumerator</span> <span class="o">+=</span> <span class="n">nDen</span> <span class="o">*</span> <span class="n">transport</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
        <span class="n">mfp</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">mfpNumerator</span> <span class="o">*</span> <span class="n">flux</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span><span class="p">)</span>
        <span class="n">sigmaA</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">absMfpNumerator</span> <span class="o">*</span> <span class="n">flux</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="n">sigmaTr</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">transportNumerator</span> <span class="o">*</span> <span class="n">flux</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="n">diffusionCoeff</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">sigmaTr</span><span class="p">)</span>
        <span class="n">mfpAbs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sigmaA</span>
        <span class="n">diffusionLength</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diffusionCoeff</span> <span class="o">/</span> <span class="n">sigmaA</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mfp</span><span class="p">,</span> <span class="n">mfpAbs</span><span class="p">,</span> <span class="n">diffusionLength</span></div>

<div class="viewcode-block" id="Block.setAreaFractionsReport"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setAreaFractionsReport">[docs]</a>    <span class="k">def</span> <span class="nf">setAreaFractionsReport</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">frac</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeFractions</span><span class="p">():</span>
            <span class="n">report</span><span class="o">.</span><span class="n">setData</span><span class="p">(</span>
                <span class="n">c</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span>
                <span class="p">[</span><span class="s2">&quot;</span><span class="si">{0:10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getArea</span><span class="p">()),</span> <span class="s2">&quot;</span><span class="si">{0:10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">frac</span><span class="p">)],</span>
                <span class="n">report</span><span class="o">.</span><span class="n">BLOCK_AREA_FRACS</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># return the group the information went to</span>
        <span class="k">return</span> <span class="n">report</span><span class="o">.</span><span class="n">ALL</span><span class="p">[</span><span class="n">report</span><span class="o">.</span><span class="n">BLOCK_AREA_FRACS</span><span class="p">]</span></div>

<div class="viewcode-block" id="Block.getBurnupPeakingFactor"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getBurnupPeakingFactor">[docs]</a>    <span class="k">def</span> <span class="nf">getBurnupPeakingFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the radial peaking factor to be applied to burnup and DPA</span>

<span class="sd">        This may be informed by previous runs which used</span>
<span class="sd">        detailed pin reconstruction and rotation. In that case,</span>
<span class="sd">        it should be set on the cs setting ``burnupPeakingFactor``.</span>

<span class="sd">        Otherwise, it just takes the current flux peaking, which</span>
<span class="sd">        is typically conservatively high.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        burnupPeakingFactor : float</span>
<span class="sd">            The peak/avg factor for burnup and DPA.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.physics.neutronics.globalFlux.globalFluxInterface.GlobalFluxInterface.updateFluenceAndDPA : uses this</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">burnupPeakingFactor</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">getMasterCs</span><span class="p">()[</span><span class="s2">&quot;burnupPeakingFactor&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">burnupPeakingFactor</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">fluxPeak</span><span class="p">:</span>
            <span class="n">burnupPeakingFactor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">fluxPeak</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flux</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">burnupPeakingFactor</span><span class="p">:</span>
            <span class="c1"># no peak available. Finite difference model?</span>
            <span class="n">burnupPeakingFactor</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">return</span> <span class="n">burnupPeakingFactor</span></div>

<div class="viewcode-block" id="Block.getBlocks"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getBlocks">[docs]</a>    <span class="k">def</span> <span class="nf">getBlocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns all the block(s) included in this block</span>
<span class="sd">        its implemented so that methods could iterate over reactors, assemblies</span>
<span class="sd">        or single blocks without checking to see what the type of the</span>
<span class="sd">        reactor-family object is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span></div>

<div class="viewcode-block" id="Block.updateComponentDims"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.updateComponentDims">[docs]</a>    <span class="k">def</span> <span class="nf">updateComponentDims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method updates all the dimensions of the components</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is VERY useful for defining a ThRZ core out of</span>
<span class="sd">        differentialRadialSegements whose dimensions are connected together</span>
<span class="sd">        some of these dimensions are derivative and can be updated by changing</span>
<span class="sd">        dimensions in a Parameter Component or other linked components</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.components.DifferentialRadialSegment.updateDims</span>
<span class="sd">        armi.reactor.components.Parameters</span>
<span class="sd">        armi.physics.optimize.OptimizationInterface.modifyCase (look up &#39;ThRZReflectorThickness&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponentsInLinkedOrder</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">updateDims</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> has no updatedDims method -- skipping&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">))</span></div>

<div class="viewcode-block" id="Block.getDpaXs"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getDpaXs">[docs]</a>    <span class="k">def</span> <span class="nf">getDpaXs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine which cross sections should be used to compute dpa for this block.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">getMasterCs</span><span class="p">()[</span><span class="s2">&quot;gridPlateDpaXsSet&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">GRID_PLATE</span>
        <span class="p">):</span>
            <span class="n">dpaXsSetName</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">getMasterCs</span><span class="p">()[</span><span class="s2">&quot;gridPlateDpaXsSet&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dpaXsSetName</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">getMasterCs</span><span class="p">()[</span><span class="s2">&quot;dpaXsSet&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dpaXsSetName</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">constants</span><span class="o">.</span><span class="n">DPA_CROSS_SECTIONS</span><span class="p">[</span><span class="n">dpaXsSetName</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;DPA cross section set </span><span class="si">{}</span><span class="s2"> does not exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dpaXsSetName</span><span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Block.breakFuelComponentsIntoIndividuals"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.breakFuelComponentsIntoIndividuals">[docs]</a>    <span class="k">def</span> <span class="nf">breakFuelComponentsIntoIndividuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split block-level components (in fuel blocks) into pin-level components.</span>

<span class="sd">        The fuel component will be broken up according to its multiplicity.</span>

<span class="sd">        Order matters! The first pin component will be located at a particular (x, y), which</span>
<span class="sd">        will be used in the fluxRecon module to determine the interpolated flux.</span>

<span class="sd">        The fuel will become fuel001 through fuel169 if there are 169 pins.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fuels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fuels</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;This block contains </span><span class="si">{0}</span><span class="s2"> fuel components: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fuels</span><span class="p">),</span> <span class="n">fuels</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot break </span><span class="si">{0}</span><span class="s2"> into multiple fuel components b/c there is not a single fuel&quot;</span>
                <span class="s2">&quot; component.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">fuel</span> <span class="o">=</span> <span class="n">fuels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fuelFlags</span> <span class="o">=</span> <span class="n">fuel</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flags</span>
        <span class="n">nPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Creating </span><span class="si">{}</span><span class="s2"> individual </span><span class="si">{}</span><span class="s2"> components on </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nPins</span><span class="p">,</span> <span class="n">fuel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># handle all other components that may be linked to the fuel multiplicity.</span>
        <span class="c1"># by unlinking them and setting them directly</span>
        <span class="c1"># XXX: what about other (actual) dimensions? This is a limitation in that only fuel</span>
        <span class="c1"># compuents are duplicated, and not the entire pin. It is also a reasonable assumption with</span>
        <span class="c1"># current/historical usage of ARMI.</span>
        <span class="k">for</span> <span class="n">comp</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponentsThatAreLinkedTo</span><span class="p">(</span><span class="n">fuel</span><span class="p">,</span> <span class="s2">&quot;mult&quot;</span><span class="p">):</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">setDimension</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">nPins</span><span class="p">)</span>

        <span class="c1"># finish the first pin as a single pin</span>
        <span class="n">fuel</span><span class="o">.</span><span class="n">setDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fuel</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;fuel001&quot;</span><span class="p">)</span>
        <span class="n">fuel</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinNum</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># create all the new pin components and add them to the block with &#39;fuel001&#39; names</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># wow, only use of a non-deepcopy</span>
            <span class="n">newC</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">fuel</span><span class="p">)</span>
            <span class="n">newC</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;fuel</span><span class="si">{0:03d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># start with 002.</span>
            <span class="n">newC</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinNum</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newC</span><span class="p">)</span>

        <span class="c1"># update moles at BOL for each pin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOLByPin</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">):</span>
            <span class="c1"># Update the fuel component flags to be the same as before the split (i.e., DEPLETABLE)</span>
            <span class="n">pin</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">fuelFlags</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOLByPin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pin</span><span class="o">.</span><span class="n">getHMMoles</span><span class="p">())</span>
            <span class="n">pin</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">massHmBOL</span> <span class="o">/=</span> <span class="n">nPins</span></div>

<div class="viewcode-block" id="Block.getIntegratedMgFlux"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getIntegratedMgFlux">[docs]</a>    <span class="k">def</span> <span class="nf">getIntegratedMgFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the volume integrated multigroup neutron tracklength in [n-cm/s].</span>

<span class="sd">        The first entry is the first energy group (fastest neutrons). Each additional</span>
<span class="sd">        group is the next energy group, as set in the ISOTXS library.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adjoint : bool, optional</span>
<span class="sd">            Return adjoint flux instead of real</span>

<span class="sd">        gamma : bool, optional</span>
<span class="sd">            Whether to return the neutron flux or the gamma flux.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        integratedFlux : numpy.array</span>
<span class="sd">            multigroup neutron tracklength in [n-cm/s]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">adjoint</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gamma</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Adjoint gamma flux is currently unsupported.&quot;</span><span class="p">)</span>
            <span class="n">integratedFlux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">adjMgFlux</span>
        <span class="k">elif</span> <span class="n">gamma</span><span class="p">:</span>
            <span class="n">integratedFlux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFluxGamma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">integratedFlux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span>

        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">integratedFlux</span><span class="p">)</span></div>

<div class="viewcode-block" id="Block.getLumpedFissionProductCollection"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getLumpedFissionProductCollection">[docs]</a>    <span class="k">def</span> <span class="nf">getLumpedFissionProductCollection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get collection of LFP objects. Will work for global or block-level LFP models.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lfps : LumpedFissionProduct</span>
<span class="sd">            lfpName keys , lfp object values</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.physics.neutronics.fissionProductModel.lumpedFissionProduct.LumpedFissionProduct : LFP object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">composites</span><span class="o">.</span><span class="n">ArmiObject</span><span class="o">.</span><span class="n">getLumpedFissionProductCollection</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Block.rotate"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function for rotating a block&#39;s spatially varying variables by a specified angle.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deg - float</span>
<span class="sd">            number specifying the angle of counter clockwise rotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Block.setAxialExpTargetComp"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setAxialExpTargetComp">[docs]</a>    <span class="k">def</span> <span class="nf">setAxialExpTargetComp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targetComponent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;sets the targetComponent for the axial expansion changer</span>

<span class="sd">        Parameter</span>
<span class="sd">        ---------</span>
<span class="sd">        targetComponent: :py:class:`Component &lt;armi.reactor.components.component.Component&gt;` object</span>
<span class="sd">            component specified to be target component for axial expansion changer</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.converters.axialExpansionChanger.py::ExpansionData::_setTargetComponents</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axialExpTargetComponent</span> <span class="o">=</span> <span class="n">targetComponent</span></div>

<div class="viewcode-block" id="Block.getPinCoordinates"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPinCoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">getPinCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the local centroid coordinates of any pins in this block.</span>

<span class="sd">        The pins must have a CLAD-flagged component for this to work.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        localCoordinates : list</span>
<span class="sd">            list of (x,y,z) pairs representing each pin in the order they are listed as children</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This assumes hexagonal pin lattice and needs to be upgraded once more generic geometry</span>
<span class="sd">        options are needed. Only works if pins have clad.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">clad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">,</span> <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span><span class="p">):</span>
                <span class="n">coords</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">locator</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">()</span> <span class="k">for</span> <span class="n">locator</span> <span class="ow">in</span> <span class="n">clad</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">coords</span></div></div>


<div class="viewcode-block" id="HexBlock"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock">[docs]</a><span class="k">class</span> <span class="nc">HexBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>

    <span class="n">PITCH_COMPONENT_TYPE</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">_PitchDefiningComponent</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">components</span><span class="o">.</span><span class="n">Hexagon</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="n">Block</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

<div class="viewcode-block" id="HexBlock.coords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotationDegreesCCW</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">displacementX</span> <span class="o">*</span> <span class="mf">100.0</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">displacementY</span> <span class="o">*</span> <span class="mf">100.0</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">FLOAT_DIMENSION_DECIMALS</span><span class="p">),</span>
            <span class="nb">round</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">FLOAT_DIMENSION_DECIMALS</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getMaxArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getMaxArea">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the max area of this block if it was totally full.&quot;&quot;&quot;</span>
        <span class="n">pitch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPitch</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pitch</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">area</span><span class="p">(</span><span class="n">pitch</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getDuctIP"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getDuctIP">[docs]</a>    <span class="k">def</span> <span class="nf">getDuctIP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">duct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">duct</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;ip&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getDuctOP"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getDuctOP">[docs]</a>    <span class="k">def</span> <span class="nf">getDuctOP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">duct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">duct</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;op&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.initializePinLocations"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.initializePinLocations">[docs]</a>    <span class="k">def</span> <span class="nf">initializePinLocations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinLocation</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nPins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="HexBlock.setPinPowers"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.setPinPowers">[docs]</a>    <span class="k">def</span> <span class="nf">setPinPowers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">powers</span><span class="p">,</span> <span class="n">powerKeySuffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the pin linear power densities of this block for the current rotation.</span>
<span class="sd">        The linear densities are represented by the *linPowByPin* parameter.</span>

<span class="sd">        It is assumed that :py:meth:`.initializePinLocations` has already been executed</span>
<span class="sd">        for fueled blocks in order to access the *pinLocation* parameter. The</span>
<span class="sd">        *pinLocation* parameter is not accessed for non-fueled blocks.</span>

<span class="sd">        The *linPowByPin* parameter can be directly assigned to instead of using this</span>
<span class="sd">        method if the multiplicity of the pins in the block is equal to the number of</span>
<span class="sd">        pins in the block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        powers : list of floats, required</span>
<span class="sd">            The block-level pin linear power densities. powers[i] represents the average</span>
<span class="sd">            linear power density of pin i. The units of linear power density is watts/cm</span>
<span class="sd">            (i.e., watts produced per cm of pin length). The &quot;ARMI pin ordering&quot; must be</span>
<span class="sd">            be used, which is counter-clockwise from 3 o&#39;clock.</span>

<span class="sd">        powerKeySuffix: str, optional</span>
<span class="sd">            Must be either an empty string, :py:const:`NEUTRON &lt;armi.physics.neutronics.const.NEUTRON&gt;`,</span>
<span class="sd">            or :py:const:`GAMMA &lt;armi.physics.neutronics.const.GAMMA&gt;`. Defaults to empty</span>
<span class="sd">            string.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method can handle assembly rotations by using the *pinLocation* parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numPins</span> <span class="ow">or</span> <span class="n">numPins</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">powers</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid power data for </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">numPins</span><span class="si">}</span><span class="s2"> pins.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; Got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">powers</span><span class="p">)</span><span class="si">}</span><span class="s2"> entries in powers: </span><span class="si">{</span><span class="n">powers</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">powerKey</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;linPowByPin</span><span class="si">{</span><span class="n">powerKeySuffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">powerKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numPins</span><span class="p">)</span>

        <span class="c1"># Loop through rings. The *pinLocation* parameter is only accessed for fueled</span>
        <span class="c1"># blocks; it is assumed that non-fueled blocks do not use a rotation map.</span>
        <span class="k">for</span> <span class="n">pinNum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numPins</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">):</span>
                <span class="c1"># -1 is needed in order to map from pinLocations to list index</span>
                <span class="n">pinLoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinLocation</span><span class="p">[</span><span class="n">pinNum</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pinLoc</span> <span class="o">=</span> <span class="n">pinNum</span>
            <span class="n">pinLinPow</span> <span class="o">=</span> <span class="n">powers</span><span class="p">[</span><span class="n">pinLoc</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">powerKey</span><span class="p">][</span><span class="n">pinNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">pinLinPow</span>

        <span class="c1"># If using the *powerKeySuffix* parameter, we also need to set total power, which</span>
        <span class="c1"># is sum of neutron and gamma powers. We assume that a solo gamma calculation</span>
        <span class="c1"># to set total power does not make sense.</span>
        <span class="k">if</span> <span class="n">powerKeySuffix</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">powerKeySuffix</span> <span class="o">==</span> <span class="n">GAMMA</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;linPowByPin</span><span class="si">{</span><span class="n">NEUTRON</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;Neutron power has not been set yet. Cannot set total power for &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">UnboundLocalError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">linPowByPin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;linPowByPin</span><span class="si">{</span><span class="n">NEUTRON</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">powerKey</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">linPowByPin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">powerKey</span><span class="p">]</span></div>

<div class="viewcode-block" id="HexBlock.rotate"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rad</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates a block&#39;s spatially varying parameters by a specified angle in the</span>
<span class="sd">        counter-clockwise direction.</span>

<span class="sd">        The parameters must have a ParamLocation of either CORNERS or EDGES and must be a</span>
<span class="sd">        Python list of length 6 in order to be eligible for rotation; all parameters that</span>
<span class="sd">        do not meet these two criteria are not rotated.</span>

<span class="sd">        The pin indexing, as stored on the pinLocation parameter, is also updated via</span>
<span class="sd">        :py:meth:`rotatePins &lt;armi.reactor.blocks.HexBlock.rotatePins&gt;`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rad: float, required</span>
<span class="sd">            Angle of counter-clockwise rotation in units of radians. Rotations must be</span>
<span class="sd">            in 60-degree increments (i.e., PI/6, PI/3, PI, 2 * PI/3, 5 * PI/6,</span>
<span class="sd">            and 2 * PI)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :py:meth:`rotatePins &lt;armi.reactor.blocks.HexBlock.rotatePins&gt;`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rotNum</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">rad</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">60</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotatePins</span><span class="p">(</span><span class="n">rotNum</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="o">.</span><span class="n">atLocation</span><span class="p">(</span><span class="n">ParamLocation</span><span class="o">.</span><span class="n">CORNERS</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>
        <span class="n">params</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="o">.</span><span class="n">atLocation</span><span class="p">(</span><span class="n">ParamLocation</span><span class="o">.</span><span class="n">EDGES</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">])</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">][</span><span class="o">-</span><span class="n">rotNum</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">][:</span><span class="o">-</span><span class="n">rotNum</span><span class="p">]</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
                    <span class="c1"># List hasn&#39;t been defined yet, no warning needed.</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;No rotation method defined for spatial parameters that aren&#39;t &quot;</span>
                        <span class="s2">&quot;defined once per hex edge/corner. No rotation performed &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;on </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># this is a scalar and there shouldn&#39;t be any rotation.</span>
                <span class="k">pass</span>
        <span class="c1"># This specifically uses the .get() functionality to avoid an error if this</span>
        <span class="c1"># parameter does not exist.</span>
        <span class="n">dispx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;displacementX&quot;</span><span class="p">)</span>
        <span class="n">dispy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;displacementY&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dispx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dispy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">displacementX</span> <span class="o">=</span> <span class="n">dispx</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">-</span> <span class="n">dispy</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">displacementY</span> <span class="o">=</span> <span class="n">dispx</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">dispy</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.rotatePins"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.rotatePins">[docs]</a>    <span class="k">def</span> <span class="nf">rotatePins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotNum</span><span class="p">,</span> <span class="n">justCompute</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate the pins of a block, which means rotating the indexing of pins. Note that this does</span>
<span class="sd">        not rotate all block quantities, just the pins.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rotNum : int, required</span>
<span class="sd">            An integer from 0 to 5, indicating the number of counterclockwise 60-degree rotations</span>
<span class="sd">            from the CURRENT orientation. Degrees of counter-clockwise rotation = 60*rot</span>

<span class="sd">        justCompute : boolean, optional</span>
<span class="sd">            If True, rotateIndexLookup will be returned but NOT assigned to the object parameter</span>
<span class="sd">            self.p.pinLocation. If False, rotateIndexLookup will be returned AND assigned to the</span>
<span class="sd">            object variable self.p.pinLocation.  Useful for figuring out which rotation is best</span>
<span class="sd">            to minimize burnup, etc.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotateIndexLookup : dict of ints</span>
<span class="sd">            This is an index lookup (or mapping) between pin ids and pin locations. The pin</span>
<span class="sd">            indexing is 1-D (not ring,pos or GEODST). The &quot;ARMI pin ordering&quot; is used for location,</span>
<span class="sd">            which is counter-clockwise from 1 o&#39;clock. Pin ids are always consecutively</span>
<span class="sd">            ordered starting at 1, while pin locations are not once a rotation has been</span>
<span class="sd">            applied.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Changing (x,y) positions of pins does NOT constitute rotation, because the indexing of pin</span>
<span class="sd">        atom densities must be re-ordered.  Re-order indexing of pin-level quantities, NOT (x,y)</span>
<span class="sd">        locations of pins.  Otherwise, subchannel input will be in wrong order.</span>

<span class="sd">        How rotations works is like this. There are pins with unique pin numbers in each block.</span>
<span class="sd">        These pin numbers will not change no matter what happens to a block, so if you have pin 1,</span>
<span class="sd">        you always have pin 1. However, these pins are all in pinLocations, and these are what</span>
<span class="sd">        change with rotations. At BOL, a pin&#39;s pinLocation is equal to its pin number, but after</span>
<span class="sd">        a rotation, this will no longer be so.</span>

<span class="sd">        So, all params that don&#39;t care about exactly where in space the pin is (such as depletion)</span>
<span class="sd">        can just use the pin number, but anything that needs to know the spatial location (such as</span>
<span class="sd">        fluxRecon, which interpolates the flux spatially, or subchannel codes, which needs to know where the</span>
<span class="sd">        power is) need to map through the pinLocation parameters.</span>

<span class="sd">        This method rotates the pins by changing the pinLocation parameter.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.blocks.HexBlock.rotate</span>
<span class="sd">            Rotates the entire block (pins, ducts, and spatial quantities).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        rotateIndexLookup[i_after_rotation-1] = i_before_rotation-1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">rotNum</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot rotate </span><span class="si">{0}</span><span class="s2"> to rotNum </span><span class="si">{1}</span><span class="s2">. Must be 0-5. &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotNum</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Pin numbers start at 1. Number of pins in the block is assumed to be based on</span>
        <span class="c1"># cladding count.</span>
        <span class="n">numPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="n">rotateIndexLookup</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numPins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numPins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># Look up the current orientation and add this to it. The math below just rotates</span>
        <span class="c1"># from the reference point so we need a total rotation.</span>
        <span class="n">rotNum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">getRotationNum</span><span class="p">()</span> <span class="o">+</span> <span class="n">rotNum</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span><span class="p">)</span>

        <span class="c1"># non-trivial rotation requested</span>
        <span class="c1"># start at 2 because pin 1 never changes (it&#39;s in the center!)</span>
        <span class="k">for</span> <span class="n">pinNum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">numPins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rotNum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Rotation to reference orientation. Pin locations are pin IDs.</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Determine the pin ring. Rotation does not change the pin ring!</span>
                <span class="n">ring</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="mf">3.0</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">9.0</span> <span class="o">-</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">pinNum</span><span class="p">)))</span> <span class="o">/</span> <span class="mf">6.0</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Rotate the pin position (within the ring, which does not change)</span>
                <span class="n">tot_pins</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">ring</span> <span class="o">*</span> <span class="p">(</span><span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">newPinLocation</span> <span class="o">=</span> <span class="n">pinNum</span> <span class="o">+</span> <span class="p">(</span><span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">rotNum</span>
                <span class="k">if</span> <span class="n">newPinLocation</span> <span class="o">&gt;</span> <span class="n">tot_pins</span><span class="p">:</span>
                    <span class="n">newPinLocation</span> <span class="o">-=</span> <span class="p">(</span><span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span>

                <span class="c1"># Assign &quot;before&quot; and &quot;after&quot; pin indices to the index lookup</span>
                <span class="n">rotateIndexLookup</span><span class="p">[</span><span class="n">pinNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">newPinLocation</span>

        <span class="c1"># Because the above math creates indices based on the absolute rotation number,</span>
        <span class="c1"># the old values of pinLocation (if they&#39;ve been set in the past) can be overwritten</span>
        <span class="c1"># with new numbers</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">justCompute</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setRotationNum</span><span class="p">(</span><span class="n">rotNum</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s2">&quot;pinLocation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">rotateIndexLookup</span><span class="p">[</span><span class="n">pinNum</span><span class="p">]</span> <span class="k">for</span> <span class="n">pinNum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numPins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="n">rotateIndexLookup</span></div>

<div class="viewcode-block" id="HexBlock.verifyBlockDims"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.verifyBlockDims">[docs]</a>    <span class="k">def</span> <span class="nf">verifyBlockDims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform some checks on this type of block before it is assembled.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wireComp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span>
            <span class="n">ductComps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">)</span>
            <span class="n">cladComp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># there are probably more that one clad/wire, so we really dont know what this block looks like</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Block design </span><span class="si">{}</span><span class="s2"> is too complicated to verify dimensions. Make sure they &quot;</span>
                <span class="s2">&quot;are correct!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># check wire wrap in contact with clad</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">wwCladGap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getWireWrapCladGap</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">wwCladGap</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;The gap between wire wrap and clad in block </span><span class="si">{}</span><span class="s2"> was </span><span class="si">{}</span><span class="s2"> cm. Expected 0.0.&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wwCladGap</span><span class="p">),</span>
                    <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="c1"># check clad duct overlap</span>
        <span class="n">pinToDuctGap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinToDuctGap</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Allow for some tolerance; user input precision may lead to slight negative</span>
        <span class="c1"># gaps</span>
        <span class="k">if</span> <span class="n">pinToDuctGap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pinToDuctGap</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.005</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Gap between pins and duct is </span><span class="si">{0:.4f}</span><span class="s2"> cm in </span><span class="si">{1}</span><span class="s2">. Make more room.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">pinToDuctGap</span><span class="p">,</span> <span class="bp">self</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">wire</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span>
            <span class="n">wireThicknesses</span> <span class="o">=</span> <span class="n">wire</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pinToDuctGap</span> <span class="o">&lt;</span> <span class="n">wireThicknesses</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Gap between pins and duct is </span><span class="si">{0:.4f}</span><span class="s2"> cm in </span><span class="si">{1}</span><span class="s2"> which does not allow room for the wire &quot;</span>
                    <span class="s2">&quot;with diameter </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pinToDuctGap</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">wireThicknesses</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">pinToDuctGap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># only produce a warning if pin or clad are found, but not all of pin, clad and duct. We</span>
            <span class="c1"># may need to tune this logic a bit</span>
            <span class="n">ductComp</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">ductComps</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cladComp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">wireComp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">[</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="n">wireComp</span><span class="p">,</span> <span class="n">cladComp</span><span class="p">,</span> <span class="n">ductComp</span><span class="p">)]</span>
            <span class="p">):</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Some component was missing in </span><span class="si">{}</span><span class="s2"> so pin-to-duct gap not calculated&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getPinToDuctGap"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getPinToDuctGap">[docs]</a>    <span class="k">def</span> <span class="nf">getPinToDuctGap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance in cm between the outer most pin and the duct in a block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cold : boolean</span>
<span class="sd">            Determines whether the results should be cold or hot dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pinToDuctGap : float</span>
<span class="sd">            Returns the diameteral gap between the outer most pins in a hex pack to the duct inner</span>
<span class="sd">            face to face in cm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wire</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span>
        <span class="n">ducts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">))</span>
        <span class="n">duct</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ducts</span><span class="p">):</span>
            <span class="n">duct</span> <span class="o">=</span> <span class="n">ducts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">duct</span><span class="p">,</span> <span class="n">components</span><span class="o">.</span><span class="n">Hexagon</span><span class="p">):</span>
                <span class="c1"># getPinCenterFlatToFlat only works for hexes</span>
                <span class="c1"># inner most duct might be circle or some other shape</span>
                <span class="n">duct</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">duct</span><span class="p">,</span> <span class="n">components</span><span class="o">.</span><span class="n">HoledHexagon</span><span class="p">):</span>
                <span class="c1"># has no ip and is circular on inside so following</span>
                <span class="c1"># code will not work</span>
                <span class="n">duct</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="n">duct</span><span class="p">,</span> <span class="n">wire</span><span class="p">,</span> <span class="n">clad</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># note, if nRings was a None, this could be for a non-hex packed fuel assembly</span>
        <span class="c1"># see thermal hydraulic design basis for description of equation</span>
        <span class="n">pinCenterFlatToFlat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinCenterFlatToFlat</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="n">pinOuterFlatToFlat</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pinCenterFlatToFlat</span>
            <span class="o">+</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
            <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">wire</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">ductMarginToContact</span> <span class="o">=</span> <span class="n">duct</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;ip&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">-</span> <span class="n">pinOuterFlatToFlat</span>
        <span class="n">pinToDuctGap</span> <span class="o">=</span> <span class="n">ductMarginToContact</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="k">return</span> <span class="n">pinToDuctGap</span></div>

<div class="viewcode-block" id="HexBlock.getRotationNum"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getRotationNum">[docs]</a>    <span class="k">def</span> <span class="nf">getRotationNum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get index 0 through 5 indicating number of rotations counterclockwise around the z-axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">orientation</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mf">360.0</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span>
        <span class="p">)</span>  <span class="c1"># assume rotation only in Z</span></div>

<div class="viewcode-block" id="HexBlock.setRotationNum"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.setRotationNum">[docs]</a>    <span class="k">def</span> <span class="nf">setRotationNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotNum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set orientation based on a number 0 through 5 indicating number of rotations</span>
<span class="sd">        counterclockwise around the z-axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">orientation</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">60.0</span> <span class="o">*</span> <span class="n">rotNum</span></div>

<div class="viewcode-block" id="HexBlock.getSymmetryFactor"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getSymmetryFactor">[docs]</a>    <span class="k">def</span> <span class="nf">getSymmetryFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a factor between 1 and N where 1/N is how much cut-off by symmetry lines this mesh</span>
<span class="sd">        cell is.</span>

<span class="sd">        Reactor-level meshes have symmetry information so we have a reactor for this to work. That&#39;s</span>
<span class="sd">        why it&#39;s not implemented on the grid/locator level.</span>

<span class="sd">        When edge-assemblies are included on both edges (i.e. MCNP or DIF3D-FD 1/3-symmetric cases),</span>
<span class="sd">        the edge assemblies have symmetry factors of 2.0. Otherwise (DIF3D-nodal) there&#39;s a full</span>
<span class="sd">        assembly on the bottom edge (overhanging) and no assembly at the top edge so the ones at the</span>
<span class="sd">        bottom are considered full (symmetryFactor=1).</span>

<span class="sd">        If this block is not in any grid at all, then there can be no symmetry so return 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">symmetry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">symmetry</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">THIRD_CORE</span>
            <span class="ow">and</span> <span class="n">symmetry</span><span class="o">.</span><span class="n">boundary</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">PERIODIC</span>
        <span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># central location</span>
                <span class="k">return</span> <span class="mf">3.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">symmetryLine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">overlapsWhichSymmetryLine</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="c1"># detect if upper edge assemblies are included. Doing this is the only way to know</span>
                <span class="c1"># definitively whether or not the edge assemblies are half-assems or full.</span>
                <span class="c1"># seeing the first one is the easiest way to detect them.</span>
                <span class="c1"># Check it last in the and statement so we don&#39;t waste time doing it.</span>
                <span class="n">upperEdgeLoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">symmetryLine</span>
                    <span class="ow">in</span> <span class="p">[</span>
                        <span class="n">grids</span><span class="o">.</span><span class="n">BOUNDARY_0_DEGREES</span><span class="p">,</span>
                        <span class="n">grids</span><span class="o">.</span><span class="n">BOUNDARY_120_DEGREES</span><span class="p">,</span>
                    <span class="p">]</span>
                    <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">upperEdgeLoc</span><span class="p">))</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="mf">2.0</span>
        <span class="k">return</span> <span class="mf">1.0</span></div>

<div class="viewcode-block" id="HexBlock.autoCreateSpatialGrids"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.autoCreateSpatialGrids">[docs]</a>    <span class="k">def</span> <span class="nf">autoCreateSpatialGrids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a block without a spatialGrid, create a spatialGrid and give its children</span>
<span class="sd">        the corresponding spatialLocators (if it is a simple block).</span>

<span class="sd">        In this case, a simple block would be one that has either multiplicity of</span>
<span class="sd">        components equal to 1 or N but no other multiplicities. Also, this should only</span>
<span class="sd">        happen when N fits exactly into a given number of hex rings.  Otherwise, do not</span>
<span class="sd">        create a grid for this block.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the block meets all the conditions, we gather all components to either be a multiIndexLocation containing all</span>
<span class="sd">        of the pin positions, otherwise, locator is the center (0,0).</span>

<span class="sd">        Also, this only works on blocks that have &#39;flat side up&#39;.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the multiplicities of the block are not only 1 or N or if generated ringNumber leads to more positions than necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check multiplicities...</span>
        <span class="n">mults</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">()}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mults</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mults</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Could not create a spatialGrid for block </span><span class="si">{}</span><span class="s2">, multiplicities are not 1 or N they are </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">mults</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">ringNumber</span> <span class="o">=</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numRingsToHoldNumCells</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">())</span>
        <span class="c1"># For the below to work, there must not be multiple wire or multiple clad types.</span>
        <span class="c1"># note that it&#39;s the pointed end of the cell hexes that are up (but the</span>
        <span class="c1"># macro shape of the pins forms a hex with a flat top fitting in the assembly)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">HexGrid</span><span class="o">.</span><span class="n">fromPitch</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getPinPitch</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">numRings</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pointedEndUp</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">spatialLocators</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">)</span>
        <span class="n">numLocations</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ringNumber</span><span class="p">):</span>
            <span class="n">numLocations</span> <span class="o">=</span> <span class="n">numLocations</span> <span class="o">+</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numPositionsInRing</span><span class="p">(</span><span class="n">ring</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numLocations</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot create spatialGrid, number of locations in rings</span><span class="si">{}</span><span class="s2"> not equal to pin number</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">numLocations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ringNumber</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">getPositionsInRing</span><span class="p">(</span><span class="n">ring</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getIndicesFromRingAndPos</span><span class="p">(</span><span class="n">ring</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">spatialLocators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="n">grid</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">spatialLocators</span>
                <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">CoordinateLocation</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getPinCenterFlatToFlat"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getPinCenterFlatToFlat">[docs]</a>    <span class="k">def</span> <span class="nf">getPinCenterFlatToFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the flat-to-flat distance between the centers of opposing pins in the outermost ring.&quot;&quot;&quot;</span>
        <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="n">nRings</span> <span class="o">=</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numRingsToHoldNumCells</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">))</span>
        <span class="n">pinPitch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinPitch</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="n">pinCenterCornerToCorner</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nRings</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pinPitch</span>
        <span class="n">pinCenterFlatToFlat</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">pinCenterCornerToCorner</span>
        <span class="k">return</span> <span class="n">pinCenterFlatToFlat</span></div>

<div class="viewcode-block" id="HexBlock.hasPinPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.hasPinPitch">[docs]</a>    <span class="k">def</span> <span class="nf">hasPinPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the block has enough information to calculate pin pitch.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getPinPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getPinPitch">[docs]</a>    <span class="k">def</span> <span class="nf">getPinPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the pin pitch in cm.</span>

<span class="sd">        Assumes that the pin pitch is defined entirely by contacting cladding tubes</span>
<span class="sd">        and wire wraps. Grid spacers not yet supported.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cold : boolean</span>
<span class="sd">            Determines whether the dimensions should be cold or hot</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pinPitch : float</span>
<span class="sd">            pin pitch in cm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
            <span class="n">wire</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Block </span><span class="si">{}</span><span class="s2"> has multiple clad and wire components,&quot;</span>
                <span class="s2">&quot; so pin pitch is not well-defined.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">wire</span> <span class="ow">and</span> <span class="n">clad</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">+</span> <span class="n">wire</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span>
                <span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get pin pitch in </span><span class="si">{}</span><span class="s2"> because it does not have a wire and a clad&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span>
                <span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getWettedPerimeter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getWettedPerimeter">[docs]</a>    <span class="k">def</span> <span class="nf">getWettedPerimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return wetted perimeter per pin with duct averaged in.&quot;&quot;&quot;</span>
        <span class="n">duct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">)</span>
        <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="n">wire</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">duct</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">clad</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Wetted perimeter cannot be computed in </span><span class="si">{}</span><span class="s2">. No duct or clad components exist.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">wire</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">duct</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;ip&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getHydraulicDiameter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getHydraulicDiameter">[docs]</a>    <span class="k">def</span> <span class="nf">getHydraulicDiameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the hydraulic diameter in this block in cm.</span>

<span class="sd">        Hydraulic diameter is 4A/P where A is the flow area and P is the wetted perimeter.</span>
<span class="sd">        In a hex assembly, the wetted perimeter includes the cladding, the wire wrap, and the</span>
<span class="sd">        inside of the duct. The flow area is the inner area of the duct minus the area of the</span>
<span class="sd">        pins and the wire.</span>

<span class="sd">        To convert the inner hex pitch into a perimeter, first convert to side, then</span>
<span class="sd">        multiply by 6.</span>

<span class="sd">        p = sqrt(3)*s</span>
<span class="sd">        l = 6*p/sqrt(3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFlowAreaPerPin</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getWettedPerimeter</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="CartesianBlock"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock">[docs]</a><span class="k">class</span> <span class="nc">CartesianBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>

    <span class="n">PITCH_DIMENSION</span> <span class="o">=</span> <span class="s2">&quot;widthOuter&quot;</span>
    <span class="n">PITCH_COMPONENT_TYPE</span> <span class="o">=</span> <span class="n">components</span><span class="o">.</span><span class="n">Rectangle</span>

<div class="viewcode-block" id="CartesianBlock.getMaxArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock.getMaxArea">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get area of this block if it were totally full.&quot;&quot;&quot;</span>
        <span class="n">xw</span><span class="p">,</span> <span class="n">yw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPitch</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">xw</span> <span class="o">*</span> <span class="n">yw</span></div>

<div class="viewcode-block" id="CartesianBlock.setPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock.setPitch">[docs]</a>    <span class="k">def</span> <span class="nf">setPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">updateBolParams</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Directly setting the pitch of a cartesian block is currently not supported.&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CartesianBlock.getSymmetryFactor"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock.getSymmetryFactor">[docs]</a>    <span class="k">def</span> <span class="nf">getSymmetryFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a factor between 1 and N where 1/N is how much cut-off by symmetry lines this mesh</span>
<span class="sd">        cell is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">isThroughCenterAssembly</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># central location</span>
                    <span class="k">return</span> <span class="mf">4.0</span>
                <span class="k">elif</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># edge location</span>
                    <span class="k">return</span> <span class="mf">2.0</span>
        <span class="k">return</span> <span class="mf">1.0</span></div>

<div class="viewcode-block" id="CartesianBlock.getPinCenterFlatToFlat"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock.getPinCenterFlatToFlat">[docs]</a>    <span class="k">def</span> <span class="nf">getPinCenterFlatToFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the flat-to-flat distance between the centers of opposing pins in the outermost ring.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="n">nRings</span> <span class="o">=</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numRingsToHoldNumCells</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">))</span>
        <span class="n">pinPitch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinPitch</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nRings</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pinPitch</span></div></div>


<div class="viewcode-block" id="ThRZBlock"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock">[docs]</a><span class="k">class</span> <span class="nc">ThRZBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
    <span class="c1"># be sure to fill ThRZ blocks with only 3D components - components with explicit getVolume methods</span>

<div class="viewcode-block" id="ThRZBlock.getMaxArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.getMaxArea">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the area of the Theta-R-Z block if it was totally full.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot get max area of a TRZ block. Fully specify your geometry.&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ThRZBlock.radialInner"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.radialInner">[docs]</a>    <span class="k">def</span> <span class="nf">radialInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a smallest radius of all the components.&quot;&quot;&quot;</span>
        <span class="n">innerRadii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;inner_radius&quot;</span><span class="p">)</span>
        <span class="n">smallestInner</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">innerRadii</span><span class="p">)</span> <span class="k">if</span> <span class="n">innerRadii</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">smallestInner</span></div>

<div class="viewcode-block" id="ThRZBlock.radialOuter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.radialOuter">[docs]</a>    <span class="k">def</span> <span class="nf">radialOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a largest radius of all the components.&quot;&quot;&quot;</span>
        <span class="n">outerRadii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;outer_radius&quot;</span><span class="p">)</span>
        <span class="n">largestOuter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">outerRadii</span><span class="p">)</span> <span class="k">if</span> <span class="n">outerRadii</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">largestOuter</span></div>

<div class="viewcode-block" id="ThRZBlock.thetaInner"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.thetaInner">[docs]</a>    <span class="k">def</span> <span class="nf">thetaInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a smallest theta of all the components.&quot;&quot;&quot;</span>
        <span class="n">innerTheta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;inner_theta&quot;</span><span class="p">)</span>
        <span class="n">smallestInner</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">innerTheta</span><span class="p">)</span> <span class="k">if</span> <span class="n">innerTheta</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">smallestInner</span></div>

<div class="viewcode-block" id="ThRZBlock.thetaOuter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.thetaOuter">[docs]</a>    <span class="k">def</span> <span class="nf">thetaOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a largest theta of all the components.&quot;&quot;&quot;</span>
        <span class="n">outerTheta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;outer_theta&quot;</span><span class="p">)</span>
        <span class="n">largestOuter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">outerTheta</span><span class="p">)</span> <span class="k">if</span> <span class="n">outerTheta</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">largestOuter</span></div>

<div class="viewcode-block" id="ThRZBlock.axialInner"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.axialInner">[docs]</a>    <span class="k">def</span> <span class="nf">axialInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the lower z-coordinate.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;inner_axial&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ThRZBlock.axialOuter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.axialOuter">[docs]</a>    <span class="k">def</span> <span class="nf">axialOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the upper z-coordinate.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;outer_axial&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ThRZBlock.verifyBlockDims"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.verifyBlockDims">[docs]</a>    <span class="k">def</span> <span class="nf">verifyBlockDims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform dimension checks related to ThetaRZ blocks.&quot;&quot;&quot;</span>
        <span class="k">return</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2009-2022, TerraPower, LLC.
      <span class="lastupdated">
        Last updated on 2022-10-03.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
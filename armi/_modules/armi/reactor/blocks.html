<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>armi.reactor.blocks &mdash; ARMI 0.4.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme_fixes.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/armiicon_16x16.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ARMI
              <img src="../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.4.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../.apidocs/modules.html">API Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #233C5B" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ARMI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../armi.html">armi</a></li>
          <li class="breadcrumb-item"><a href="../reactor.html">armi.reactor</a></li>
      <li class="breadcrumb-item active">armi.reactor.blocks</li>
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for armi.reactor.blocks</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Defines blocks, which are axial chunks of assemblies. They contain most of the state variables,</span>
<span class="sd">including power, flux, and homogenized number densities.</span>

<span class="sd">Assemblies are made of blocks. Blocks are made of components.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">ClassVar</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">nuclideBases</span>
<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">runLog</span>
<span class="kn">from</span> <span class="nn">armi.bookkeeping</span> <span class="kn">import</span> <span class="n">report</span>
<span class="kn">from</span> <span class="nn">armi.nucDirectory</span> <span class="kn">import</span> <span class="n">elements</span>
<span class="kn">from</span> <span class="nn">armi.nuclearDataIO</span> <span class="kn">import</span> <span class="n">xsCollections</span>
<span class="kn">from</span> <span class="nn">armi.physics.neutronics</span> <span class="kn">import</span> <span class="n">GAMMA</span>
<span class="kn">from</span> <span class="nn">armi.physics.neutronics</span> <span class="kn">import</span> <span class="n">NEUTRON</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">blockParameters</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">components</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">composites</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">geometry</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">grids</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">parameters</span>
<span class="kn">from</span> <span class="nn">armi.reactor.components</span> <span class="kn">import</span> <span class="n">basicShapes</span>
<span class="kn">from</span> <span class="nn">armi.reactor.components.basicShapes</span> <span class="kn">import</span> <span class="n">Hexagon</span><span class="p">,</span> <span class="n">Circle</span>
<span class="kn">from</span> <span class="nn">armi.reactor.components.complexShapes</span> <span class="kn">import</span> <span class="n">Helix</span>
<span class="kn">from</span> <span class="nn">armi.reactor.flags</span> <span class="kn">import</span> <span class="n">Flags</span>
<span class="kn">from</span> <span class="nn">armi.reactor.parameters</span> <span class="kn">import</span> <span class="n">ParamLocation</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">densityTools</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">hexagon</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">iterables</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">units</span>
<span class="kn">from</span> <span class="nn">armi.utils.plotting</span> <span class="kn">import</span> <span class="n">plotBlockFlux</span>
<span class="kn">from</span> <span class="nn">armi.utils.units</span> <span class="kn">import</span> <span class="n">TRACE_NUMBER_DENSITY</span>

<span class="n">PIN_COMPONENTS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">CONTROL</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">PLENUM</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">SHIELD</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">PIN</span><span class="p">,</span>
    <span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">_PitchDefiningComponent</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">components</span><span class="o">.</span><span class="n">Component</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span>


<div class="viewcode-block" id="Block"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block">[docs]</a><span class="k">class</span> <span class="nc">Block</span><span class="p">(</span><span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A homogenized axial slab of material.</span>

<span class="sd">    Blocks are stacked together to form assemblies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">uniqID</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># dimension used to determine which component defines the block&#39;s pitch</span>
    <span class="n">PITCH_DIMENSION</span> <span class="o">=</span> <span class="s2">&quot;op&quot;</span>

    <span class="c1"># component type that can be considered a candidate for providing pitch</span>
    <span class="n">PITCH_COMPONENT_TYPE</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">_PitchDefiningComponent</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">pDefs</span> <span class="o">=</span> <span class="n">blockParameters</span><span class="o">.</span><span class="n">getBlockParameterDefinitions</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a new ARMI block.</span>

<span class="sd">        name : str</span>
<span class="sd">            The name of this block</span>

<span class="sd">        height : float, optional</span>
<span class="sd">            The height of the block in cm. Defaults to 1.0 so that ``getVolume`` assumes unit height.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">heightBOL</span> <span class="o">=</span> <span class="n">height</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">macros</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># flag to indicated when DerivedShape children must be updated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derivedMustUpdate</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># which component to use to determine block pitch, along with its &#39;op&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># TODO: what&#39;s causing these to have wrong values at BOL?</span>
        <span class="k">for</span> <span class="n">problemParam</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;THcornTemp&quot;</span><span class="p">,</span> <span class="s2">&quot;THedgeTemp&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">problemParam</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">problemParam</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="s2">&quot;residence&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bondRemoved&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fluence&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fastFluence&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fastFluencePeak&quot;</span><span class="p">,</span>
            <span class="s2">&quot;displacementX&quot;</span><span class="p">,</span>
            <span class="s2">&quot;displacementY&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fluxAdj&quot;</span><span class="p">,</span>
            <span class="s2">&quot;buRate&quot;</span><span class="p">,</span>
            <span class="s2">&quot;eqRegion&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fissileFraction&quot;</span><span class="p">,</span>
        <span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">problemParam</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># be warned, changing this might break unit tests on input file generations</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{type}</span><span class="s2"> </span><span class="si">{name}</span><span class="s2"> at </span><span class="si">{loc}</span><span class="s2"> XS: </span><span class="si">{xs}</span><span class="s2"> BU GP: </span><span class="si">{bu}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getType</span><span class="p">(),</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span>
            <span class="n">xs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">xsType</span><span class="p">,</span>
            <span class="n">bu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buGroup</span><span class="p">,</span>
            <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getLocation</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Custom deepcopy behavior to prevent duplication of macros and _lumpedFissionProducts.</span>

<span class="sd">        We detach the recursive links to the parent and the reactor to prevent blocks carrying large</span>
<span class="sd">        independent copies of stale reactors in memory. If you make a new block, you must add it to</span>
<span class="sd">        an assembly and a reactor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add self to memo to prevent child objects from duplicating the parent block</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

        <span class="c1"># use __getstate__ and __setstate__ pickle-methods to initialize</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>  <span class="c1"># __getstate__ removes parent</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;macros&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;_lumpedFissionProducts&quot;</span><span class="p">]</span>
        <span class="n">b</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>

        <span class="c1"># assign macros and LFP</span>
        <span class="n">b</span><span class="o">.</span><span class="n">macros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">macros</span>
        <span class="n">b</span><span class="o">.</span><span class="n">_lumpedFissionProducts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lumpedFissionProducts</span>

        <span class="k">return</span> <span class="n">b</span>

<div class="viewcode-block" id="Block.createHomogenizedCopy"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.createHomogenizedCopy">[docs]</a>    <span class="k">def</span> <span class="nf">createHomogenizedCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pinSpatialLocators</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a copy of a block.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Used to implement a copy function for specific block types that can be much faster than a</span>
<span class="sd">        deepcopy by glossing over details that may be unnecessary in certain contexts.</span>

<span class="sd">        This base class implementation is just a deepcopy of the block, in full detail (not</span>
<span class="sd">        homogenized).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">armi.reactor.reactors</span> <span class="kn">import</span> <span class="n">Core</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAncestor</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Core</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">c</span>

<div class="viewcode-block" id="Block.makeName"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.makeName">[docs]</a>    <span class="k">def</span> <span class="nf">makeName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemNum</span><span class="p">,</span> <span class="n">axialIndex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a standard block from assembly number.</span>

<span class="sd">        This also sets the block-level assembly-num param.</span>

<span class="sd">        Once, we used a axial-character suffix to represent the axial index, but this is inherently</span>
<span class="sd">        limited so we switched to a numerical name. The axial suffix needs can be brought in to</span>
<span class="sd">        plugins that require them.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; makeName(120, 5)</span>
<span class="sd">        &#39;B0120-005&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span> <span class="o">=</span> <span class="n">assemNum</span>
        <span class="k">return</span> <span class="s2">&quot;B</span><span class="si">{0:04d}</span><span class="s2">-</span><span class="si">{1:03d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">assemNum</span><span class="p">,</span> <span class="n">axialIndex</span><span class="p">)</span></div>

<div class="viewcode-block" id="Block.getSmearDensity"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getSmearDensity">[docs]</a>    <span class="k">def</span> <span class="nf">getSmearDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the smear density of pins in this block.</span>

<span class="sd">        Smear density is the area of the fuel divided by the area of the space available for fuel</span>
<span class="sd">        inside the cladding. Other space filled with solid materials is not considered available. If</span>
<span class="sd">        all the area is fuel, it has 100% smear density. Lower smear density allows more room for</span>
<span class="sd">        swelling.</span>

<span class="sd">        .. warning:: This requires circular fuel and circular cladding. Designs that vary</span>
<span class="sd">            from this will be wrong. It may make sense in the future to put this somewhere a</span>
<span class="sd">            bit more design specific.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This only considers circular objects. If you have a cladding that is not a circle, it will</span>
<span class="sd">        be ignored.</span>

<span class="sd">        Negative areas can exist for void gaps in the fuel pin. A negative area in a gap represents</span>
<span class="sd">        overlap area between two solid components. To account for this additional space within the</span>
<span class="sd">        pin cladding the abs(negativeArea) is added to the inner cladding area.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cold : bool, optional</span>
<span class="sd">            If false, returns the smear density at hot temperatures</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smearDensity : float</span>
<span class="sd">            The smear density as a fraction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fuels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fuels</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>  <span class="c1"># Smear density is not computed for non-fuel blocks</span>

        <span class="n">circles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponentsOfShape</span><span class="p">(</span><span class="n">components</span><span class="o">.</span><span class="n">Circle</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">circles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get smear density of </span><span class="si">{}</span><span class="s2">. There are no circular components.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">clads</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">circles</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">clads</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get smear density of </span><span class="si">{}</span><span class="s2">. There are no clad components.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Compute component areas</span>
        <span class="n">cladID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="k">for</span> <span class="n">clad</span> <span class="ow">in</span> <span class="n">clads</span><span class="p">])</span>
        <span class="n">innerCladdingArea</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">cladID</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">fuelComponentArea</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">unmovableComponentArea</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">negativeArea</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSortedComponentsInsideOfComponent</span><span class="p">(</span><span class="n">clads</span><span class="o">.</span><span class="n">pop</span><span class="p">()):</span>
            <span class="n">componentArea</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getArea</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isFuel</span><span class="p">():</span>
                <span class="n">fuelComponentArea</span> <span class="o">+=</span> <span class="n">componentArea</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">SLUG</span><span class="p">):</span>
                <span class="c1"># this flag designates that this clad/slug combination isn&#39;t fuel and shouldn&#39;t be</span>
                <span class="c1"># counted in the average</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">containsSolidMaterial</span><span class="p">():</span>
                    <span class="n">unmovableComponentArea</span> <span class="o">+=</span> <span class="n">componentArea</span>
                <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">containsVoidMaterial</span><span class="p">()</span> <span class="ow">and</span> <span class="n">componentArea</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cold</span><span class="p">:</span>  <span class="c1"># will error out soon</span>
                        <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> with id </span><span class="si">{}</span><span class="s2"> and od </span><span class="si">{}</span><span class="s2"> has negative area at cold dimensions&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">c</span><span class="p">,</span>
                                <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                                <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">negativeArea</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">componentArea</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cold</span> <span class="ow">and</span> <span class="n">negativeArea</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Negative component areas exist on </span><span class="si">{}</span><span class="s2">. Check that the cold dimensions are properly aligned &quot;</span>
                <span class="s2">&quot;and no components overlap.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">innerCladdingArea</span> <span class="o">+=</span> <span class="n">negativeArea</span>  <span class="c1"># See note 2</span>
        <span class="n">totalMovableArea</span> <span class="o">=</span> <span class="n">innerCladdingArea</span> <span class="o">-</span> <span class="n">unmovableComponentArea</span>
        <span class="n">smearDensity</span> <span class="o">=</span> <span class="n">fuelComponentArea</span> <span class="o">/</span> <span class="n">totalMovableArea</span>

        <span class="k">return</span> <span class="n">smearDensity</span></div>

<div class="viewcode-block" id="Block.autoCreateSpatialGrids"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.autoCreateSpatialGrids">[docs]</a>    <span class="k">def</span> <span class="nf">autoCreateSpatialGrids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a spatialGrid for a Block.</span>

<span class="sd">        Blocks do not always have a spatialGrid from Blueprints, but, some Blocks can have their</span>
<span class="sd">        spatialGrids inferred based on the multiplicty of their components.</span>
<span class="sd">        This would add the ability to create a spatialGrid for a Block and give its children</span>
<span class="sd">        the corresponding spatialLocators if certain conditions are met.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the multiplicities of the block are not only 1 or N or if generated ringNumber leads</span>
<span class="sd">            to more positions than necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.getMgFlux"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getMgFlux">[docs]</a>    <span class="k">def</span> <span class="nf">getMgFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the multigroup neutron flux in [n/cm^2/s].</span>

<span class="sd">        The first entry is the first energy group (fastest neutrons). Each additional</span>
<span class="sd">        group is the next energy group, as set in the ISOTXS library.</span>

<span class="sd">        It is stored integrated over volume on self.p.mgFlux</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adjoint : bool, optional</span>
<span class="sd">            Return adjoint flux instead of real</span>

<span class="sd">        average : bool, optional</span>
<span class="sd">            If true, will return average flux between latest and previous. Doesn&#39;t work</span>
<span class="sd">            for pin detailed yet</span>

<span class="sd">        volume: float, optional</span>
<span class="sd">            If average=True, the volume-integrated flux is divided by volume before being returned.</span>
<span class="sd">            The user may specify a volume, or the function will obtain the block volume directly.</span>

<span class="sd">        gamma : bool, optional</span>
<span class="sd">            Whether to return the neutron flux or the gamma flux.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        flux : multigroup neutron flux in [n/cm^2/s]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">composites</span><span class="o">.</span><span class="n">ArmiObject</span><span class="o">.</span><span class="n">getMgFlux</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="n">adjoint</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">average</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">lastMgFlux</span><span class="p">):</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>
            <span class="n">lastFlux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">lastMgFlux</span> <span class="o">/</span> <span class="n">volume</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="p">(</span><span class="n">flux</span> <span class="o">+</span> <span class="n">lastFlux</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">return</span> <span class="n">flux</span></div>

<div class="viewcode-block" id="Block.setPinMgFluxes"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setPinMgFluxes">[docs]</a>    <span class="k">def</span> <span class="nf">setPinMgFluxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fluxes</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the pin-detailed multi-group neutron flux.</span>

<span class="sd">        The [g][i] indexing is transposed to be a list of lists, one for each pin. This makes it</span>
<span class="sd">        simple to do depletion for each pin, etc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fluxes : 2-D list of floats</span>
<span class="sd">            The block-level pin multigroup fluxes. fluxes[g][i] represents the flux in group g for</span>
<span class="sd">            pin i. Flux units are the standard n/cm^2/s.</span>
<span class="sd">            The &quot;ARMI pin ordering&quot; is used, which is counter-clockwise from 3 o&#39;clock.</span>
<span class="sd">        adjoint : bool, optional</span>
<span class="sd">            Whether to set real or adjoint data.</span>
<span class="sd">        gamma : bool, optional</span>
<span class="sd">            Whether to set gamma or neutron data.</span>

<span class="sd">        Outputs</span>
<span class="sd">        -------</span>
<span class="sd">        self.p.pinMgFluxes : 2-D array of floats</span>
<span class="sd">            The block-level pin multigroup fluxes. pinMgFluxes[g][i] represents the flux in group g</span>
<span class="sd">            for pin i. Flux units are the standard n/cm^2/s.</span>
<span class="sd">            The &quot;ARMI pin ordering&quot; is used, which is counter-clockwise from 3 o&#39;clock.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pinFluxes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">G</span><span class="p">,</span> <span class="n">nPins</span> <span class="o">=</span> <span class="n">fluxes</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">for</span> <span class="n">pinNum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nPins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">thisPinFlux</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">):</span>
                <span class="n">pinLoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinLocation</span><span class="p">[</span><span class="n">pinNum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pinLoc</span> <span class="o">=</span> <span class="n">pinNum</span>

            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
                <span class="n">thisPinFlux</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fluxes</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">pinLoc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">pinFluxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisPinFlux</span><span class="p">)</span>

        <span class="n">pinFluxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pinFluxes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gamma</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">adjoint</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Adjoint gamma flux is currently unsupported.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinMgFluxesGamma</span> <span class="o">=</span> <span class="n">pinFluxes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">adjoint</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinMgFluxesAdj</span> <span class="o">=</span> <span class="n">pinFluxes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinMgFluxes</span> <span class="o">=</span> <span class="n">pinFluxes</span></div>

<div class="viewcode-block" id="Block.getMicroSuffix"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getMicroSuffix">[docs]</a>    <span class="k">def</span> <span class="nf">getMicroSuffix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the microscopic library suffix (e.g. &#39;AB&#39;) for this block.</span>

<span class="sd">        DIF3D and MC2 are limited to 6 character nuclide labels. ARMI by convention uses</span>
<span class="sd">        the first 4 for nuclide name (e.g. U235, PU39, etc.) and then uses the 5th</span>
<span class="sd">        character for cross-section type and the 6th for burnup group. This allows a</span>
<span class="sd">        variety of XS sets to be built modeling substantially different blocks.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The single-letter use for xsType and buGroup limit users to 26 groups of each.</span>
<span class="sd">        ARMI will allow 2-letter xsType designations if and only if the `buGroups`</span>
<span class="sd">        setting has length 1 (i.e. no burnup groups are defined). This is useful for</span>
<span class="sd">        high-fidelity XS modeling of V&amp;V models such as the ZPPRs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buGroup</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bu</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get MicroXS suffix because </span><span class="si">{0}</span><span class="s2"> in </span><span class="si">{1}</span><span class="s2"> does not have a burnup group&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">xsType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">xsType</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xsType</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xsType</span> <span class="o">+</span> <span class="n">bu</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">xsType</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">bu</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Use of multiple burnup groups is not allowed with multi-character xs groups!&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xsType</span></div>

<div class="viewcode-block" id="Block.getHeight"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getHeight">[docs]</a>    <span class="k">def</span> <span class="nf">getHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the block height.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">height</span></div>

<div class="viewcode-block" id="Block.setHeight"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setHeight">[docs]</a>    <span class="k">def</span> <span class="nf">setHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modifiedHeight</span><span class="p">,</span> <span class="n">conserveMass</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">adjustList</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a new height of the block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        modifiedHeight : float</span>
<span class="sd">            The height of the block in cm</span>

<span class="sd">        conserveMass : bool, optional</span>
<span class="sd">            Conserve mass of nuclides in ``adjustList``.</span>

<span class="sd">        adjustList : list, optional</span>
<span class="sd">            Nuclides that will be conserved in conserving mass in the block. It is recommended to pass a list of</span>
<span class="sd">            all nuclides in the block.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        There is a coupling between block heights, the parent assembly axial mesh,</span>
<span class="sd">        and the ztop/zbottom/z params of the sibling blocks. When you set a height,</span>
<span class="sd">        all those things are invalidated. Thus, this method has to go through and</span>
<span class="sd">        update them via ``parent.calculateZCoords``. This could be inefficient</span>
<span class="sd">        though it has not been identified as a bottleneck. Possible improvements</span>
<span class="sd">        include deriving z/ztop/zbottom on the fly and invalidating the parent mesh</span>
<span class="sd">        with some kind of flag, signaling it to recompute itself on demand.</span>
<span class="sd">        Developers can get around some of the O(N^2) scaling of this by setting</span>
<span class="sd">        ``p.height`` directly but they must know to update the dependent objects</span>
<span class="sd">        after they do that. Use with care.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.reactors.Core.updateAxialMesh</span>
<span class="sd">            May need to be called after this.</span>
<span class="sd">        armi.reactor.assemblies.Assembly.calculateZCoords</span>
<span class="sd">            Recalculates z-coords, automatically called by this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">originalHeight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>  <span class="c1"># get before modifying</span>
        <span class="k">if</span> <span class="n">modifiedHeight</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot set height of block </span><span class="si">{}</span><span class="s2"> to height of </span><span class="si">{}</span><span class="s2"> cm&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">modifiedHeight</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">modifiedHeight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">conserveMass</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">originalHeight</span> <span class="o">!=</span> <span class="n">modifiedHeight</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">adjustList</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Nuclides in ``adjustList`` must be provided to conserve mass.&quot;</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">adjustDensity</span><span class="p">(</span><span class="n">originalHeight</span> <span class="o">/</span> <span class="n">modifiedHeight</span><span class="p">,</span> <span class="n">adjustList</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">calculateZCoords</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.getWettedPerimeter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getWettedPerimeter">[docs]</a>    <span class="k">def</span> <span class="nf">getWettedPerimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Block.getFlowAreaPerPin"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getFlowAreaPerPin">[docs]</a>    <span class="k">def</span> <span class="nf">getFlowAreaPerPin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the flowing coolant area of the block in cm^2, normalized to the number of pins in the block.</span>

<span class="sd">        NumPins looks for max number of fuel, clad, control, etc.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.blocks.Block.getNumPins</span>
<span class="sd">            figures out numPins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">COOLANT</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">getArea</span><span class="p">()</span> <span class="o">/</span> <span class="n">numPins</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span>
                <span class="s2">&quot;Block </span><span class="si">{}</span><span class="s2"> has 0 pins (fuel, clad, control, shield, etc.). Thus, its flow area &quot;</span>
                <span class="s2">&quot;per pin is undefined.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Block.getHydraulicDiameter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getHydraulicDiameter">[docs]</a>    <span class="k">def</span> <span class="nf">getHydraulicDiameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Block.adjustUEnrich"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.adjustUEnrich">[docs]</a>    <span class="k">def</span> <span class="nf">adjustUEnrich</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newEnrich</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust U-235/U-238 mass ratio to a mass enrichment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newEnrich : float</span>
<span class="sd">            New U-235 enrichment in mass fraction</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        completeInitialLoading must be run because adjusting the enrichment actually</span>
<span class="sd">        changes the mass slightly and you can get negative burnups, which you do not want.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fuels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fuels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fuel</span> <span class="ow">in</span> <span class="n">fuels</span><span class="p">:</span>
                <span class="n">fuel</span><span class="o">.</span><span class="n">adjustMassEnrichment</span><span class="p">(</span><span class="n">newEnrich</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no fuel in this block</span>
            <span class="n">tU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensity</span><span class="p">(</span><span class="s2">&quot;U235&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensity</span><span class="p">(</span><span class="s2">&quot;U238&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tU</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setNumberDensity</span><span class="p">(</span><span class="s2">&quot;U235&quot;</span><span class="p">,</span> <span class="n">tU</span> <span class="o">*</span> <span class="n">newEnrich</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setNumberDensity</span><span class="p">(</span><span class="s2">&quot;U238&quot;</span><span class="p">,</span> <span class="n">tU</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">newEnrich</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">completeInitialLoading</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.getLocation"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getLocation">[docs]</a>    <span class="k">def</span> <span class="nf">getLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representation of the location.</span>

<span class="sd">        .. impl:: Location of a block is retrievable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_POSI0</span>
<span class="sd">            :implements: R_ARMI_BLOCK_POSI</span>

<span class="sd">            If the block does not have its ``core`` attribute set, if the block&#39;s</span>
<span class="sd">            parent does not have a ``spatialGrid`` attribute, or if the block</span>
<span class="sd">            does not have its location defined by its ``spatialLocator`` attribute,</span>
<span class="sd">            return a string indicating that it is outside of the core.</span>

<span class="sd">            Otherwise, use the :py:class:`~armi.reactor.grids.Grid.getLabel` static</span>
<span class="sd">            method to convert the block&#39;s indices into a string like &quot;XXX-YYY-ZZZ&quot;.</span>
<span class="sd">            For hexagonal geometry, &quot;XXX&quot; is the zero-padded hexagonal core ring,</span>
<span class="sd">            &quot;YYY&quot; is the zero-padded position in that ring, and &quot;ZZZ&quot; is the zero-padded</span>
<span class="sd">            block axial index from the bottom of the core.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getLabel</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;ExCore&quot;</span></div>

<div class="viewcode-block" id="Block.coords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinates of the block.</span>

<span class="sd">        .. impl:: Coordinates of a block are queryable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_POSI1</span>
<span class="sd">            :implements: R_ARMI_BLOCK_POSI</span>

<span class="sd">            Calls to the :py:meth:`~armi.reactor.grids.locations.IndexLocation.getGlobalCoordinates`</span>
<span class="sd">            method of the block&#39;s ``spatialLocator`` attribute, which recursively</span>
<span class="sd">            calls itself on all parents of the block to get the coordinates of the</span>
<span class="sd">            block&#39;s centroid in 3D cartesian space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.setBuLimitInfo"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setBuLimitInfo">[docs]</a>    <span class="k">def</span> <span class="nf">setBuLimitInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets burnup limit based on igniter, feed, etc.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buRate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># might be cycle 1 or a non-burning block</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">timeToLimit</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">timeLimit</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buLimit</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBu</span>
            <span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buRate</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">residence</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">timeToLimit</span> <span class="o">=</span> <span class="p">(</span><span class="n">timeLimit</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">residence</span><span class="p">)</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">DAYS_PER_YEAR</span></div>

<div class="viewcode-block" id="Block.getMaxArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getMaxArea">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Block.getArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getArea">[docs]</a>    <span class="k">def</span> <span class="nf">getArea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the area of a block for a full core or a 1/3 core model.</span>

<span class="sd">        Area is consistent with the area in the model, so if you have a central</span>
<span class="sd">        assembly in a 1/3 symmetric model, this will return 1/3 of the total</span>
<span class="sd">        area of the physical assembly. This way, if you take the sum</span>
<span class="sd">        of the areas in the core (or count the atoms in the core, etc.),</span>
<span class="sd">        you will have the proper number after multiplying by the model symmetry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cold : bool</span>
<span class="sd">            flag to indicate that cold (as input) dimensions are required</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This might not work for a 1/6 core model (due to symmetry line issues).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        area : float (cm^2)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.blocks.Block.getMaxArea</span>
<span class="sd">            return the full area of the physical assembly disregarding model symmetry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this caching requires that you clear the cache every time you adjust anything</span>
        <span class="c1"># including temperature and dimensions.</span>
        <span class="n">area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getCached</span><span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">area</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">area</span>

        <span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
            <span class="n">myArea</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getArea</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">+=</span> <span class="n">myArea</span>
        <span class="n">fullArea</span> <span class="o">=</span> <span class="n">a</span>

        <span class="c1"># correct the fullHexArea by the symmetry factor</span>
        <span class="c1"># this factor determines if the hex has been clipped by symmetry lines</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">fullArea</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSymmetryFactor</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_setCache</span><span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">,</span> <span class="n">area</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">area</span></div>

<div class="viewcode-block" id="Block.getVolume"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getVolume">[docs]</a>    <span class="k">def</span> <span class="nf">getVolume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the volume of a block.</span>

<span class="sd">        .. impl:: Volume of block is retrievable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_DIMS0</span>
<span class="sd">            :implements: R_ARMI_BLOCK_DIMS</span>

<span class="sd">            Loops over all the components in the block, calling</span>
<span class="sd">            :py:meth:`~armi.reactor.components.component.Component.getVolume` on</span>
<span class="sd">            each and summing the result. The summed value is then divided by</span>
<span class="sd">            the symmetry factor of the block to account for reduced volumes of</span>
<span class="sd">            blocks in certain symmetric representations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        volume : float</span>
<span class="sd">            Block or component volume in cm^3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use symmetryFactor in case the assembly is sitting on a boundary and needs to be cut in half, etc.</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vol</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSymmetryFactor</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.getSymmetryFactor"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getSymmetryFactor">[docs]</a>    <span class="k">def</span> <span class="nf">getSymmetryFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a scaling factor due to symmetry on the area of the block or its components.</span>

<span class="sd">        Takes into account assemblies that are bisected or trisected by symmetry lines</span>

<span class="sd">        In 1/3 symmetric cases, the central assembly is 1/3 a full area.</span>
<span class="sd">        If edge assemblies are included in a model, the symmetry factor along</span>
<span class="sd">        both edges for overhanging assemblies should be 2.0. However,</span>
<span class="sd">        ARMI runs in most scenarios with those assemblies on the 120-edge removed,</span>
<span class="sd">        so the symmetry factor should generally be just 1.0.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.converters.geometryConverter.EdgeAssemblyChanger.scaleParamsRelatedToSymmetry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.0</span></div>

<div class="viewcode-block" id="Block.adjustDensity"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.adjustDensity">[docs]</a>    <span class="k">def</span> <span class="nf">adjustDensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">adjustList</span><span class="p">,</span> <span class="n">returnMass</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        adjusts the total density of each nuclide in adjustList by frac.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frac : float</span>
<span class="sd">            The fraction of the current density that will remain after this operation</span>

<span class="sd">        adjustList : list</span>
<span class="sd">            List of nuclide names that will be adjusted.</span>

<span class="sd">        returnMass : bool</span>
<span class="sd">            If true, will return mass difference.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mass : float</span>
<span class="sd">            Mass difference in grams. If you subtract mass, mass will be negative.</span>
<span class="sd">            If returnMass is False (default), this will always be zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updateDetailedNdens</span><span class="p">(</span><span class="n">frac</span><span class="p">,</span> <span class="n">adjustList</span><span class="p">)</span>

        <span class="n">mass</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">returnMass</span><span class="p">:</span>
            <span class="c1"># do this with a flag to enable faster operation when mass is not needed.</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>

        <span class="n">numDensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNuclideNumberDensities</span><span class="p">(</span><span class="n">adjustList</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nuclideName</span><span class="p">,</span> <span class="n">dens</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">adjustList</span><span class="p">,</span> <span class="n">numDensities</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dens</span><span class="p">:</span>
                <span class="c1"># don&#39;t modify zeros.</span>
                <span class="k">continue</span>
            <span class="n">newDens</span> <span class="o">=</span> <span class="n">dens</span> <span class="o">*</span> <span class="n">frac</span>
            <span class="c1"># add a little so components remember</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setNumberDensity</span><span class="p">(</span><span class="n">nuclideName</span><span class="p">,</span> <span class="n">newDens</span> <span class="o">+</span> <span class="n">TRACE_NUMBER_DENSITY</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">returnMass</span><span class="p">:</span>
                <span class="n">mass</span> <span class="o">+=</span> <span class="n">densityTools</span><span class="o">.</span><span class="n">getMassInGrams</span><span class="p">(</span><span class="n">nuclideName</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">newDens</span> <span class="o">-</span> <span class="n">dens</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mass</span></div>

    <span class="k">def</span> <span class="nf">_updateDetailedNdens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">adjustList</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update detailed number density which is used by hi-fi depleters such as ORIGEN.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This will perturb all number densities so it is assumed that if one of the active densities</span>
<span class="sd">        is perturbed, all of htem are perturbed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">detailedNDens</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># BOL assems get expanded to a reference so the first check is needed so it</span>
            <span class="c1"># won&#39;t call .blueprints on None since BOL assems don&#39;t have a core/r</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">nuc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">blueprints</span><span class="o">.</span><span class="n">activeNuclides</span> <span class="k">for</span> <span class="n">nuc</span> <span class="ow">in</span> <span class="n">adjustList</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">detailedNDens</span> <span class="o">*=</span> <span class="n">frac</span>
            <span class="c1"># Other power densities do not need to be updated as they are calculated in</span>
            <span class="c1"># the global flux interface, which occurs after axial expansion from crucible</span>
            <span class="c1"># on the interface stack.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pdensDecay</span> <span class="o">*=</span> <span class="n">frac</span>

<div class="viewcode-block" id="Block.completeInitialLoading"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.completeInitialLoading">[docs]</a>    <span class="k">def</span> <span class="nf">completeInitialLoading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bolBlock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does some BOL bookkeeping to track things like BOL HM density for burnup tracking.</span>

<span class="sd">        This should run after this block is loaded up at BOC (called from</span>
<span class="sd">        Reactor.initialLoading).</span>

<span class="sd">        The original purpose of this was to get the moles HM at BOC for the moles</span>
<span class="sd">        Pu/moles HM at BOL calculation.</span>

<span class="sd">        This also must be called after modifying something like the smear density or zr</span>
<span class="sd">        fraction in an optimization case. In ECPT cases, a BOL block must be passed or</span>
<span class="sd">        else the burnup will try to get based on a pre-burned value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bolBlock : Block, optional</span>
<span class="sd">            A BOL-state block of this block type, required for perturbed equilibrium cases.</span>
<span class="sd">            Must have the same enrichment as this block!</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hmDens : float</span>
<span class="sd">            The heavy metal number density of this block.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Reactor.importGeom</span>
<span class="sd">        depletion._updateBlockParametersAfterDepletion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bolBlock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bolBlock</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">hmDens</span> <span class="o">=</span> <span class="n">bolBlock</span><span class="o">.</span><span class="n">getHMDens</span><span class="p">()</span>  <span class="c1"># total homogenized heavy metal number density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">nHMAtBOL</span> <span class="o">=</span> <span class="n">hmDens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHMMoles</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">puFrac</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getPuMoles</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOL</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOL</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># non-pinned reactors (or ones without cladding) will not use smear density</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">smearDensity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSmearDensity</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">enrichmentBOL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFissileMassEnrich</span><span class="p">()</span>
        <span class="n">massHmBOL</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSymmetryFactor</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">hmMass</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">getHMMass</span><span class="p">()</span> <span class="o">*</span> <span class="n">sf</span>
            <span class="n">massHmBOL</span> <span class="o">+=</span> <span class="n">hmMass</span>
            <span class="c1"># Components have a massHmBOL parameter but not every composite will</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">components</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
                <span class="n">child</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">massHmBOL</span> <span class="o">=</span> <span class="n">hmMass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">massHmBOL</span> <span class="o">=</span> <span class="n">massHmBOL</span>

        <span class="k">return</span> <span class="n">hmDens</span></div>

<div class="viewcode-block" id="Block.setB10VolParam"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setB10VolParam">[docs]</a>    <span class="k">def</span> <span class="nf">setB10VolParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heightHot</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the b.p.initialB10ComponentVol param according to the volume of boron-10 containing components.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        heightHot : Boolean</span>
<span class="sd">            True if self.height() is cold height</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># exclude fuel components since they could have slight B10 impurity and</span>
        <span class="c1"># this metric is not relevant for fuel.</span>
        <span class="n">b10Comps</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">getNumberDensity</span><span class="p">(</span><span class="s2">&quot;B10&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">isFuel</span><span class="p">()]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">b10Comps</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># get the highest density comp dont want to sum all because some</span>
        <span class="c1"># comps might have very small impurities of boron and adding this</span>
        <span class="c1"># volume wont be conservative for captures per cc.</span>
        <span class="n">b10Comp</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">b10Comps</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">getNumberDensity</span><span class="p">(</span><span class="s2">&quot;B10&quot;</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b10Comps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;More than one boron10-containing component found  in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Only </span><span class="si">{</span><span class="n">b10Comp</span><span class="si">}</span><span class="s2"> will be considered for calculation of initialB10ComponentVol &quot;</span>
                <span class="s2">&quot;Since adding multiple volumes is not conservative for captures/cc.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;All compos found </span><span class="si">{</span><span class="n">b10Comps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isFuel</span><span class="p">():</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> has both fuel and initial b10. &quot;</span>
                <span class="s2">&quot;b10 volume may not be conserved with axial expansion.&quot;</span><span class="p">,</span>
                <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># calc volume of boron components</span>
        <span class="n">coldArea</span> <span class="o">=</span> <span class="n">b10Comp</span><span class="o">.</span><span class="n">getArea</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">coldFactor</span> <span class="o">=</span> <span class="n">b10Comp</span><span class="o">.</span><span class="n">getThermalExpansionFactor</span><span class="p">()</span> <span class="k">if</span> <span class="n">heightHot</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">coldHeight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span> <span class="o">/</span> <span class="n">coldFactor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">initialB10ComponentVol</span> <span class="o">=</span> <span class="n">coldArea</span> <span class="o">*</span> <span class="n">coldHeight</span></div>

<div class="viewcode-block" id="Block.replaceBlockWithBlock"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.replaceBlockWithBlock">[docs]</a>    <span class="k">def</span> <span class="nf">replaceBlockWithBlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bReplacement</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace the current block with the replacementBlock.</span>

<span class="sd">        Typically used in the insertion of control rods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paramsToSkip</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="o">.</span><span class="n">inCategory</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">Category</span><span class="o">.</span><span class="n">retainOnReplacement</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>
        <span class="p">)</span>

        <span class="n">tempBlock</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">bReplacement</span><span class="p">)</span>
        <span class="n">oldParams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">newParams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">tempBlock</span><span class="o">.</span><span class="n">p</span>
        <span class="k">for</span> <span class="n">paramName</span> <span class="ow">in</span> <span class="n">paramsToSkip</span><span class="p">:</span>
            <span class="n">newParams</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldParams</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span>

        <span class="c1"># update synchronization information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assigned</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span>
        <span class="n">paramDefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span>
        <span class="k">for</span> <span class="n">paramName</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">newParams</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="n">paramsToSkip</span><span class="p">:</span>
            <span class="n">paramDefs</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span><span class="o">.</span><span class="n">assigned</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">SINCE_ANYTHING</span>

        <span class="n">newComponents</span> <span class="o">=</span> <span class="n">tempBlock</span><span class="o">.</span><span class="n">getChildren</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setChildren</span><span class="p">(</span><span class="n">newComponents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.plotFlux"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.plotFlux">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">plotFlux</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="n">fName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bList2</span><span class="o">=</span><span class="p">[]):</span>
        <span class="c1"># Block.plotFlux has been moved to utils.plotting as plotBlockFlux, which is a</span>
        <span class="c1"># better fit.</span>
        <span class="c1"># We don&#39;t want to remove the plotFlux function in the Block namespace yet</span>
        <span class="c1"># in case client code is depending on this function existing here. This is just</span>
        <span class="c1"># a simple pass-through function that passes the arguments along to the actual</span>
        <span class="c1"># implementation in its new location.</span>
        <span class="n">plotBlockFlux</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="n">fName</span><span class="p">,</span> <span class="n">bList</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">adjoint</span><span class="p">,</span> <span class="n">bList2</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_updatePitchComponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the component that defines the pitch.</span>

<span class="sd">        Given a Component, compare it to the current component that defines the pitch of the Block.</span>
<span class="sd">        If bigger, replace it.</span>
<span class="sd">        We need different implementations of this to support different logic for determining the</span>
<span class="sd">        form of pitch and the concept of &quot;larger&quot;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        CartesianBlock._updatePitchComponent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Some block types don&#39;t have a clearly defined pitch (e.g. ThRZ)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">PITCH_COMPONENT_TYPE</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PITCH_COMPONENT_TYPE</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">componentPitch</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PITCH_DIMENSION</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">parameters</span><span class="o">.</span><span class="n">UnknownParameterError</span><span class="p">:</span>
            <span class="c1"># some components dont have the appropriate parameter</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">componentPitch</span> <span class="ow">and</span> <span class="p">(</span><span class="n">componentPitch</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">componentPitch</span><span class="p">)</span>

<div class="viewcode-block" id="Block.add"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">derivedMustUpdate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBuByPin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBuByPin</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mult</span><span class="p">:</span>
                <span class="c1"># this may be a little wasteful, but we can fix it later...</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBuByPin</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mult</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># maybe adding a Composite of components rather than a single</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updatePitchComponent</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>

<div class="viewcode-block" id="Block.removeAll"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.removeAll">[docs]</a>    <span class="k">def</span> <span class="nf">removeAll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recomputeAreaFractions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">recomputeAreaFractions</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">recomputeAreaFractions</span><span class="p">:</span>  <span class="c1"># only do this once</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeFractions</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.remove"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">recomputeAreaFractions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLargestComponent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PITCH_DIMENSION</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_updatePitchComponent</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">recomputeAreaFractions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeFractions</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.getComponentsThatAreLinkedTo"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getComponentsThatAreLinkedTo">[docs]</a>    <span class="k">def</span> <span class="nf">getComponentsThatAreLinkedTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine which dimensions of which components are linked to a specific dimension of a particular component.</span>

<span class="sd">        Useful for breaking fuel components up into individuals and making sure</span>
<span class="sd">        anything that was linked to the fuel mult (like the cladding mult) stays correct.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        comp : Component</span>
<span class="sd">            The component that the results are linked to</span>
<span class="sd">        dim : str</span>
<span class="sd">            The name of the dimension that the results are linked to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        linkedComps : list</span>
<span class="sd">            A list of (components,dimName) that are linked to this component, dim.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">linked</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">dimName</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">dimensionIsLinked</span><span class="p">(</span><span class="n">dimName</span><span class="p">):</span>
                    <span class="n">requiredComponent</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">requiredComponent</span> <span class="ow">is</span> <span class="n">comp</span> <span class="ow">and</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="n">linked</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">dimName</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">linked</span></div>

<div class="viewcode-block" id="Block.getComponentsInLinkedOrder"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getComponentsInLinkedOrder">[docs]</a>    <span class="k">def</span> <span class="nf">getComponentsInLinkedOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">componentList</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of the components in order of their linked-dimension dependencies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        components : list, optional</span>
<span class="sd">            A list of components to consider. If None, this block&#39;s components will be used.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This means that components other components are linked to come first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">componentList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">componentList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">()</span>
        <span class="n">cList</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">componentList</span><span class="p">)</span>
        <span class="n">orderedComponents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Loop through the components until there are none left.</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">cList</span><span class="p">:</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">cList</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>  <span class="c1"># take first item in list</span>
            <span class="n">cleared</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># innocent until proven guilty</span>
            <span class="c1"># loop through all dimensions in this component to determine its dependencies</span>
            <span class="k">for</span> <span class="n">dimName</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">candidate</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">candidate</span><span class="o">.</span><span class="n">dimensionIsLinked</span><span class="p">(</span><span class="n">dimName</span><span class="p">):</span>
                    <span class="c1"># In linked dimensions, val = (component, dimName)</span>
                    <span class="n">requiredComponent</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">requiredComponent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">orderedComponents</span><span class="p">:</span>
                        <span class="c1"># this component depends on one that is not in the ordered list yet.</span>
                        <span class="c1"># do not add it.</span>
                        <span class="n">cleared</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>  <span class="c1"># short circuit. One failed lookup is enough to flag this component as dirty.</span>
            <span class="k">if</span> <span class="n">cleared</span><span class="p">:</span>
                <span class="c1"># this candidate is free of dependencies and is ready to be added.</span>
                <span class="n">orderedComponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">counter</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">cList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;The component </span><span class="si">{0}</span><span class="s2"> in </span><span class="si">{1}</span><span class="s2"> contains a dimension that is linked to another component, &quot;</span>
                    <span class="s2">&quot; but the required component is not present in the block. They may also be other dependency fails. &quot;</span>
                    <span class="s2">&quot;The component dims are </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">,</span> <span class="n">cList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot locate linked component.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orderedComponents</span></div>

<div class="viewcode-block" id="Block.getSortedComponentsInsideOfComponent"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getSortedComponentsInsideOfComponent">[docs]</a>    <span class="k">def</span> <span class="nf">getSortedComponentsInsideOfComponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of components inside of the given component sorted from innermost to outermost.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        component : object</span>
<span class="sd">            Component to look inside of.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you just want sorted components in this block, use ``sorted(self)``.</span>
<span class="sd">        This will never include any ``DerivedShape`` objects. Since they have a derived</span>
<span class="sd">        area they don&#39;t have a well-defined dimension. For now we just ignore them.</span>
<span class="sd">        If they are desired in the future some knowledge of their dimension will be</span>
<span class="sd">        required while they are being derived.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sortedComponents</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">componentIndex</span> <span class="o">=</span> <span class="n">sortedComponents</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
        <span class="n">sortedComponents</span> <span class="o">=</span> <span class="n">sortedComponents</span><span class="p">[:</span><span class="n">componentIndex</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sortedComponents</span></div>

<div class="viewcode-block" id="Block.getNumPins"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getNumPins">[docs]</a>    <span class="k">def</span> <span class="nf">getNumPins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of pins in this block.</span>

<span class="sd">        .. impl:: Get the number of pins in a block.</span>
<span class="sd">            :id: I_ARMI_BLOCK_NPINS</span>
<span class="sd">            :implements: R_ARMI_BLOCK_NPINS</span>

<span class="sd">            Uses some simple criteria to infer the number of pins in the block.</span>

<span class="sd">            For every flag in the module list :py:data:`~armi.reactor.blocks.PIN_COMPONENTS`,</span>
<span class="sd">            loop over all components of that type in the block. If the component</span>
<span class="sd">            is an instance of :py:class:`~armi.reactor.components.basicShapes.Circle`,</span>
<span class="sd">            add its multiplicity to a list, and sum that list over all components</span>
<span class="sd">            with each given flag.</span>

<span class="sd">            After looping over all possibilities, return the maximum value returned</span>
<span class="sd">            from the process above, or if no compatible components were found,</span>
<span class="sd">            return zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nPins</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">sum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">))</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">basicShapes</span><span class="o">.</span><span class="n">Circle</span><span class="p">)</span>
                        <span class="k">else</span> <span class="mi">0</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">(</span><span class="n">compType</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">compType</span> <span class="ow">in</span> <span class="n">PIN_COMPONENTS</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">nPins</span> <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="n">nPins</span><span class="p">)</span></div>

<div class="viewcode-block" id="Block.mergeWithBlock"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.mergeWithBlock">[docs]</a>    <span class="k">def</span> <span class="nf">mergeWithBlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">otherBlock</span><span class="p">,</span> <span class="n">fraction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turns this block into a mixture of this block and some other block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        otherBlock : Block</span>
<span class="sd">            The block to mix this block with. The other block will not be modified.</span>

<span class="sd">        fraction : float</span>
<span class="sd">            Fraction of the other block to mix in with this block. If 0.1 is passed in, this block</span>
<span class="sd">            will become 90% what it originally was and 10% what the other block is.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This merges on a high level (using number densities). Components will not be merged.</span>

<span class="sd">        This is used e.g. for inserting a control block partially to get a very tight criticality</span>
<span class="sd">        control.  In this case, a control block would be merged with a duct block. It is also used</span>
<span class="sd">        when a control rod is specified as a certain length but that length does not fit exactly</span>
<span class="sd">        into a full block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numDensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">()</span>
        <span class="n">otherBlockDensities</span> <span class="o">=</span> <span class="n">otherBlock</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">()</span>
        <span class="n">newDensities</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Make sure to hit all nuclides in union of blocks</span>
        <span class="k">for</span> <span class="n">nucName</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">numDensities</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">otherBlockDensities</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">newDensities</span><span class="p">[</span><span class="n">nucName</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">fraction</span><span class="p">)</span> <span class="o">*</span> <span class="n">numDensities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">nucName</span><span class="p">,</span> <span class="mf">0.0</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">fraction</span> <span class="o">*</span> <span class="n">otherBlockDensities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">nucName</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setNumberDensities</span><span class="p">(</span><span class="n">newDensities</span><span class="p">)</span></div>

<div class="viewcode-block" id="Block.getComponentAreaFrac"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getComponentAreaFrac">[docs]</a>    <span class="k">def</span> <span class="nf">getComponentAreaFrac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the area fraction of the specified component(s) among all components in the block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or list of Flags</span>
<span class="sd">            Component types to look up</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; b.getComponentAreaFrac(Flags.CLAD)</span>
<span class="sd">        0.15</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The area fraction of the component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tFrac</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeFractions</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">tFrac</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tFrac</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No component </span><span class="si">{0}</span><span class="s2"> exists on </span><span class="si">{1}</span><span class="s2">, so area fraction is zero.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">typeSpec</span><span class="p">,</span> <span class="bp">self</span>
                <span class="p">),</span>
                <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> areaFrac is zero&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="mf">0.0</span></div>

<div class="viewcode-block" id="Block.verifyBlockDims"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.verifyBlockDims">[docs]</a>    <span class="k">def</span> <span class="nf">verifyBlockDims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Optional dimension checking.&quot;&quot;&quot;</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Block.getDim"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getDim">[docs]</a>    <span class="k">def</span> <span class="nf">getDim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">dimName</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search through blocks in this assembly and find the first component of compName.</span>
<span class="sd">        Then, look on that component for dimName.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or list of Flags</span>
<span class="sd">            Component name, e.g. Flags.FUEL, Flags.CLAD, Flags.COOLANT, ...</span>
<span class="sd">        dimName : str</span>
<span class="sd">            Dimension name, e.g. &#39;od&#39;, ...</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dimVal : float</span>
<span class="sd">            The dimension in cm.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; getDim(Flags.WIRE,&#39;od&#39;)</span>
<span class="sd">        0.01</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="n">dimName</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot get Dimension because Flag not found: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Block.getPinCenterFlatToFlat"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPinCenterFlatToFlat">[docs]</a>    <span class="k">def</span> <span class="nf">getPinCenterFlatToFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the flat-to-flat distance between the centers of opposing pins in the outermost ring.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>  <span class="c1"># no geometry can be assumed</span></div>

<div class="viewcode-block" id="Block.getWireWrapCladGap"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getWireWrapCladGap">[docs]</a>    <span class="k">def</span> <span class="nf">getWireWrapCladGap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the gap betwen the wire wrap and the clad.&quot;&quot;&quot;</span>
        <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="n">wire</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span>
        <span class="n">wireOuterRadius</span> <span class="o">=</span> <span class="n">wire</span><span class="o">.</span><span class="n">getBoundingCircleOuterDiameter</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">wireInnerRadius</span> <span class="o">=</span> <span class="n">wireOuterRadius</span> <span class="o">-</span> <span class="n">wire</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="n">cladOuterRadius</span> <span class="o">=</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">return</span> <span class="n">wireInnerRadius</span> <span class="o">-</span> <span class="n">cladOuterRadius</span></div>

<div class="viewcode-block" id="Block.getPlenumPin"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPlenumPin">[docs]</a>    <span class="k">def</span> <span class="nf">getPlenumPin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the plenum pin if it exists.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">GAP</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isPlenumPin</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">c</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Block.isPlenumPin"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.isPlenumPin">[docs]</a>    <span class="k">def</span> <span class="nf">isPlenumPin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if the specified component is a plenum pin.&quot;&quot;&quot;</span>
        <span class="c1"># This assumes that anything with the GAP flag will have a valid &#39;id&#39; dimension. If that</span>
        <span class="c1"># were not the case, then we would need to protect the call to getDimension with a</span>
        <span class="c1"># try/except</span>
        <span class="n">cIsCenterGapGap</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">components</span><span class="o">.</span><span class="n">Component</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">GAP</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">([</span><span class="n">Flags</span><span class="o">.</span><span class="n">PLENUM</span><span class="p">,</span> <span class="n">Flags</span><span class="o">.</span><span class="n">ACLP</span><span class="p">])</span> <span class="ow">and</span> <span class="n">cIsCenterGapGap</span></div>

<div class="viewcode-block" id="Block.getPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPitch">[docs]</a>    <span class="k">def</span> <span class="nf">getPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">returnComp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the center-to-center hex pitch of this block.</span>

<span class="sd">        .. impl:: Pitch of block is retrievable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_DIMS1</span>
<span class="sd">            :implements: R_ARMI_BLOCK_DIMS</span>

<span class="sd">            Uses the block&#39;s ``_pitchDefiningComponent`` to identify the component</span>
<span class="sd">            in the block that defines the pitch. Then uses the</span>
<span class="sd">            :py:meth:`~armi.reactor.components.component.Component.getPitchData`</span>
<span class="sd">            method of that component to return the pitch for the block, accounting</span>
<span class="sd">            for the component&#39;s current temperature.</span>

<span class="sd">            The ``_pitchDefiningComponent`` attribute can be set by</span>
<span class="sd">            :py:meth:`~armi.reactor.blocks.Block.setPitch`, but is typically</span>
<span class="sd">            set via a calls to :py:meth:`~armi.reactor.blocks.Block._updatePitchComponent`</span>
<span class="sd">            as components are added to the block with :py:meth:`~armi.reactor.blocks.Block.add`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        returnComp : bool, optional</span>
<span class="sd">            If true, will return the component that has the maximum pitch as well</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pitch : float or None</span>
<span class="sd">            Hex pitch in cm, if well-defined. If there is no clear component for determining pitch,</span>
<span class="sd">            returns None</span>
<span class="sd">        component : Component or None</span>
<span class="sd">            Component that has the max pitch, if returnComp == True. If no component is found to</span>
<span class="sd">            define the pitch, returns None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The block stores a reference to the component that defines the pitch, making the assumption</span>
<span class="sd">        that while the dimensions can change, the component containing the largest dimension will</span>
<span class="sd">        not. This lets us skip the search for largest component. We still need to ask the largest</span>
<span class="sd">        component for its current dimension in case its temperature changed, or was otherwise</span>
<span class="sd">        modified.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        setPitch : sets pitch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> has no valid pitch defining component&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># ask component for dimensions, since they could have changed,</span>
        <span class="c1"># due to temperature, for example.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getPitchData</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="n">returnComp</span> <span class="k">else</span> <span class="n">p</span></div>

<div class="viewcode-block" id="Block.hasPinPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.hasPinPitch">[docs]</a>    <span class="k">def</span> <span class="nf">hasPinPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if the block has enough information to calculate pin pitch.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Block.getPinPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPinPitch">[docs]</a>    <span class="k">def</span> <span class="nf">getPinPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return sub-block pitch in blocks.</span>

<span class="sd">        This assumes the spatial grid is defined by unit steps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">pitch</span></div>

<div class="viewcode-block" id="Block.getDimensions"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getDimensions">[docs]</a>    <span class="k">def</span> <span class="nf">getDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return dimensional values of the specified dimension.&quot;&quot;&quot;</span>
        <span class="n">dimVals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dimVal</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">parameters</span><span class="o">.</span><span class="n">ParameterError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">dimVal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dimVals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dimVal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dimVals</span></div>

<div class="viewcode-block" id="Block.getLargestComponent"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getLargestComponent">[docs]</a>    <span class="k">def</span> <span class="nf">getLargestComponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the component with the largest dimension of the specified type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dimension: str</span>
<span class="sd">            The name of the dimension to find the largest component of.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        largestComponent: armi.reactor.components.Component</span>
<span class="sd">            The component with the largest dimension of the specified type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">maxDim</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">largestComponent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dimVal</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">parameters</span><span class="o">.</span><span class="n">ParameterError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">dimVal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dimVal</span> <span class="o">&gt;</span> <span class="n">maxDim</span><span class="p">:</span>
                <span class="n">maxDim</span> <span class="o">=</span> <span class="n">dimVal</span>
                <span class="n">largestComponent</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">return</span> <span class="n">largestComponent</span></div>

<div class="viewcode-block" id="Block.setPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setPitch">[docs]</a>    <span class="k">def</span> <span class="nf">setPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">updateBolParams</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets outer pitch to some new value.</span>

<span class="sd">        This sets the settingPitch and actually sets the dimension of the outer hexagon.</span>

<span class="sd">        During a load (importGeom), the setDimension doesn&#39;t usually do anything except</span>
<span class="sd">        set the setting See Issue 034</span>

<span class="sd">        But during a actual case modification (e.g. in an optimization sweep, then the dimension</span>
<span class="sd">        has to be set as well.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getPitch : gets the pitch</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">setDimension</span><span class="p">(</span><span class="s2">&quot;op&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No pitch-defining component on block </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">updateBolParams</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">completeInitialLoading</span><span class="p">()</span></div>

<div class="viewcode-block" id="Block.getMfp"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getMfp">[docs]</a>    <span class="k">def</span> <span class="nf">getMfp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the mean free path for neutron or gammas in this block.</span>

<span class="sd">        .. math::</span>

<span class="sd">            &lt;\Sigma&gt; = \frac{\sum_E(\phi_e \Sigma_e dE)}{\sum_E (\phi_e dE)}  =</span>
<span class="sd">            \frac{\sum_E(\phi_e N \sum_{\text{type}}(\sigma_e)  dE}{\sum_E (\phi_e dE))}</span>

<span class="sd">        Block macro is the sum of macros of all nuclides.</span>

<span class="sd">        phi_g = flux*dE already in multigroup method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mfp, mfpAbs, diffusionLength : tuple(float, float float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMgFlux</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">flux</span><span class="p">]</span>
        <span class="n">mfpNumerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>
        <span class="n">absMfpNumerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>
        <span class="n">transportNumerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>

        <span class="n">numDensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">()</span>

        <span class="c1"># vol = self.getVolume()</span>
        <span class="k">for</span> <span class="n">nucName</span><span class="p">,</span> <span class="n">nDen</span> <span class="ow">in</span> <span class="n">numDensities</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">nucMc</span> <span class="o">=</span> <span class="n">nuclideBases</span><span class="o">.</span><span class="n">byName</span><span class="p">[</span><span class="n">nucName</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">gamma</span><span class="p">:</span>
                <span class="n">micros</span> <span class="o">=</span> <span class="n">lib</span><span class="p">[</span><span class="n">nucMc</span><span class="p">]</span><span class="o">.</span><span class="n">gammaXS</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">micros</span> <span class="o">=</span> <span class="n">lib</span><span class="p">[</span><span class="n">nucMc</span><span class="p">]</span><span class="o">.</span><span class="n">micros</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">micros</span><span class="o">.</span><span class="n">total</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># 0th order</span>
            <span class="n">transport</span> <span class="o">=</span> <span class="n">micros</span><span class="o">.</span><span class="n">transport</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># 0th order, [bn]</span>
            <span class="n">absorb</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">micros</span><span class="o">.</span><span class="n">getAbsorptionXS</span><span class="p">())</span>
            <span class="n">mfpNumerator</span> <span class="o">+=</span> <span class="n">nDen</span> <span class="o">*</span> <span class="n">total</span>  <span class="c1"># [cm]</span>
            <span class="n">absMfpNumerator</span> <span class="o">+=</span> <span class="n">nDen</span> <span class="o">*</span> <span class="n">absorb</span>
            <span class="n">transportNumerator</span> <span class="o">+=</span> <span class="n">nDen</span> <span class="o">*</span> <span class="n">transport</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
        <span class="n">mfp</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">mfpNumerator</span> <span class="o">*</span> <span class="n">flux</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span><span class="p">)</span>
        <span class="n">sigmaA</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">absMfpNumerator</span> <span class="o">*</span> <span class="n">flux</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="n">sigmaTr</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">transportNumerator</span> <span class="o">*</span> <span class="n">flux</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="n">diffusionCoeff</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">sigmaTr</span><span class="p">)</span>
        <span class="n">mfpAbs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sigmaA</span>
        <span class="n">diffusionLength</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diffusionCoeff</span> <span class="o">/</span> <span class="n">sigmaA</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mfp</span><span class="p">,</span> <span class="n">mfpAbs</span><span class="p">,</span> <span class="n">diffusionLength</span></div>

<div class="viewcode-block" id="Block.setAreaFractionsReport"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setAreaFractionsReport">[docs]</a>    <span class="k">def</span> <span class="nf">setAreaFractionsReport</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">frac</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolumeFractions</span><span class="p">():</span>
            <span class="n">report</span><span class="o">.</span><span class="n">setData</span><span class="p">(</span>
                <span class="n">c</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span>
                <span class="p">[</span><span class="s2">&quot;</span><span class="si">{0:10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getArea</span><span class="p">()),</span> <span class="s2">&quot;</span><span class="si">{0:10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">frac</span><span class="p">)],</span>
                <span class="n">report</span><span class="o">.</span><span class="n">BLOCK_AREA_FRACS</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># return the group the information went to</span>
        <span class="k">return</span> <span class="n">report</span><span class="o">.</span><span class="n">ALL</span><span class="p">[</span><span class="n">report</span><span class="o">.</span><span class="n">BLOCK_AREA_FRACS</span><span class="p">]</span></div>

<div class="viewcode-block" id="Block.getBlocks"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getBlocks">[docs]</a>    <span class="k">def</span> <span class="nf">getBlocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns all the block(s) included in this block</span>
<span class="sd">        its implemented so that methods could iterate over reactors, assemblies</span>
<span class="sd">        or single blocks without checking to see what the type of the</span>
<span class="sd">        reactor-family object is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span></div>

<div class="viewcode-block" id="Block.updateComponentDims"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.updateComponentDims">[docs]</a>    <span class="k">def</span> <span class="nf">updateComponentDims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method updates all the dimensions of the components.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is VERY useful for defining a ThRZ core out of</span>
<span class="sd">        differentialRadialSegements whose dimensions are connected together</span>
<span class="sd">        some of these dimensions are derivative and can be updated by changing</span>
<span class="sd">        dimensions in a Parameter Component or other linked components</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.components.DifferentialRadialSegment.updateDims</span>
<span class="sd">        armi.reactor.components.Parameters</span>
<span class="sd">        armi.physics.optimize.OptimizationInterface.modifyCase (look up &#39;ThRZReflectorThickness&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponentsInLinkedOrder</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">updateDims</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> has no updatedDims method -- skipping&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">))</span></div>

<div class="viewcode-block" id="Block.breakFuelComponentsIntoIndividuals"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.breakFuelComponentsIntoIndividuals">[docs]</a>    <span class="k">def</span> <span class="nf">breakFuelComponentsIntoIndividuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split block-level components (in fuel blocks) into pin-level components.</span>

<span class="sd">        The fuel component will be broken up according to its multiplicity.</span>

<span class="sd">        Order matters! The first pin component will be located at a particular (x, y), which</span>
<span class="sd">        will be used in the fluxRecon module to determine the interpolated flux.</span>

<span class="sd">        The fuel will become fuel001 through fuel169 if there are 169 pins.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fuels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fuels</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;This block contains </span><span class="si">{0}</span><span class="s2"> fuel components: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fuels</span><span class="p">),</span> <span class="n">fuels</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot break </span><span class="si">{0}</span><span class="s2"> into multiple fuel components b/c there is not a single fuel&quot;</span>
                <span class="s2">&quot; component.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">fuel</span> <span class="o">=</span> <span class="n">fuels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fuelFlags</span> <span class="o">=</span> <span class="n">fuel</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flags</span>
        <span class="n">nPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Creating </span><span class="si">{}</span><span class="s2"> individual </span><span class="si">{}</span><span class="s2"> components on </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nPins</span><span class="p">,</span> <span class="n">fuel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Handle all other components that may be linked to the fuel multiplicity</span>
        <span class="c1"># by unlinking them and setting them directly.</span>
        <span class="c1"># TODO: What about other (actual) dimensions? This is a limitation in that only fuel</span>
        <span class="c1"># compuents are duplicated, and not the entire pin. It is also a reasonable assumption with</span>
        <span class="c1"># current/historical usage of ARMI.</span>
        <span class="k">for</span> <span class="n">comp</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponentsThatAreLinkedTo</span><span class="p">(</span><span class="n">fuel</span><span class="p">,</span> <span class="s2">&quot;mult&quot;</span><span class="p">):</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">setDimension</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">nPins</span><span class="p">)</span>

        <span class="c1"># finish the first pin as a single pin</span>
        <span class="n">fuel</span><span class="o">.</span><span class="n">setDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fuel</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;fuel001&quot;</span><span class="p">)</span>
        <span class="n">fuel</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinNum</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># create all the new pin components and add them to the block with &#39;fuel001&#39; names</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># wow, only use of a non-deepcopy</span>
            <span class="n">newC</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">fuel</span><span class="p">)</span>
            <span class="n">newC</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;fuel</span><span class="si">{0:03d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># start with 002.</span>
            <span class="n">newC</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinNum</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newC</span><span class="p">)</span>

        <span class="c1"># update moles at BOL for each pin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOLByPin</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pin</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">):</span>
            <span class="c1"># Update the fuel component flags to be the same as before the split (i.e., DEPLETABLE)</span>
            <span class="n">pin</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">fuelFlags</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">molesHmBOLByPin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pin</span><span class="o">.</span><span class="n">getHMMoles</span><span class="p">())</span>
            <span class="n">pin</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">massHmBOL</span> <span class="o">/=</span> <span class="n">nPins</span></div>

<div class="viewcode-block" id="Block.getIntegratedMgFlux"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getIntegratedMgFlux">[docs]</a>    <span class="k">def</span> <span class="nf">getIntegratedMgFlux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the volume integrated multigroup neutron tracklength in [n-cm/s].</span>

<span class="sd">        The first entry is the first energy group (fastest neutrons). Each additional</span>
<span class="sd">        group is the next energy group, as set in the ISOTXS library.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adjoint : bool, optional</span>
<span class="sd">            Return adjoint flux instead of real</span>

<span class="sd">        gamma : bool, optional</span>
<span class="sd">            Whether to return the neutron flux or the gamma flux.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        integratedFlux : np.ndarray</span>
<span class="sd">            multigroup neutron tracklength in [n-cm/s]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">adjoint</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gamma</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Adjoint gamma flux is currently unsupported.&quot;</span><span class="p">)</span>
            <span class="n">integratedFlux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">adjMgFlux</span>
        <span class="k">elif</span> <span class="n">gamma</span><span class="p">:</span>
            <span class="n">integratedFlux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFluxGamma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">integratedFlux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">integratedFlux</span><span class="p">)</span></div>

<div class="viewcode-block" id="Block.getLumpedFissionProductCollection"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getLumpedFissionProductCollection">[docs]</a>    <span class="k">def</span> <span class="nf">getLumpedFissionProductCollection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get collection of LFP objects. Will work for global or block-level LFP models.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lfps : LumpedFissionProduct</span>
<span class="sd">            lfpName keys , lfp object values</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.physics.neutronics.fissionProductModel.lumpedFissionProduct.LumpedFissionProduct : LFP object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">composites</span><span class="o">.</span><span class="n">ArmiObject</span><span class="o">.</span><span class="n">getLumpedFissionProductCollection</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Block.rotate"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rad</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function for rotating a block&#39;s spatially varying variables by a specified angle (radians).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rad: float</span>
<span class="sd">            Number (in radians) specifying the angle of counter clockwise rotation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Block.setAxialExpTargetComp"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.setAxialExpTargetComp">[docs]</a>    <span class="k">def</span> <span class="nf">setAxialExpTargetComp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targetComponent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the targetComponent for the axial expansion changer.</span>

<span class="sd">        .. impl:: Set the target axial expansion components on a given block.</span>
<span class="sd">            :id: I_ARMI_MANUAL_TARG_COMP</span>
<span class="sd">            :implements: R_ARMI_MANUAL_TARG_COMP</span>

<span class="sd">            Sets the ``axialExpTargetComponent`` parameter on the block to the name of the Component</span>
<span class="sd">            which is passed in. This is then used by the</span>
<span class="sd">            :py:class:`~armi.reactor.converters.axialExpansionChanger.AxialExpansionChanger`</span>
<span class="sd">            class during axial expansion.</span>

<span class="sd">            This method is typically called from within</span>
<span class="sd">            :py:meth:`~armi.reactor.blueprints.blockBlueprint.BlockBlueprint.construct` during the</span>
<span class="sd">            process of building a Block from the blueprints.</span>

<span class="sd">        Parameter</span>
<span class="sd">        ---------</span>
<span class="sd">        targetComponent: :py:class:`Component &lt;armi.reactor.components.component.Component&gt;` object</span>
<span class="sd">            Component specified to be target component for axial expansion changer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axialExpTargetComponent</span> <span class="o">=</span> <span class="n">targetComponent</span><span class="o">.</span><span class="n">name</span></div>

<div class="viewcode-block" id="Block.getPinCoordinates"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPinCoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">getPinCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the local centroid coordinates of any pins in this block.</span>

<span class="sd">        The pins must have a CLAD-flagged component for this to work.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        localCoordinates : list</span>
<span class="sd">            list of (x,y,z) pairs representing each pin in the order they are listed as children</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This assumes hexagonal pin lattice and needs to be upgraded once more generic geometry</span>
<span class="sd">        options are needed. Only works if pins have clad.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">clad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">,</span> <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span><span class="p">):</span>
                <span class="n">coords</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">locator</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">()</span> <span class="k">for</span> <span class="n">locator</span> <span class="ow">in</span> <span class="n">clad</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">coords</span></div>

<div class="viewcode-block" id="Block.getTotalEnergyGenerationConstants"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getTotalEnergyGenerationConstants">[docs]</a>    <span class="k">def</span> <span class="nf">getTotalEnergyGenerationConstants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the total energy generation group constants for a block.</span>

<span class="sd">        Gives the total energy generation rates when multiplied by the multigroup flux.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        totalEnergyGenConstant: np.ndarray</span>
<span class="sd">            Total (fission + capture) energy generation group constants (Joules/cm)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getFissionEnergyGenerationConstants</span><span class="p">()</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCaptureEnergyGenerationConstants</span><span class="p">()</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Block.getFissionEnergyGenerationConstants"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getFissionEnergyGenerationConstants">[docs]</a>    <span class="k">def</span> <span class="nf">getFissionEnergyGenerationConstants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the fission energy generation group constants for a block.</span>

<span class="sd">        Gives the fission energy generation rates when multiplied by the multigroup</span>
<span class="sd">        flux.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fissionEnergyGenConstant: np.ndarray</span>
<span class="sd">            Energy generation group constants (Joules/cm)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError:</span>
<span class="sd">            Reports if a cross section library is not assigned to a reactor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot compute energy generation group constants without a library&quot;</span>
                <span class="s2">&quot;. Please ensure a library exists.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">xsCollections</span><span class="o">.</span><span class="n">computeFissionEnergyGenerationConstants</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Block.getCaptureEnergyGenerationConstants"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getCaptureEnergyGenerationConstants">[docs]</a>    <span class="k">def</span> <span class="nf">getCaptureEnergyGenerationConstants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the capture energy generation group constants for a block.</span>

<span class="sd">        Gives the capture energy generation rates when multiplied by the multigroup</span>
<span class="sd">        flux.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fissionEnergyGenConstant: np.ndarray</span>
<span class="sd">            Energy generation group constants (Joules/cm)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError:</span>
<span class="sd">            Reports if a cross section library is not assigned to a reactor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot compute energy generation group constants without a library&quot;</span>
                <span class="s2">&quot;. Please ensure a library exists.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">xsCollections</span><span class="o">.</span><span class="n">computeCaptureEnergyGenerationConstants</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Block.getNeutronEnergyDepositionConstants"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getNeutronEnergyDepositionConstants">[docs]</a>    <span class="k">def</span> <span class="nf">getNeutronEnergyDepositionConstants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the neutron energy deposition group constants for a block.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        energyDepConstants: np.ndarray</span>
<span class="sd">            Neutron energy generation group constants (in Joules/cm)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError:</span>
<span class="sd">            Reports if a cross section library is not assigned to a reactor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get neutron energy deposition group constants without &quot;</span>
                <span class="s2">&quot;a library. Please ensure a library exists.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">xsCollections</span><span class="o">.</span><span class="n">computeNeutronEnergyDepositionConstants</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Block.getGammaEnergyDepositionConstants"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getGammaEnergyDepositionConstants">[docs]</a>    <span class="k">def</span> <span class="nf">getGammaEnergyDepositionConstants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the gamma energy deposition group constants for a block.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        energyDepConstants: np.ndarray</span>
<span class="sd">            Energy generation group constants (in Joules/cm)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError:</span>
<span class="sd">            Reports if a cross section library is not assigned to a reactor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get gamma energy deposition group constants without &quot;</span>
                <span class="s2">&quot;a library. Please ensure a library exists.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">xsCollections</span><span class="o">.</span><span class="n">computeGammaEnergyDepositionConstants</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">lib</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMicroSuffix</span><span class="p">()</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Block.getBoronMassEnrich"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getBoronMassEnrich">[docs]</a>    <span class="k">def</span> <span class="nf">getBoronMassEnrich</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return B-10 mass fraction.&quot;&quot;&quot;</span>
        <span class="n">b10</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s2">&quot;B10&quot;</span><span class="p">)</span>
        <span class="n">b11</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s2">&quot;B11&quot;</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">b11</span> <span class="o">+</span> <span class="n">b10</span>
        <span class="k">if</span> <span class="n">total</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">b10</span> <span class="o">/</span> <span class="n">total</span></div>

<div class="viewcode-block" id="Block.getPuMoles"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getPuMoles">[docs]</a>    <span class="k">def</span> <span class="nf">getPuMoles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns total number of moles of Pu isotopes.&quot;&quot;&quot;</span>
        <span class="n">nucNames</span> <span class="o">=</span> <span class="p">[</span><span class="n">nuc</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">nuc</span> <span class="ow">in</span> <span class="n">elements</span><span class="o">.</span><span class="n">byZ</span><span class="p">[</span><span class="mi">94</span><span class="p">]</span><span class="o">.</span><span class="n">nuclides</span><span class="p">]</span>
        <span class="n">puN</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getNuclideNumberDensities</span><span class="p">(</span><span class="n">nucNames</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">puN</span>
            <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">MOLES_PER_CC_TO_ATOMS_PER_BARN_CM</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSymmetryFactor</span><span class="p">()</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Block.getUraniumMassEnrich"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.Block.getUraniumMassEnrich">[docs]</a>    <span class="k">def</span> <span class="nf">getUraniumMassEnrich</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns U-235 mass fraction assuming U-235 and U-238 only.&quot;&quot;&quot;</span>
        <span class="n">u5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s2">&quot;U235&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">u5</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="n">u8</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s2">&quot;U238&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">u5</span> <span class="o">/</span> <span class="p">(</span><span class="n">u8</span> <span class="o">+</span> <span class="n">u5</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HexBlock"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock">[docs]</a><span class="k">class</span> <span class="nc">HexBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a HexBlock.</span>

<span class="sd">    .. impl:: ARMI has the ability to create hex shaped blocks.</span>
<span class="sd">        :id: I_ARMI_BLOCK_HEX</span>
<span class="sd">        :implements: R_ARMI_BLOCK_HEX</span>

<span class="sd">        This class defines hexagonal-shaped Blocks. It inherits functionality from the parent class,</span>
<span class="sd">        Block, and defines hexagonal-specific methods including, but not limited to, querying pin</span>
<span class="sd">        pitch, pin linear power densities, hydraulic diameter, and retrieving inner and outer pitch.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">PITCH_COMPONENT_TYPE</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">_PitchDefiningComponent</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">components</span><span class="o">.</span><span class="n">Hexagon</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="n">Block</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

<div class="viewcode-block" id="HexBlock.coords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinates of the block.</span>

<span class="sd">        .. impl:: Coordinates of a block are queryable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_POSI2</span>
<span class="sd">            :implements: R_ARMI_BLOCK_POSI</span>

<span class="sd">            Calls to the :py:meth:`~armi.reactor.grids.locations.IndexLocation.getGlobalCoordinates`</span>
<span class="sd">            method of the block&#39;s ``spatialLocator`` attribute, which recursively</span>
<span class="sd">            calls itself on all parents of the block to get the coordinates of the</span>
<span class="sd">            block&#39;s centroid in 3D cartesian space.</span>

<span class="sd">            Will additionally adjust the x and y coordinates based on the block</span>
<span class="sd">            parameters ``displacementX`` and ``displacementY``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">displacementX</span> <span class="o">*</span> <span class="mf">100.0</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">displacementY</span> <span class="o">*</span> <span class="mf">100.0</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">FLOAT_DIMENSION_DECIMALS</span><span class="p">),</span>
            <span class="nb">round</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">FLOAT_DIMENSION_DECIMALS</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.createHomogenizedCopy"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.createHomogenizedCopy">[docs]</a>    <span class="k">def</span> <span class="nf">createHomogenizedCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pinSpatialLocators</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new homogenized copy of a block that is less expensive than a full deepcopy.</span>

<span class="sd">        .. impl:: Block compositions can be homogenized.</span>
<span class="sd">            :id: I_ARMI_BLOCK_HOMOG</span>
<span class="sd">            :implements: R_ARMI_BLOCK_HOMOG</span>

<span class="sd">            This method creates and returns a homogenized representation of itself in the form of a new Block.</span>
<span class="sd">            The homogenization occurs in the following manner. A single Hexagon Component is created</span>
<span class="sd">            and added to the new Block. This Hexagon Component is given the</span>
<span class="sd">            :py:class:`armi.materials.mixture._Mixture` material and a volume averaged temperature</span>
<span class="sd">            (``getAverageTempInC``). The number densities of the original Block are also stored on</span>
<span class="sd">            this new Component (:need:`I_ARMI_CMP_GET_NDENS`). Several parameters from the original block</span>
<span class="sd">            are copied onto the homogenized block (e.g., macros, lumped fission products, burnup group,</span>
<span class="sd">            number of pins, and spatial grid).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This can be used to improve performance when a new copy of a reactor needs to be</span>
<span class="sd">        built, but the full detail of the block (including component geometry, material,</span>
<span class="sd">        number density, etc.) is not required for the targeted physics solver being applied</span>
<span class="sd">        to the new reactor model.</span>

<span class="sd">        The main use case is for the uniform mesh converter (UMC). Frequently, a deterministic</span>
<span class="sd">        neutronics solver will require a uniform mesh reactor, which is produced by the UMC.</span>
<span class="sd">        Many deterministic solvers for fast spectrum reactors will also treat the individual</span>
<span class="sd">        blocks as homogenized mixtures. Since the neutronics solver does not need to know about</span>
<span class="sd">        the geometric and material details of the individual child components within a block,</span>
<span class="sd">        we can save significant effort while building the uniform mesh reactor with the UMC</span>
<span class="sd">        by omitting this detailed data and only providing the necessary level of detail for</span>
<span class="sd">        the uniform mesh reactor: number densities on each block.</span>

<span class="sd">        Individual components within a block can have different temperatures, and this</span>
<span class="sd">        can affect cross sections. This temperature variation is captured by the lattice physics</span>
<span class="sd">        module. As long as temperature distribution is correctly captured during cross section</span>
<span class="sd">        generation, it doesn&#39;t need to be transferred to the neutronics solver directly through</span>
<span class="sd">        this copy operation.</span>

<span class="sd">        If you make a new block, you must add it to an assembly and a reactor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        b</span>
<span class="sd">            A homogenized block containing a single Hexagon Component that contains an</span>
<span class="sd">            average temperature and the number densities from the original block.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.converters.uniformMesh.UniformMeshGeometryConverter.makeAssemWithUniformMesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span> <span class="n">height</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">())</span>
        <span class="n">b</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getType</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flags</span><span class="p">)</span>

        <span class="c1"># assign macros and LFP</span>
        <span class="n">b</span><span class="o">.</span><span class="n">macros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">macros</span>
        <span class="n">b</span><span class="o">.</span><span class="n">_lumpedFissionProducts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lumpedFissionProducts</span>
        <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buGroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buGroup</span>

        <span class="n">hexComponent</span> <span class="o">=</span> <span class="n">Hexagon</span><span class="p">(</span>
            <span class="s2">&quot;homogenizedHex&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_Mixture&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getAverageTempInC</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getAverageTempInC</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pitchDefiningComponent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">hexComponent</span><span class="o">.</span><span class="n">setNumberDensities</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getNumberDensities</span><span class="p">())</span>
        <span class="n">b</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">hexComponent</span><span class="p">)</span>

        <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">nPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">nPins</span>
        <span class="k">if</span> <span class="n">pinSpatialLocators</span><span class="p">:</span>
            <span class="c1"># create a null component with cladding flags and spatialLocator from source block&#39;s</span>
            <span class="c1"># clad components in case pin locations need to be known for physics solver</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">):</span>
                <span class="n">cladComponents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">clad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cladComponents</span><span class="p">):</span>
                    <span class="n">pinComponent</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;voidPin</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;Void&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getAverageTempInC</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getAverageTempInC</span><span class="p">(),</span>
                        <span class="mf">0.0</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">pinComponent</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="s2">&quot;pin&quot;</span><span class="p">,</span> <span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
                    <span class="n">pinComponent</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">pinComponent</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">,</span> <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span>
                    <span class="p">):</span>
                        <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                            <span class="nb">list</span><span class="p">(</span><span class="n">pinComponent</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
                        <span class="p">):</span>
                            <span class="n">i1</span><span class="o">.</span><span class="n">associate</span><span class="p">(</span><span class="n">i2</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
                    <span class="n">pinComponent</span><span class="o">.</span><span class="n">setDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">,</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">))</span>
                    <span class="n">b</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pinComponent</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span>

        <span class="k">return</span> <span class="n">b</span></div>

<div class="viewcode-block" id="HexBlock.getMaxArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getMaxArea">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the max area of this block if it was totally full.</span>

<span class="sd">        .. impl:: Area of block is retrievable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_DIMS2</span>
<span class="sd">            :implements: R_ARMI_BLOCK_DIMS</span>

<span class="sd">            This method first retrieves the pitch of the hexagonal Block</span>
<span class="sd">            (:need:`I_ARMI_UTIL_HEXAGON0`) and then leverages the</span>
<span class="sd">            area calculation via :need:`I_ARMI_UTIL_HEXAGON0`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pitch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPitch</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pitch</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">area</span><span class="p">(</span><span class="n">pitch</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getDuctIP"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getDuctIP">[docs]</a>    <span class="k">def</span> <span class="nf">getDuctIP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the duct IP dimension.</span>

<span class="sd">        .. impl:: IP dimension is retrievable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_DIMS3</span>
<span class="sd">            :implements: R_ARMI_BLOCK_DIMS</span>

<span class="sd">            This method retrieves the duct Component and quieries</span>
<span class="sd">            it&#39;s inner pitch directly. If the duct is missing or if there</span>
<span class="sd">            are multiple duct Components, an error will be raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">duct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">duct</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;ip&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getDuctOP"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getDuctOP">[docs]</a>    <span class="k">def</span> <span class="nf">getDuctOP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the duct OP dimension.</span>

<span class="sd">        .. impl:: OP dimension is retrievable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_DIMS4</span>
<span class="sd">            :implements: R_ARMI_BLOCK_DIMS</span>

<span class="sd">            This method retrieves the duct Component and quieries</span>
<span class="sd">            its outer pitch directly. If the duct is missing or if there</span>
<span class="sd">            are multiple duct Components, an error will be raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">duct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">duct</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;op&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.initializePinLocations"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.initializePinLocations">[docs]</a>    <span class="k">def</span> <span class="nf">initializePinLocations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize pin locations.&quot;&quot;&quot;</span>
        <span class="n">nPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinLocation</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nPins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="HexBlock.setPinPowers"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.setPinPowers">[docs]</a>    <span class="k">def</span> <span class="nf">setPinPowers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">powers</span><span class="p">,</span> <span class="n">powerKeySuffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the pin linear power densities of this block for the current rotation.</span>
<span class="sd">        The linear densities are represented by the *linPowByPin* parameter.</span>

<span class="sd">        It is assumed that :py:meth:`.initializePinLocations` has already been executed</span>
<span class="sd">        for fueled blocks in order to access the *pinLocation* parameter. The</span>
<span class="sd">        *pinLocation* parameter is not accessed for non-fueled blocks.</span>

<span class="sd">        The *linPowByPin* parameter can be directly assigned to instead of using this</span>
<span class="sd">        method if the multiplicity of the pins in the block is equal to the number of</span>
<span class="sd">        pins in the block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        powers : list of floats, required</span>
<span class="sd">            The block-level pin linear power densities. powers[i] represents the average</span>
<span class="sd">            linear power density of pin i. The units of linear power density is watts/cm</span>
<span class="sd">            (i.e., watts produced per cm of pin length). The &quot;ARMI pin ordering&quot; must be</span>
<span class="sd">            be used, which is counter-clockwise from 3 o&#39;clock.</span>

<span class="sd">        powerKeySuffix: str, optional</span>
<span class="sd">            Must be either an empty string, :py:const:`NEUTRON &lt;armi.physics.neutronics.const.NEUTRON&gt;`,</span>
<span class="sd">            or :py:const:`GAMMA &lt;armi.physics.neutronics.const.GAMMA&gt;`. Defaults to empty</span>
<span class="sd">            string.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method can handle assembly rotations by using the *pinLocation* parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numPins</span> <span class="ow">or</span> <span class="n">numPins</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">powers</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid power data for </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">numPins</span><span class="si">}</span><span class="s2"> pins.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; Got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">powers</span><span class="p">)</span><span class="si">}</span><span class="s2"> entries in powers: </span><span class="si">{</span><span class="n">powers</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">powerKey</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;linPowByPin</span><span class="si">{</span><span class="n">powerKeySuffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">powerKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numPins</span><span class="p">)</span>

        <span class="c1"># Loop through rings. The *pinLocation* parameter is only accessed for fueled</span>
        <span class="c1"># blocks; it is assumed that non-fueled blocks do not use a rotation map.</span>
        <span class="k">for</span> <span class="n">pinNum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numPins</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">):</span>
                <span class="c1"># -1 is needed in order to map from pinLocations to list index</span>
                <span class="n">pinLoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinLocation</span><span class="p">[</span><span class="n">pinNum</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pinLoc</span> <span class="o">=</span> <span class="n">pinNum</span>
            <span class="n">pinLinPow</span> <span class="o">=</span> <span class="n">powers</span><span class="p">[</span><span class="n">pinLoc</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">powerKey</span><span class="p">][</span><span class="n">pinNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">pinLinPow</span>

        <span class="c1"># If using the *powerKeySuffix* parameter, we also need to set total power, which</span>
        <span class="c1"># is sum of neutron and gamma powers. We assume that a solo gamma calculation</span>
        <span class="c1"># to set total power does not make sense.</span>
        <span class="k">if</span> <span class="n">powerKeySuffix</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">powerKeySuffix</span> <span class="o">==</span> <span class="n">GAMMA</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;linPowByPin</span><span class="si">{</span><span class="n">NEUTRON</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;Neutron power has not been set yet. Cannot set total power for &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">UnboundLocalError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">linPowByPin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;linPowByPin</span><span class="si">{</span><span class="n">NEUTRON</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">powerKey</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">linPowByPin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">powerKey</span><span class="p">]</span></div>

<div class="viewcode-block" id="HexBlock.rotate"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rad</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates a block&#39;s spatially varying parameters by a specified angle in the</span>
<span class="sd">        counter-clockwise direction.</span>

<span class="sd">        The parameters must have a ParamLocation of either CORNERS or EDGES and must be a</span>
<span class="sd">        Python list of length 6 in order to be eligible for rotation; all parameters that</span>
<span class="sd">        do not meet these two criteria are not rotated.</span>

<span class="sd">        The pin indexing, as stored on the ``pinLocation`` parameter, is also updated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rad: float, required</span>
<span class="sd">            Angle of counter-clockwise rotation in units of radians. Rotations must be</span>
<span class="sd">            in 60-degree increments (i.e., PI/6, PI/3, PI, 2 * PI/3, 5 * PI/6,</span>
<span class="sd">            and 2 * PI)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rotNum</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">rad</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">60</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rotatePins</span><span class="p">(</span><span class="n">rotNum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rotateBoundaryParameters</span><span class="p">(</span><span class="n">rotNum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rotateDisplacement</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_rotateBoundaryParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotNum</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rotate any parameters defined on the corners or edge of bounding hexagon.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rotNum : int</span>
<span class="sd">            Rotation number between zero and five, inclusive, specifying how many</span>
<span class="sd">            rotations have taken place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="o">.</span><span class="n">atLocation</span><span class="p">(</span><span class="n">ParamLocation</span><span class="o">.</span><span class="n">CORNERS</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>
        <span class="n">names</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="o">.</span><span class="n">atLocation</span><span class="p">(</span><span class="n">ParamLocation</span><span class="o">.</span><span class="n">EDGES</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">original</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
                    <span class="c1"># Rotate by making the -rotNum item be first</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">iterables</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="o">-</span><span class="n">rotNum</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Hasn&#39;t been defined yet, no warning needed.</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;No rotation method defined for spatial parameters that aren&#39;t &quot;</span>
                        <span class="s2">&quot;defined once per hex edge/corner. No rotation performed &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;on </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="c1"># this is a scalar and there shouldn&#39;t be any rotation.</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">original</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># param is not set yet. no rotations as well.</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;b.rotate() method received unexpected data type for </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> on block </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;expected list, np.ndarray, int, or float. received </span><span class="si">{</span><span class="n">original</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rotateDisplacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rad</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="c1"># This specifically uses the .get() functionality to avoid an error if this</span>
        <span class="c1"># parameter does not exist.</span>
        <span class="n">dispx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;displacementX&quot;</span><span class="p">)</span>
        <span class="n">dispy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;displacementY&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dispx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dispy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">displacementX</span> <span class="o">=</span> <span class="n">dispx</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">-</span> <span class="n">dispy</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">displacementY</span> <span class="o">=</span> <span class="n">dispx</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">dispy</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rotatePins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotNum</span><span class="p">,</span> <span class="n">justCompute</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate the pins of a block, which means rotating the indexing of pins. Note that this does</span>
<span class="sd">        not rotate all block quantities, just the pins.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rotNum : int, required</span>
<span class="sd">            An integer from 0 to 5, indicating the number of counterclockwise 60-degree rotations</span>
<span class="sd">            from the CURRENT orientation. Degrees of counter-clockwise rotation = 60*rot</span>

<span class="sd">        justCompute : boolean, optional</span>
<span class="sd">            If True, rotateIndexLookup will be returned but NOT assigned to the object parameter</span>
<span class="sd">            self.p.pinLocation. If False, rotateIndexLookup will be returned AND assigned to the</span>
<span class="sd">            object variable self.p.pinLocation.  Useful for figuring out which rotation is best</span>
<span class="sd">            to minimize burnup, etc.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotateIndexLookup : dict of ints</span>
<span class="sd">            This is an index lookup (or mapping) between pin ids and pin locations. The pin</span>
<span class="sd">            indexing is 1-D (not ring,pos or GEODST). The &quot;ARMI pin ordering&quot; is used for location,</span>
<span class="sd">            which is counter-clockwise from 1 o&#39;clock. Pin ids are always consecutively</span>
<span class="sd">            ordered starting at 1, while pin locations are not once a rotation has been</span>
<span class="sd">            applied.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Changing (x,y) positions of pins does NOT constitute rotation, because the indexing of pin</span>
<span class="sd">        atom densities must be re-ordered.  Re-order indexing of pin-level quantities, NOT (x,y)</span>
<span class="sd">        locations of pins.  Otherwise, subchannel input will be in wrong order.</span>

<span class="sd">        How rotations works is like this. There are pins with unique pin numbers in each block.</span>
<span class="sd">        These pin numbers will not change no matter what happens to a block, so if you have pin 1,</span>
<span class="sd">        you always have pin 1. However, these pins are all in pinLocations, and these are what</span>
<span class="sd">        change with rotations. At BOL, a pin&#39;s pinLocation is equal to its pin number, but after</span>
<span class="sd">        a rotation, this will no longer be so.</span>

<span class="sd">        So, all params that don&#39;t care about exactly where in space the pin is (such as depletion)</span>
<span class="sd">        can just use the pin number, but anything that needs to know the spatial location (such as</span>
<span class="sd">        fluxRecon, which interpolates the flux spatially, or subchannel codes, which needs to know where the</span>
<span class="sd">        power is) need to map through the pinLocation parameters.</span>

<span class="sd">        This method rotates the pins by changing the pinLocation parameter.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.blocks.HexBlock.rotate</span>
<span class="sd">            Rotates the entire block (pins, ducts, and spatial quantities).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">            rotateIndexLookup[i_after_rotation-1] = i_before_rotation-1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">rotNum</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot rotate </span><span class="si">{0}</span><span class="s2"> to rotNum </span><span class="si">{1}</span><span class="s2">. Must be 0-5. &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotNum</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Pin numbers start at 1. Number of pins in the block is assumed to be based on</span>
        <span class="c1"># cladding count.</span>
        <span class="n">numPins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="n">rotateIndexLookup</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numPins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numPins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># Look up the current orientation and add this to it. The math below just rotates</span>
        <span class="c1"># from the reference point so we need a total rotation.</span>
        <span class="n">rotNum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">getRotationNum</span><span class="p">()</span> <span class="o">+</span> <span class="n">rotNum</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span><span class="p">)</span>

        <span class="c1"># non-trivial rotation requested</span>
        <span class="c1"># start at 2 because pin 1 never changes (it&#39;s in the center!)</span>
        <span class="k">for</span> <span class="n">pinNum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">numPins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rotNum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Rotation to reference orientation. Pin locations are pin IDs.</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newPinLocation</span> <span class="o">=</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">getIndexOfRotatedCell</span><span class="p">(</span><span class="n">pinNum</span><span class="p">,</span> <span class="n">rotNum</span><span class="p">)</span>
                <span class="c1"># Assign &quot;before&quot; and &quot;after&quot; pin indices to the index lookup</span>
                <span class="n">rotateIndexLookup</span><span class="p">[</span><span class="n">pinNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">newPinLocation</span>

        <span class="c1"># Because the above math creates indices based on the absolute rotation number,</span>
        <span class="c1"># the old values of pinLocation (if they&#39;ve been set in the past) can be overwritten</span>
        <span class="c1"># with new numbers</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">justCompute</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setRotationNum</span><span class="p">(</span><span class="n">rotNum</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s2">&quot;pinLocation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">rotateIndexLookup</span><span class="p">[</span><span class="n">pinNum</span><span class="p">]</span> <span class="k">for</span> <span class="n">pinNum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numPins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="n">rotateIndexLookup</span>

<div class="viewcode-block" id="HexBlock.verifyBlockDims"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.verifyBlockDims">[docs]</a>    <span class="k">def</span> <span class="nf">verifyBlockDims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform some checks on this type of block before it is assembled.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wireComp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span>
            <span class="n">ductComps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponents</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">)</span>
            <span class="n">cladComp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># there are probably more that one clad/wire, so we really dont know what this block looks like</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Block design </span><span class="si">{}</span><span class="s2"> is too complicated to verify dimensions. Make sure they &quot;</span>
                <span class="s2">&quot;are correct!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># check wire wrap in contact with clad</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">wwCladGap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getWireWrapCladGap</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">wwCladGap</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;The gap between wire wrap and clad in block </span><span class="si">{}</span><span class="s2"> was </span><span class="si">{}</span><span class="s2"> cm. Expected 0.0.&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wwCladGap</span><span class="p">),</span>
                    <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="c1"># check clad duct overlap</span>
        <span class="n">pinToDuctGap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinToDuctGap</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Allow for some tolerance; user input precision may lead to slight negative</span>
        <span class="c1"># gaps</span>
        <span class="k">if</span> <span class="n">pinToDuctGap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pinToDuctGap</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.005</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Gap between pins and duct is </span><span class="si">{0:.4f}</span><span class="s2"> cm in </span><span class="si">{1}</span><span class="s2">. Make more room.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">pinToDuctGap</span><span class="p">,</span> <span class="bp">self</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">pinToDuctGap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># only produce a warning if pin or clad are found, but not all of pin, clad and duct. We</span>
            <span class="c1"># may need to tune this logic a bit</span>
            <span class="n">ductComp</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">ductComps</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cladComp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">wireComp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">[</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="n">wireComp</span><span class="p">,</span> <span class="n">cladComp</span><span class="p">,</span> <span class="n">ductComp</span><span class="p">)]</span>
            <span class="p">):</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Some component was missing in </span><span class="si">{}</span><span class="s2"> so pin-to-duct gap not calculated&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getPinToDuctGap"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getPinToDuctGap">[docs]</a>    <span class="k">def</span> <span class="nf">getPinToDuctGap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance in cm between the outer most pin and the duct in a block.</span>

<span class="sd">        .. impl:: Pin to duct gap of block is retrievable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_DIMS5</span>
<span class="sd">            :implements: R_ARMI_BLOCK_DIMS</span>

<span class="sd">            Requires that the outer most duct be Hexagonal and wire and clad Components</span>
<span class="sd">            be present. The flat-to-flat distance between the radial exterior of opposing</span>
<span class="sd">            pins in the outermost ring is computed by computing the distance between</span>
<span class="sd">            pin centers (``getPinCenterFlatToFlat``) and adding the outer diameter of</span>
<span class="sd">            the clad Component and the outer diameter of the wire Component twice. The</span>
<span class="sd">            total margin between the inner pitch of the duct Component and the wire is then</span>
<span class="sd">            computed. The pin to duct gap is then half this distance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cold : boolean</span>
<span class="sd">            Determines whether the results should be cold or hot dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pinToDuctGap : float</span>
<span class="sd">            Returns the diameteral gap between the outer most pins in a hex pack to the duct inner</span>
<span class="sd">            face to face in cm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wire</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span>
        <span class="n">ducts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">))</span>
        <span class="n">duct</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ducts</span><span class="p">):</span>
            <span class="n">duct</span> <span class="o">=</span> <span class="n">ducts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">duct</span><span class="p">,</span> <span class="n">components</span><span class="o">.</span><span class="n">Hexagon</span><span class="p">):</span>
                <span class="c1"># getPinCenterFlatToFlat only works for hexes</span>
                <span class="c1"># inner most duct might be circle or some other shape</span>
                <span class="n">duct</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">duct</span><span class="p">,</span> <span class="n">components</span><span class="o">.</span><span class="n">HoledHexagon</span><span class="p">):</span>
                <span class="c1"># has no ip and is circular on inside so following</span>
                <span class="c1"># code will not work</span>
                <span class="n">duct</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="n">duct</span><span class="p">,</span> <span class="n">wire</span><span class="p">,</span> <span class="n">clad</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># note, if nRings was a None, this could be for a non-hex packed fuel assembly</span>
        <span class="c1"># see thermal hydraulic design basis for description of equation</span>
        <span class="n">pinCenterFlatToFlat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinCenterFlatToFlat</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="n">pinOuterFlatToFlat</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pinCenterFlatToFlat</span>
            <span class="o">+</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
            <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">wire</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">ductMarginToContact</span> <span class="o">=</span> <span class="n">duct</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;ip&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">-</span> <span class="n">pinOuterFlatToFlat</span>
        <span class="n">pinToDuctGap</span> <span class="o">=</span> <span class="n">ductMarginToContact</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="k">return</span> <span class="n">pinToDuctGap</span></div>

<div class="viewcode-block" id="HexBlock.getRotationNum"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getRotationNum">[docs]</a>    <span class="k">def</span> <span class="nf">getRotationNum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get index 0 through 5 indicating number of rotations counterclockwise around the z-axis.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">orientation</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mf">360.0</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span>
        <span class="p">)</span>  <span class="c1"># assume rotation only in Z</span></div>

<div class="viewcode-block" id="HexBlock.setRotationNum"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.setRotationNum">[docs]</a>    <span class="k">def</span> <span class="nf">setRotationNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotNum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set orientation based on a number 0 through 5 indicating number of rotations</span>
<span class="sd">        counterclockwise around the z-axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">orientation</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">60.0</span> <span class="o">*</span> <span class="n">rotNum</span></div>

<div class="viewcode-block" id="HexBlock.getSymmetryFactor"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getSymmetryFactor">[docs]</a>    <span class="k">def</span> <span class="nf">getSymmetryFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a factor between 1 and N where 1/N is how much cut-off by symmetry lines this mesh</span>
<span class="sd">        cell is.</span>

<span class="sd">        Reactor-level meshes have symmetry information so we have a reactor for this to work. That&#39;s</span>
<span class="sd">        why it&#39;s not implemented on the grid/locator level.</span>

<span class="sd">        When edge-assemblies are included on both edges (i.e. MCNP or DIF3D-FD 1/3-symmetric cases),</span>
<span class="sd">        the edge assemblies have symmetry factors of 2.0. Otherwise (DIF3D-nodal) there&#39;s a full</span>
<span class="sd">        assembly on the bottom edge (overhanging) and no assembly at the top edge so the ones at the</span>
<span class="sd">        bottom are considered full (symmetryFactor=1).</span>

<span class="sd">        If this block is not in any grid at all, then there can be no symmetry so return 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">symmetry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">symmetry</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">THIRD_CORE</span>
            <span class="ow">and</span> <span class="n">symmetry</span><span class="o">.</span><span class="n">boundary</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">PERIODIC</span>
        <span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># central location</span>
                <span class="k">return</span> <span class="mf">3.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">symmetryLine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">overlapsWhichSymmetryLine</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="c1"># detect if upper edge assemblies are included. Doing this is the only way to know</span>
                <span class="c1"># definitively whether or not the edge assemblies are half-assems or full.</span>
                <span class="c1"># seeing the first one is the easiest way to detect them.</span>
                <span class="c1"># Check it last in the and statement so we don&#39;t waste time doing it.</span>
                <span class="n">upperEdgeLoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">symmetryLine</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="n">grids</span><span class="o">.</span><span class="n">BOUNDARY_0_DEGREES</span><span class="p">,</span>
                    <span class="n">grids</span><span class="o">.</span><span class="n">BOUNDARY_120_DEGREES</span><span class="p">,</span>
                <span class="p">]</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">upperEdgeLoc</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="mf">2.0</span>
        <span class="k">return</span> <span class="mf">1.0</span></div>

<div class="viewcode-block" id="HexBlock.autoCreateSpatialGrids"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.autoCreateSpatialGrids">[docs]</a>    <span class="k">def</span> <span class="nf">autoCreateSpatialGrids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a block without a spatialGrid, create a spatialGrid and give its children the</span>
<span class="sd">        corresponding spatialLocators (if it is a simple block).</span>

<span class="sd">        In this case, a simple block would be one that has either multiplicity of components equal</span>
<span class="sd">        to 1 or N but no other multiplicities. Also, this should only happen when N fits exactly</span>
<span class="sd">        into a given number of hex rings.  Otherwise, do not create a grid for this block.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the Block meets all the conditions, we gather all components to either be a</span>
<span class="sd">        multiIndexLocation containing all of the pin positions, or the locator is the center (0,0).</span>

<span class="sd">        Also, this only works on blocks that have &#39;flat side up&#39;.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the multiplicities of the block are not only 1 or N or if generated ringNumber leads</span>
<span class="sd">            to more positions than necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check multiplicities...</span>
        <span class="n">mults</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterComponents</span><span class="p">()}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mults</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mults</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Could not create a spatialGrid for block </span><span class="si">{}</span><span class="s2">, multiplicities are not 1 or N they are </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">mults</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">ringNumber</span> <span class="o">=</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numRingsToHoldNumCells</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">())</span>
        <span class="c1"># For the below to work, there must not be multiple wire or multiple clad types.</span>
        <span class="c1"># note that it&#39;s the pointed end of the cell hexes that are up (but the</span>
        <span class="c1"># macro shape of the pins forms a hex with a flat top fitting in the assembly)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">HexGrid</span><span class="o">.</span><span class="n">fromPitch</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getPinPitch</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">numRings</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">cornersUp</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">spatialLocators</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">)</span>
        <span class="n">numLocations</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ringNumber</span><span class="p">):</span>
            <span class="n">numLocations</span> <span class="o">=</span> <span class="n">numLocations</span> <span class="o">+</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numPositionsInRing</span><span class="p">(</span><span class="n">ring</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numLocations</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot create spatialGrid, number of locations in rings</span><span class="si">{}</span><span class="s2"> not equal to pin number</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">numLocations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ringNumber</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">getPositionsInRing</span><span class="p">(</span><span class="n">ring</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getIndicesFromRingAndPos</span><span class="p">(</span><span class="n">ring</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">spatialLocators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="n">grid</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">spatialLocators</span>
                <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">CoordinateLocation</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getPinCenterFlatToFlat"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getPinCenterFlatToFlat">[docs]</a>    <span class="k">def</span> <span class="nf">getPinCenterFlatToFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the flat-to-flat distance between the centers of opposing pins in the outermost ring.&quot;&quot;&quot;</span>
        <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="n">nRings</span> <span class="o">=</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numRingsToHoldNumCells</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">))</span>
        <span class="n">pinPitch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinPitch</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="n">pinCenterCornerToCorner</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nRings</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pinPitch</span>
        <span class="n">pinCenterFlatToFlat</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">pinCenterCornerToCorner</span>
        <span class="k">return</span> <span class="n">pinCenterFlatToFlat</span></div>

<div class="viewcode-block" id="HexBlock.hasPinPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.hasPinPitch">[docs]</a>    <span class="k">def</span> <span class="nf">hasPinPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if the block has enough information to calculate pin pitch.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getPinPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getPinPitch">[docs]</a>    <span class="k">def</span> <span class="nf">getPinPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the pin pitch in cm.</span>

<span class="sd">        Assumes that the pin pitch is defined entirely by contacting cladding tubes and wire wraps.</span>
<span class="sd">        Grid spacers not yet supported.</span>

<span class="sd">        .. impl:: Pin pitch within block is retrievable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_DIMS6</span>
<span class="sd">            :implements: R_ARMI_BLOCK_DIMS</span>

<span class="sd">            This implementation requires that clad and wire Components are present.</span>
<span class="sd">            If not, an error is raised. If present, the pin pitch is calculated</span>
<span class="sd">            as the sum of the outer diameter of the clad and outer diameter of</span>
<span class="sd">            the wire.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cold : boolean</span>
<span class="sd">            Determines whether the dimensions should be cold or hot</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pinPitch : float</span>
<span class="sd">            pin pitch in cm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
            <span class="n">wire</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Block </span><span class="si">{}</span><span class="s2"> has multiple clad and wire components,&quot;</span>
                <span class="s2">&quot; so pin pitch is not well-defined.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">wire</span> <span class="ow">and</span> <span class="n">clad</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span> <span class="o">+</span> <span class="n">wire</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span>
                <span class="s2">&quot;od&quot;</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="n">cold</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get pin pitch in </span><span class="si">{}</span><span class="s2"> because it does not have a wire and a clad&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span>
                <span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getWettedPerimeter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getWettedPerimeter">[docs]</a>    <span class="k">def</span> <span class="nf">getWettedPerimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return the total wetted perimeter of the block in cm.</span>

<span class="sd">        .. impl:: Wetted perimeter of block is retrievable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_DIMS7</span>
<span class="sd">            :implements: R_ARMI_BLOCK_DIMS</span>

<span class="sd">            This implementation computes wetted perimeters for specific Components, as specified</span>
<span class="sd">            by their Flags (:need:`R_ARMI_FLAG_DEFINE`). Hollow hexagons and circular pin Components</span>
<span class="sd">            are supported. The latter supports both instances where the exterior is wetted</span>
<span class="sd">            (e.g., clad, wire) as well as when the interior and exterior are wetted (hollow circle).</span>

<span class="sd">            Hollow hexagons are calculated via,</span>

<span class="sd">            .. math::</span>

<span class="sd">                \frac{6 \times \text{ip}}{\sqrt{3}},</span>

<span class="sd">            where :math:`\text{ip}` is the inner pitch of the hollow hexagon. Circular pin Components</span>
<span class="sd">            where the exterior is wetted is calculated via,</span>

<span class="sd">            .. math::</span>

<span class="sd">                N \pi \left( \text{OD}_c + \text{OD}_w \right),</span>

<span class="sd">            where :math:`N` is the total number of pins, :math:`\text{OD}_c` is the outer diameter</span>
<span class="sd">            of the clad, and :math:`\text{OD}_w` is the outer diameter of the wire, respectively.</span>
<span class="sd">            When both the interior and exterior are wetted, the wetted perimeter is calculated as</span>

<span class="sd">            .. math::</span>

<span class="sd">                \pi \left( \text{OD} + \text{ID} \right),</span>

<span class="sd">            where :math:`\text{OD}` and :math:`\text{ID}` are the outer and inner diameters of the pin</span>
<span class="sd">            Component, respectively.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># flags pertaining to hexagon components where the interior of the hexagon is wetted</span>
        <span class="n">wettedHollowHexagonComponentFlags</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span><span class="p">,</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">GRID_PLATE</span><span class="p">,</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">INLET_NOZZLE</span><span class="p">,</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">HANDLING_SOCKET</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># flags pertaining to circular pin components where the exterior of the circle is wetted</span>
        <span class="n">wettedPinComponentFlags</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">,</span>
            <span class="n">Flags</span><span class="o">.</span><span class="n">WIRE</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># flags pertaining to circular components where both the interior and exterior of the circle are wetted</span>
        <span class="n">wettedHollowCircleComponentFlags</span> <span class="o">=</span> <span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">DUCT</span> <span class="o">|</span> <span class="n">Flags</span><span class="o">.</span><span class="n">INNER</span><span class="p">,)</span>

        <span class="c1"># obtain all wetted components based on type</span>
        <span class="n">wettedHollowHexagonComponents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">wettedHollowHexagonComponentFlags</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">wettedHollowHexagonComponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">wettedPinComponents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">wettedPinComponentFlags</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">wettedPinComponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">wettedHollowCircleComponents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">wettedHollowCircleComponentFlags</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">wettedHollowCircleComponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># calculate wetted perimeters according to their geometries</span>

        <span class="c1"># hollow hexagon = 6 * ip / sqrt(3)</span>
        <span class="n">wettedHollowHexagonPerimeter</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">wettedHollowHexagonComponents</span><span class="p">:</span>
            <span class="n">wettedHollowHexagonPerimeter</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="mi">6</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;ip&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="mf">0.0</span>
            <span class="p">)</span>

        <span class="c1"># solid circle = NumPins * pi * (Comp Diam + Wire Diam)</span>
        <span class="n">wettedPinPerimeter</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">wettedPinComponents</span><span class="p">:</span>
            <span class="n">correctionFactor</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Helix</span><span class="p">):</span>
                <span class="c1"># account for the helical wire wrap</span>
                <span class="n">correctionFactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span>
                    <span class="mf">1.0</span><span class="p">,</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
                    <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;helixDiameter&quot;</span><span class="p">)</span>
                    <span class="o">/</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;axialPitch&quot;</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="n">wettedPinPerimeter</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">correctionFactor</span>
        <span class="n">wettedPinPerimeter</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPins</span><span class="p">()</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># hollow circle = (id + od) * pi</span>
        <span class="n">wettedHollowCirclePerimeter</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">wettedHollowCircleComponents</span><span class="p">:</span>
            <span class="n">wettedHollowCirclePerimeter</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;od&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="mf">0.0</span>
            <span class="p">)</span>
        <span class="n">wettedHollowCirclePerimeter</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">wettedHollowHexagonPerimeter</span>
            <span class="o">+</span> <span class="n">wettedPinPerimeter</span>
            <span class="o">+</span> <span class="n">wettedHollowCirclePerimeter</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HexBlock.getFlowArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getFlowArea">[docs]</a>    <span class="k">def</span> <span class="nf">getFlowArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the total flowing coolant area of the block in cm^2.</span>

<span class="sd">        .. impl:: Flow area of block is retrievable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_DIMS8</span>
<span class="sd">            :implements: R_ARMI_BLOCK_DIMS</span>

<span class="sd">            Retrieving the flow area requires that there be a single coolant Component.</span>
<span class="sd">            If available, the area is calculated (:need:`I_ARMI_COMP_VOL0`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">COOLANT</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">getArea</span><span class="p">()</span></div>

<div class="viewcode-block" id="HexBlock.getHydraulicDiameter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.HexBlock.getHydraulicDiameter">[docs]</a>    <span class="k">def</span> <span class="nf">getHydraulicDiameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the hydraulic diameter in this block in cm.</span>

<span class="sd">        Hydraulic diameter is 4A/P where A is the flow area and P is the wetted perimeter.</span>
<span class="sd">        In a hex assembly, the wetted perimeter includes the cladding, the wire wrap, and the</span>
<span class="sd">        inside of the duct. The flow area is the inner area of the duct minus the area of the</span>
<span class="sd">        pins and the wire.</span>

<span class="sd">        .. impl:: Hydraulic diameter of block is retrievable.</span>
<span class="sd">            :id: I_ARMI_BLOCK_DIMS9</span>
<span class="sd">            :implements: R_ARMI_BLOCK_DIMS</span>

<span class="sd">            The hydraulic diamter is calculated via</span>

<span class="sd">            .. math::</span>

<span class="sd">                4\frac{A}{P},</span>

<span class="sd">            where :math:`A` is the flow area (:need:`I_ARMI_BLOCK_DIMS8`) and :math:`P` is the</span>
<span class="sd">            wetted perimeter (:need:`I_ARMI_BLOCK_DIMS7`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFlowArea</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getWettedPerimeter</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="CartesianBlock"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock">[docs]</a><span class="k">class</span> <span class="nc">CartesianBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
    <span class="n">PITCH_DIMENSION</span> <span class="o">=</span> <span class="s2">&quot;widthOuter&quot;</span>
    <span class="n">PITCH_COMPONENT_TYPE</span> <span class="o">=</span> <span class="n">components</span><span class="o">.</span><span class="n">Rectangle</span>

<div class="viewcode-block" id="CartesianBlock.getMaxArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock.getMaxArea">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get area of this block if it were totally full.&quot;&quot;&quot;</span>
        <span class="n">xw</span><span class="p">,</span> <span class="n">yw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPitch</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">xw</span> <span class="o">*</span> <span class="n">yw</span></div>

<div class="viewcode-block" id="CartesianBlock.setPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock.setPitch">[docs]</a>    <span class="k">def</span> <span class="nf">setPitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">updateBolParams</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Directly setting the pitch of a cartesian block is currently not supported.&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CartesianBlock.getSymmetryFactor"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock.getSymmetryFactor">[docs]</a>    <span class="k">def</span> <span class="nf">getSymmetryFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a factor between 1 and N where 1/N is how much cut-off by symmetry lines this mesh</span>
<span class="sd">        cell is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">isThroughCenterAssembly</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># central location</span>
                    <span class="k">return</span> <span class="mf">4.0</span>
                <span class="k">elif</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># edge location</span>
                    <span class="k">return</span> <span class="mf">2.0</span>
        <span class="k">return</span> <span class="mf">1.0</span></div>

<div class="viewcode-block" id="CartesianBlock.getPinCenterFlatToFlat"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.CartesianBlock.getPinCenterFlatToFlat">[docs]</a>    <span class="k">def</span> <span class="nf">getPinCenterFlatToFlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cold</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the flat-to-flat distance between the centers of opposing pins in the outermost ring.&quot;&quot;&quot;</span>
        <span class="n">clad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span>
        <span class="n">nRings</span> <span class="o">=</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numRingsToHoldNumCells</span><span class="p">(</span><span class="n">clad</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;mult&quot;</span><span class="p">))</span>
        <span class="n">pinPitch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPinPitch</span><span class="p">(</span><span class="n">cold</span><span class="o">=</span><span class="n">cold</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nRings</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pinPitch</span></div></div>


<div class="viewcode-block" id="ThRZBlock"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock">[docs]</a><span class="k">class</span> <span class="nc">ThRZBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
    <span class="c1"># be sure to fill ThRZ blocks with only 3D components - components with explicit getVolume methods</span>

<div class="viewcode-block" id="ThRZBlock.getMaxArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.getMaxArea">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the area of the Theta-R-Z block if it was totally full.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot get max area of a TRZ block. Fully specify your geometry.&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ThRZBlock.radialInner"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.radialInner">[docs]</a>    <span class="k">def</span> <span class="nf">radialInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a smallest radius of all the components.&quot;&quot;&quot;</span>
        <span class="n">innerRadii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;inner_radius&quot;</span><span class="p">)</span>
        <span class="n">smallestInner</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">innerRadii</span><span class="p">)</span> <span class="k">if</span> <span class="n">innerRadii</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">smallestInner</span></div>

<div class="viewcode-block" id="ThRZBlock.radialOuter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.radialOuter">[docs]</a>    <span class="k">def</span> <span class="nf">radialOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a largest radius of all the components.&quot;&quot;&quot;</span>
        <span class="n">outerRadii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;outer_radius&quot;</span><span class="p">)</span>
        <span class="n">largestOuter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">outerRadii</span><span class="p">)</span> <span class="k">if</span> <span class="n">outerRadii</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">largestOuter</span></div>

<div class="viewcode-block" id="ThRZBlock.thetaInner"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.thetaInner">[docs]</a>    <span class="k">def</span> <span class="nf">thetaInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a smallest theta of all the components.&quot;&quot;&quot;</span>
        <span class="n">innerTheta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;inner_theta&quot;</span><span class="p">)</span>
        <span class="n">smallestInner</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">innerTheta</span><span class="p">)</span> <span class="k">if</span> <span class="n">innerTheta</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">smallestInner</span></div>

<div class="viewcode-block" id="ThRZBlock.thetaOuter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.thetaOuter">[docs]</a>    <span class="k">def</span> <span class="nf">thetaOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a largest theta of all the components.&quot;&quot;&quot;</span>
        <span class="n">outerTheta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;outer_theta&quot;</span><span class="p">)</span>
        <span class="n">largestOuter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">outerTheta</span><span class="p">)</span> <span class="k">if</span> <span class="n">outerTheta</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">largestOuter</span></div>

<div class="viewcode-block" id="ThRZBlock.axialInner"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.axialInner">[docs]</a>    <span class="k">def</span> <span class="nf">axialInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the lower z-coordinate.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;inner_axial&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ThRZBlock.axialOuter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.axialOuter">[docs]</a>    <span class="k">def</span> <span class="nf">axialOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the upper z-coordinate.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">(</span><span class="s2">&quot;outer_axial&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ThRZBlock.verifyBlockDims"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.blocks.html#armi.reactor.blocks.ThRZBlock.verifyBlockDims">[docs]</a>    <span class="k">def</span> <span class="nf">verifyBlockDims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform dimension checks related to ThetaRZ blocks.&quot;&quot;&quot;</span>
        <span class="k">return</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2009-2024, TerraPower, LLC.
      <span class="lastupdated">Last updated on 2024-09-25.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
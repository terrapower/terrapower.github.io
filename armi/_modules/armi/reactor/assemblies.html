<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>armi.reactor.assemblies &mdash; ARMI 0.3.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme_fixes.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/armiicon_16x16.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ARMI
              <img src="../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../.apidocs/modules.html">API Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #233C5B" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ARMI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../armi.html">armi</a></li>
          <li class="breadcrumb-item"><a href="../reactor.html">armi.reactor</a></li>
      <li class="breadcrumb-item active">armi.reactor.assemblies</li>
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for armi.reactor.assemblies</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Assemblies are collections of Blocks.</span>

<span class="sd">Generally, blocks are stacked from bottom to top.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>

<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">runLog</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">assemblyLists</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">assemblyParameters</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">blocks</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">composites</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">grids</span>
<span class="kn">from</span> <span class="nn">armi.reactor.flags</span> <span class="kn">import</span> <span class="n">Flags</span>
<span class="kn">from</span> <span class="nn">armi.reactor.parameters</span> <span class="kn">import</span> <span class="n">ParamLocation</span>


<div class="viewcode-block" id="Assembly"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly">[docs]</a><span class="k">class</span> <span class="nc">Assembly</span><span class="p">(</span><span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single assembly in a reactor made up of blocks built from the bottom up.</span>
<span class="sd">    Append blocks to add them up. Index blocks with 0 being the bottom.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    pinNum : int</span>
<span class="sd">        The number of pins in this assembly.</span>

<span class="sd">    pinPeakingFactors : list of floats</span>
<span class="sd">        The assembly-averaged pin power peaking factors. This is the ratio of pin</span>
<span class="sd">        power to AVERAGE pin power in an assembly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pDefs</span> <span class="o">=</span> <span class="n">assemblyParameters</span><span class="o">.</span><span class="n">getAssemblyParameterDefinitions</span><span class="p">()</span>

    <span class="n">LOAD_QUEUE</span> <span class="o">=</span> <span class="s2">&quot;LoadQueue&quot;</span>
    <span class="n">SPENT_FUEL_POOL</span> <span class="o">=</span> <span class="s2">&quot;SFP&quot;</span>
    <span class="c1"># For assemblies coming in from the database, waiting to be loaded to their old</span>
    <span class="c1"># position. This is a necessary distinction, since we need to make sure that a bunch</span>
    <span class="c1"># of fuel management stuff doesn&#39;t treat its re-placement into the core as a new move</span>
    <span class="n">DATABASE</span> <span class="o">=</span> <span class="s2">&quot;database&quot;</span>
    <span class="n">NOT_IN_CORE</span> <span class="o">=</span> <span class="p">[</span><span class="n">LOAD_QUEUE</span><span class="p">,</span> <span class="n">SPENT_FUEL_POOL</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">assemNum</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typ : str</span>
<span class="sd">            Name of assembly design (e.g. the name from the blueprints input file).</span>

<span class="sd">        assemNum : int, optional</span>
<span class="sd">            The unique ID number of this assembly. If None is provided, we generate a</span>
<span class="sd">            random int. This makes it clear that it is a placeholder. When an assembly with</span>
<span class="sd">            a negative ID is placed into a Reactor, it will be given a new, positive ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no assembly number is provided, generate a random number as a placeholder.</span>
        <span class="k">if</span> <span class="n">assemNum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">assemNum</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="mf">9e12</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">makeNameFromAssemNum</span><span class="p">(</span><span class="n">assemNum</span><span class="p">)</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span> <span class="o">=</span> <span class="n">assemNum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setType</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># for iterating</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">buLimit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxParam</span><span class="p">(</span><span class="s2">&quot;buLimit&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pinPeakingFactors</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># assembly-averaged pin power peaking factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lastLocationLabel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOAD_QUEUE</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&lt;</span><span class="si">{typeName}</span><span class="s2"> Assembly </span><span class="si">{name}</span><span class="s2"> at </span><span class="si">{loc}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span> <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getLocation</span><span class="p">(),</span> <span class="n">typeName</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare two assemblies by location.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As with other ArmiObjects, Assemblies are sorted based on location. Assemblies</span>
<span class="sd">        are more permissive in the grid consistency checks to accomodate situations</span>
<span class="sd">        where assemblies might be children of the same Core, but not in the same grid as</span>
<span class="sd">        each other (as can be the case in the spent fuel pool). In these situations,</span>
<span class="sd">        the operator returns ``False``.  This behavior may lead to some strange sorting</span>
<span class="sd">        behavior when two or more Assemblies are being compared that do not live in the</span>
<span class="sd">        same grid. It may be beneficial in the future to maintain the more strict behavior</span>
<span class="sd">        of ArmiObject&#39;s ``__lt__`` implementation once the SFP situation is cleared up.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.composites.ArmiObject.__lt__</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">composites</span><span class="o">.</span><span class="n">ArmiObject</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Assembly.renameBlocksAccordingToAssemblyNum"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.renameBlocksAccordingToAssemblyNum">[docs]</a>    <span class="k">def</span> <span class="nf">renameBlocksAccordingToAssemblyNum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the names of all blocks to comply with the assembly number.</span>

<span class="sd">        Useful after an assembly number/name has been loaded from a snapshot and you</span>
<span class="sd">        want to update all block names to be consistent.</span>

<span class="sd">        It may be better to store block numbers on each block as params. A database that</span>
<span class="sd">        can hold strings would be even better.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        You must run armi.reactor.reactors.Reactor.regenAssemblyLists after calling</span>
<span class="sd">        this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">assemNum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNum</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">bi</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">b</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">makeName</span><span class="p">(</span><span class="n">assemNum</span><span class="p">,</span> <span class="n">bi</span><span class="p">))</span></div>

<div class="viewcode-block" id="Assembly.makeNameFromAssemNum"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.makeNameFromAssemNum">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">makeNameFromAssemNum</span><span class="p">(</span><span class="n">assemNum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the name of this assembly (and the containing blocks) based on an assemNum.</span>

<span class="sd">        AssemNums are like serial numbers for assemblies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;A</span><span class="si">{0:04d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">assemNum</span><span class="p">))</span></div>

<div class="viewcode-block" id="Assembly.renumber"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.renumber">[docs]</a>    <span class="k">def</span> <span class="nf">renumber</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newNum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the assembly number of this assembly.</span>

<span class="sd">        And handle the downstream impacts of changing the name of this Assembly and all</span>
<span class="sd">        of the Blocks within this Assembly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newNum : int</span>
<span class="sd">            The new Assembly number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">newNum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">makeNameFromAssemNum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">renameBlocksAccordingToAssemblyNum</span><span class="p">()</span></div>

<div class="viewcode-block" id="Assembly.makeUnique"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.makeUnique">[docs]</a>    <span class="k">def</span> <span class="nf">makeUnique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to make an assembly unique by getting a new assembly number.</span>

<span class="sd">        This also adjusts the assembly&#39;s blocks IDs. This is necessary when using</span>
<span class="sd">        ``deepcopy`` to get a unique ``assemNum`` since a deepcopy implies it would</span>
<span class="sd">        otherwise have been the same object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Default to a random negative assembly number (unique enough)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="mf">9e12</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">renumber</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.add"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">blocks</span><span class="o">.</span><span class="n">Block</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an object to this assembly.</span>

<span class="sd">        The simple act of adding a block to an assembly fully defines the location of</span>
<span class="sd">        the block in 3-D.</span>

<span class="sd">        .. impl:: Assemblies are made up of type Block.</span>
<span class="sd">            :id: I_ARMI_ASSEM_BLOCKS</span>
<span class="sd">            :implements: R_ARMI_ASSEM_BLOCKS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># assemblies have bounds-based 1-D spatial grids. Adjust it to the right value.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># more work is needed, make a new mesh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reestablishBlockOrder</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculateZCoords</span><span class="p">()</span></div>

<div class="viewcode-block" id="Assembly.moveTo"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.moveTo">[docs]</a>    <span class="k">def</span> <span class="nf">moveTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move an assembly somewhere else.&quot;&quot;&quot;</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">moveTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lastLocationLabel</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DATABASE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">numMoves</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">daysSinceLastMove</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">childrenByLocator</span><span class="p">[</span><span class="n">locator</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># symmetry may have changed (either moving on or off of symmetry line)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span></div>

<div class="viewcode-block" id="Assembly.insert"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert an object at a given index position with the assembly.&quot;&quot;&quot;</span>
        <span class="n">composites</span><span class="o">.</span><span class="n">Composite</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span></div>

<div class="viewcode-block" id="Assembly.getNum"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getNum">[docs]</a>    <span class="k">def</span> <span class="nf">getNum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return unique integer for this assembly.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.getLocation"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getLocation">[docs]</a>    <span class="k">def</span> <span class="nf">getLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get string label representing this object&#39;s location.</span>

<span class="sd">        .. impl:: Assembly location is retrievable.</span>
<span class="sd">            :id: I_ARMI_ASSEM_POSI0</span>
<span class="sd">            :implements: R_ARMI_ASSEM_POSI</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function (and its friends) were created before the advent of both the</span>
<span class="sd">        grid/spatialLocator system and the ability to represent things like the SFP as</span>
<span class="sd">        siblings of a Core. In future, this will likely be re-implemented in terms of</span>
<span class="sd">        just spatialLocator objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># just use ring and position, not axial (which is 0)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOAD_QUEUE</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">assemblyLists</span><span class="o">.</span><span class="n">SpentFuelPool</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPENT_FUEL_POOL</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getLabel</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.coords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the location of the assembly in the plane using cartesian global</span>
<span class="sd">        coordinates.</span>

<span class="sd">        .. impl:: Assembly coordinates are retrievable.</span>
<span class="sd">            :id: I_ARMI_ASSEM_POSI1</span>
<span class="sd">            :implements: R_ARMI_ASSEM_POSI</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.getArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getArea">[docs]</a>    <span class="k">def</span> <span class="nf">getArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the area of the assembly by looking at its first block.</span>

<span class="sd">        The assumption is that all blocks in an assembly have the same area.</span>
<span class="sd">        Calculate the total assembly volume in cm^3.</span>

<span class="sd">        .. impl:: Assembly area is retrievable.</span>
<span class="sd">            :id: I_ARMI_ASSEM_DIMS0</span>
<span class="sd">            :implements: R_ARMI_ASSEM_DIMS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getArea</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> has no blocks and therefore no area. Assuming 1.0&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="mf">1.0</span></div>

<div class="viewcode-block" id="Assembly.getVolume"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getVolume">[docs]</a>    <span class="k">def</span> <span class="nf">getVolume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the total assembly volume in cm^3.</span>

<span class="sd">        .. impl:: Assembly volume is retrievable.</span>
<span class="sd">            :id: I_ARMI_ASSEM_DIMS1</span>
<span class="sd">            :implements: R_ARMI_ASSEM_DIMS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getArea</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTotalHeight</span><span class="p">()</span></div>

<div class="viewcode-block" id="Assembly.getPinPlenumVolumeInCubicMeters"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getPinPlenumVolumeInCubicMeters">[docs]</a>    <span class="k">def</span> <span class="nf">getPinPlenumVolumeInCubicMeters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the volume of the plenum for a pin in an assembly.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If there is no plenum blocks in the assembly, a plenum volume of 0.0 is returned</span>

<span class="sd">        .. warning:: This is a bit design-specific for pinned assemblies</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plenumBlocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">PLENUM</span><span class="p">)</span>

        <span class="n">plenumVolume</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">plenumBlocks</span><span class="p">:</span>
            <span class="n">cladId</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">CLAD</span><span class="p">)</span><span class="o">.</span><span class="n">getDimension</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
            <span class="n">plenumVolume</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">cladId</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">length</span> <span class="o">*</span> <span class="mf">1e-6</span>
            <span class="p">)</span>  <span class="c1"># convert cm^3 to m^3</span>
        <span class="k">return</span> <span class="n">plenumVolume</span></div>

<div class="viewcode-block" id="Assembly.getAveragePlenumTemperature"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getAveragePlenumTemperature">[docs]</a>    <span class="k">def</span> <span class="nf">getAveragePlenumTemperature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the average of the plenum block outlet temperatures.&quot;&quot;&quot;</span>
        <span class="n">plenumBlocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">PLENUM</span><span class="p">)</span>
        <span class="n">plenumTemps</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">THcoolantOutletT</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">plenumBlocks</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">plenumTemps</span>
        <span class="p">):</span>  <span class="c1"># no plenum blocks, use the top block of the assembly for plenum temperature</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No plenum blocks exist. Using outlet coolant temperature.&quot;</span><span class="p">)</span>
            <span class="n">plenumTemps</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">THcoolantOutletT</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">plenumTemps</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">plenumTemps</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.rotatePins"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.rotatePins">[docs]</a>    <span class="k">def</span> <span class="nf">rotatePins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rotate an assembly, which means rotating the indexing of pins.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">rotatePins</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.doubleResolution"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.doubleResolution">[docs]</a>    <span class="k">def</span> <span class="nf">doubleResolution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turns each block into two half-size blocks.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Used for mesh sensitivity studies.</span>

<span class="sd">        .. warning:: This is likely destined for a geometry converter rather than</span>
<span class="sd">            this instance method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newBlockStack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">topIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">b0</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bx</span> <span class="ow">in</span> <span class="p">[</span><span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">]:</span>
                <span class="n">newHeight</span> <span class="o">=</span> <span class="n">bx</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">bx</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">newHeight</span>
                <span class="n">bx</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">heightBOL</span> <span class="o">=</span> <span class="n">newHeight</span>
                <span class="n">topIndex</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">bx</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">topIndex</span> <span class="o">=</span> <span class="n">topIndex</span>
                <span class="n">newBlockStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bx</span><span class="p">)</span>
                <span class="n">bx</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">removeAll</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">axialUnitGrid</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newBlockStack</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">newBlockStack</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reestablishBlockOrder</span><span class="p">()</span></div>

<div class="viewcode-block" id="Assembly.adjustResolution"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.adjustResolution">[docs]</a>    <span class="k">def</span> <span class="nf">adjustResolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refA</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split the blocks in this assembly to have the same mesh structure as refA.&quot;&quot;&quot;</span>
        <span class="n">newBlockStack</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">newBlocks</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># number of new blocks we&#39;ve added so far.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">refB</span> <span class="o">=</span> <span class="n">refA</span><span class="p">[</span>
                <span class="n">i</span> <span class="o">+</span> <span class="n">newBlocks</span>
            <span class="p">]</span>  <span class="c1"># pick the block that is &quot;supposed to&quot; line up with refB.</span>

            <span class="c1"># runLog.important(&#39;Dealing with {0}, ref b {1}&#39;.format(b,refB))</span>
            <span class="k">if</span> <span class="n">refB</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">():</span>
                <span class="c1"># these blocks line up</span>
                <span class="c1"># runLog.important(&#39;They are the same.&#39;)</span>
                <span class="n">newBlockStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">refB</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;can&#39;t split </span><span class="si">{0}</span><span class="s2"> (</span><span class="si">{1}</span><span class="s2">cm) into larger blocks to match ref block </span><span class="si">{2}</span><span class="s2"> (</span><span class="si">{3}</span><span class="s2">cm)&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(),</span> <span class="n">refB</span><span class="p">,</span> <span class="n">refB</span><span class="o">.</span><span class="n">getHeight</span><span class="p">())</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># b is larger than refB. Split b up by splitting it into several smaller</span>
                <span class="c1"># blocks of refBs</span>
                <span class="n">heightToChop</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
                <span class="n">heightChopped</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">while</span> <span class="p">(</span>
                    <span class="nb">abs</span><span class="p">(</span><span class="n">heightChopped</span> <span class="o">-</span> <span class="n">heightToChop</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-5</span>
                <span class="p">):</span>  <span class="c1"># stop when they are equal. floating point.</span>
                    <span class="c1"># update which ref block we&#39;re on (does nothing on the first pass)</span>
                    <span class="n">refB</span> <span class="o">=</span> <span class="n">refA</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">newBlocks</span><span class="p">]</span>
                    <span class="n">newB</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                    <span class="n">newB</span><span class="o">.</span><span class="n">setHeight</span><span class="p">(</span><span class="n">refB</span><span class="o">.</span><span class="n">getHeight</span><span class="p">())</span>  <span class="c1"># make block match ref mesh</span>
                    <span class="n">newBlockStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newB</span><span class="p">)</span>
                    <span class="n">heightChopped</span> <span class="o">+=</span> <span class="n">refB</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
                    <span class="n">newBlocks</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span>
                        <span class="s2">&quot;Added a new block </span><span class="si">{0}</span><span class="s2"> of height </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">newB</span><span class="p">,</span> <span class="n">newB</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span>
                        <span class="s2">&quot;Chopped </span><span class="si">{0}</span><span class="s2"> of </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">heightChopped</span><span class="p">,</span> <span class="n">heightToChop</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">newBlocks</span> <span class="o">-=</span> <span class="p">(</span>
                    <span class="mi">1</span>  <span class="c1"># subtract one because we eliminated the original b completely.</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">removeAll</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">axialUnitGrid</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newBlockStack</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">newBlockStack</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reestablishBlockOrder</span><span class="p">()</span></div>

<div class="viewcode-block" id="Assembly.getAxialMesh"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getAxialMesh">[docs]</a>    <span class="k">def</span> <span class="nf">getAxialMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zeroAtFuel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a list of the block z-mesh tops from bottom to top in cm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        centers : bool, optional</span>
<span class="sd">            Return centers instead of tops. If centers and zeroesAtFuel the zero point</span>
<span class="sd">            will be center of first fuel.</span>

<span class="sd">        zeroAtFuel : bool, optional</span>
<span class="sd">            If true will make the (bottom or center depending on centers) of the</span>
<span class="sd">            first fuel block be the zero point instead of the bottom of the first block.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.assemblies.Assembly.makeAxialSnapList : makes index-based lookup of</span>
<span class="sd">        axial mesh</span>

<span class="sd">        armi.reactor.reactors.Reactor.findAllAxialMeshPoints : gets a global list of all</span>
<span class="sd">        of these, plus finer res.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">meshVals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fuelIndex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">bi</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">bottom</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">centers</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">bottom</span> <span class="o">+</span> <span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">meshVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">meshVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">top</span>
            <span class="k">if</span> <span class="n">fuelIndex</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">isFuel</span><span class="p">():</span>
                <span class="n">fuelIndex</span> <span class="o">=</span> <span class="n">bi</span>

        <span class="k">if</span> <span class="n">zeroAtFuel</span><span class="p">:</span>
            <span class="c1"># adjust the mesh to put zero at the first fuel block.</span>
            <span class="n">zeroVal</span> <span class="o">=</span> <span class="n">meshVals</span><span class="p">[</span><span class="n">fuelIndex</span><span class="p">]</span>
            <span class="n">meshVals</span> <span class="o">=</span> <span class="p">[</span><span class="n">mv</span> <span class="o">-</span> <span class="n">zeroVal</span> <span class="k">for</span> <span class="n">mv</span> <span class="ow">in</span> <span class="n">meshVals</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">meshVals</span></div>

<div class="viewcode-block" id="Assembly.calculateZCoords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.calculateZCoords">[docs]</a>    <span class="k">def</span> <span class="nf">calculateZCoords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the center z-coords of each block and the params for axial expansion.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        reestablishBlockOrder</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">bottom</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">bi</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">bottom</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">zbottom</span> <span class="o">=</span> <span class="n">bottom</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">bottom</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
            <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span> <span class="o">=</span> <span class="n">top</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">top</span>
            <span class="n">b</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bi</span><span class="p">]</span>

        <span class="c1"># also update the 1-D axial assembly level grid (this is intended to replace z,</span>
        <span class="c1"># ztop, zbottom, etc.)</span>

        <span class="c1"># length of this is numBlocks + 1</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">_bounds</span><span class="p">)</span>
        <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.getTotalHeight"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getTotalHeight">[docs]</a>    <span class="k">def</span> <span class="nf">getTotalHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the height of this assembly in cm.</span>

<span class="sd">        .. impl:: Assembly height is retrievable.</span>
<span class="sd">            :id: I_ARMI_ASSEM_DIMS2</span>
<span class="sd">            :implements: R_ARMI_ASSEM_DIMS</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : See :py:meth:`armi.composites.Composite.hasFlags`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        height : float</span>
<span class="sd">            the height in cm</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">):</span>
                <span class="n">h</span> <span class="o">+=</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">h</span></div>

<div class="viewcode-block" id="Assembly.getHeight"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getHeight">[docs]</a>    <span class="k">def</span> <span class="nf">getHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTotalHeight</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.getReactiveHeight"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getReactiveHeight">[docs]</a>    <span class="k">def</span> <span class="nf">getReactiveHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enrichThresh</span><span class="o">=</span><span class="mf">0.02</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the zBottom and total height in cm that has fissile enrichment over</span>
<span class="sd">        enrichThresh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reactiveH</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">zBot</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">z</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">getFissileMass</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.01</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">getFissileMassEnrich</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">enrichThresh</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">zBot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">zBot</span> <span class="o">=</span> <span class="n">z</span>
                <span class="n">reactiveH</span> <span class="o">+=</span> <span class="n">h</span>
            <span class="n">z</span> <span class="o">+=</span> <span class="n">h</span>

        <span class="k">return</span> <span class="n">zBot</span><span class="p">,</span> <span class="n">reactiveH</span></div>

<div class="viewcode-block" id="Assembly.getElevationBoundariesByBlockType"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getElevationBoundariesByBlockType">[docs]</a>    <span class="k">def</span> <span class="nf">getElevationBoundariesByBlockType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blockType</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets of list of elevations, ordered from bottom to top of all boundaries of the block of specified type.</span>

<span class="sd">        Useful for determining location of the top of the upper grid plate or active</span>
<span class="sd">        fuel, etc by using [0] to get the lowest boundary and [-1] to get highest</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The list will have duplicates when blocks of the same type share a boundary.</span>
<span class="sd">        this is intentional. It makes it easy to grab pairs off the list and know that</span>
<span class="sd">        the first item in a pair is the bottom boundary and the second is the top.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        blockType : str</span>
<span class="sd">            Block type to find. empty accepts all</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        elevation : list of floats</span>
<span class="sd">            Every float in the list is an elevation of a block boundary for the block</span>
<span class="sd">            type specified (has duplicates)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elevation</span><span class="p">,</span> <span class="n">elevationsWithBlockBoundaries</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="p">[]</span>

        <span class="c1"># loop from bottom to top, stopping at the first instance of blockType</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">blockType</span><span class="p">):</span>
                <span class="n">elevationsWithBlockBoundaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elevation</span><span class="p">)</span>  <span class="c1"># bottom Boundary</span>
                <span class="n">elevationsWithBlockBoundaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">elevation</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
                <span class="p">)</span>  <span class="c1"># top Boundary</span>
            <span class="n">elevation</span> <span class="o">+=</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">elevationsWithBlockBoundaries</span></div>

<div class="viewcode-block" id="Assembly.getElevationsMatchingParamValue"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getElevationsMatchingParamValue">[docs]</a>    <span class="k">def</span> <span class="nf">getElevationsMatchingParamValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the elevations (z-coordinates) where the specified param takes the</span>
<span class="sd">        specified value.</span>

<span class="sd">        Uses linear interpolation, assuming params correspond to block centers</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param : str</span>
<span class="sd">            Name of param to try and match</span>

<span class="sd">        value: float</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        heights : list</span>
<span class="sd">            z-coordinates where the specified param takes the specified value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">heights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># loop from bottom to top</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">diff1</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">-</span> <span class="n">value</span>
            <span class="n">diff2</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">-</span> <span class="n">value</span>
            <span class="n">z1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">zbottom</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">z2</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">zbottom</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">diff1</span> <span class="o">==</span> <span class="n">diff2</span><span class="p">:</span>  <span class="c1"># params are flat</span>
                <span class="k">if</span> <span class="n">diff1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># no match</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">z1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">heights</span><span class="p">:</span>
                        <span class="n">heights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">z2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">heights</span><span class="p">:</span>
                        <span class="n">heights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z2</span><span class="p">)</span>

            <span class="c1"># check if param is bounded by two adjacent blocks</span>
            <span class="k">elif</span> <span class="n">diff1</span> <span class="o">*</span> <span class="n">diff2</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tie</span> <span class="o">=</span> <span class="n">diff1</span> <span class="o">/</span> <span class="p">(</span><span class="n">diff1</span> <span class="o">-</span> <span class="n">diff2</span><span class="p">)</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">z1</span> <span class="o">+</span> <span class="n">tie</span> <span class="o">*</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">z</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">heights</span><span class="p">:</span>  <span class="c1"># avoid duplicates</span>
                    <span class="n">heights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">heights</span></div>

<div class="viewcode-block" id="Assembly.getAge"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getAge">[docs]</a>    <span class="k">def</span> <span class="nf">getAge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets a height-averaged residence time of this assembly in days.&quot;&quot;&quot;</span>
        <span class="n">at</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">at</span> <span class="o">+=</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">residence</span> <span class="o">*</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">at</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTotalHeight</span><span class="p">()</span></div>

<div class="viewcode-block" id="Assembly.makeAxialSnapList"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.makeAxialSnapList">[docs]</a>    <span class="k">def</span> <span class="nf">makeAxialSnapList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refAssem</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">refMesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a list of block indices that should track axially with refAssem&#39;s.</span>

<span class="sd">        When axially expanding, the control rods, shields etc. need to maintain mesh</span>
<span class="sd">        lines with the rest of the core. To do this, we&#39;ll just keep track of which</span>
<span class="sd">        indices of a reference assembly we should stick with. This method writes the</span>
<span class="sd">        indices of the top of a block to settings as topIndex.</span>

<span class="sd">        Keep in mind that assemblies can have different number of blocks. This is why</span>
<span class="sd">        this function is useful. So this makes a list of reference indices that</span>
<span class="sd">        correspond to different axial mesh points on this assembly.</span>

<span class="sd">        This is the depletion mesh we&#39;re returning, useful for snapping after axial</span>
<span class="sd">        extension. Note that the neutronics mesh on rebusOutputs might be different.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        setBlockMesh : applies a snap.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">force</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">topIndex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">refMesh</span> <span class="o">=</span> <span class="n">refAssem</span><span class="o">.</span><span class="n">getAxialMesh</span><span class="p">()</span> <span class="k">if</span> <span class="n">refMesh</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">refMesh</span>
        <span class="n">selfMesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAxialMesh</span><span class="p">()</span>
        <span class="c1"># make a list relating this assemblies axial mesh points to indices of the</span>
        <span class="c1"># reference assembly</span>
        <span class="n">z</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">topIndex</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">refMesh</span><span class="p">,</span> <span class="n">top</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;Height </span><span class="si">{0}</span><span class="s2"> in this assembly (</span><span class="si">{1}</span><span class="s2"> in </span><span class="si">{4}</span><span class="s2">) is not in the reactor mesh &quot;</span>
                    <span class="s2">&quot;list from  </span><span class="si">{2}</span><span class="se">\n</span><span class="s2">This has: </span><span class="si">{3}</span><span class="se">\n</span><span class="s2">If you want to run &quot;</span>
                    <span class="s2">&quot;a case with non-uniform axial mesh, activate the `detailedAxialExpansion` &quot;</span>
                    <span class="s2">&quot;setting&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">refMesh</span><span class="p">,</span> <span class="n">selfMesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">top</span></div>

    <span class="k">def</span> <span class="nf">_shouldMassBeConserved</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">belowFuelColumn</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine from a rule set if the mass of a block should be conserved during axial expansion.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        belowFuelColumn : boolean</span>
<span class="sd">            Determines whether a block is below the fuel column or not in fuel</span>
<span class="sd">            assemblies</span>

<span class="sd">        b : armi block</span>
<span class="sd">            The block that is being examined for modification</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conserveMass : boolean</span>
<span class="sd">            Should the mass be conserved in this block</span>

<span class="sd">        adjustList : list of nuclides</span>
<span class="sd">            What nuclides should have their mass conserved (if any)</span>

<span class="sd">        belowFuelColumn : boolean</span>
<span class="sd">            Update whether the block is above or below a fuel column</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.assemblies.Assembly.setBlockMesh</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">):</span>
            <span class="c1"># fuel block</span>
            <span class="n">conserveMass</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">adjustList</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span><span class="o">.</span><span class="n">getNuclides</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">):</span>
            <span class="c1"># non-fuel block of a fuel assembly.</span>
            <span class="k">if</span> <span class="n">belowFuelColumn</span><span class="p">:</span>
                <span class="c1"># conserve mass of everything below the fuel so as to not invalidate</span>
                <span class="c1"># grid-plate dose calcs.</span>
                <span class="n">conserveMass</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">adjustList</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getNuclides</span><span class="p">()</span>
                <span class="c1"># conserve mass of everything except coolant.</span>
                <span class="n">coolant</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getComponent</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">COOLANT</span><span class="p">)</span>
                <span class="n">coolantList</span> <span class="o">=</span> <span class="n">coolant</span><span class="o">.</span><span class="n">getNuclides</span><span class="p">()</span> <span class="k">if</span> <span class="n">coolant</span> <span class="k">else</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">nuc</span> <span class="ow">in</span> <span class="n">coolantList</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nuc</span> <span class="ow">in</span> <span class="n">adjustList</span><span class="p">:</span>
                        <span class="n">adjustList</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">nuc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># plenum or above block in fuel assembly. don&#39;t conserve mass.</span>
                <span class="n">conserveMass</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">adjustList</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># non fuel block in non-fuel assem. Don&#39;t conserve mass.</span>
            <span class="n">conserveMass</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">adjustList</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">conserveMass</span><span class="p">,</span> <span class="n">adjustList</span>

<div class="viewcode-block" id="Assembly.setBlockMesh"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.setBlockMesh">[docs]</a>    <span class="k">def</span> <span class="nf">setBlockMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blockMesh</span><span class="p">,</span> <span class="n">conserveMassFlag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">adjustList</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Snaps the axial mesh points of this assembly to correspond with the reference mesh.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function only conserves mass on certain conditions:</span>
<span class="sd">            1) Fuel Assembly</span>
<span class="sd">                a) Structural material below the assembly conserves mass to accurate</span>
<span class="sd">                   depict grid plate shielding Sodium is not conserved.</span>
<span class="sd">                b) Fuel blocks only conserve mass of the fuel, not the structure since</span>
<span class="sd">                   the fuel slides up through the cladding (thus fuel/cladding should be</span>
<span class="sd">                   reduced).</span>
<span class="sd">                c) Structure above the assemblies (expected to be plenum) do not</span>
<span class="sd">                   conserve mass since plenum regions have their height reduced to</span>
<span class="sd">                   conserve the total structure mass when the fuel grows in the</span>
<span class="sd">                   cladding.  See b)</span>
<span class="sd">            2) Reflectors, shields, and control rods</span>
<span class="sd">                a) These assemblies do not conserve mass since they should remain</span>
<span class="sd">                   uniform to keep radial shielding accurate. This approach should be</span>
<span class="sd">                   conservative.</span>
<span class="sd">                b) Control rods do not have their mass conserved and the control rod</span>
<span class="sd">                   interface is required to be run after this function is called to</span>
<span class="sd">                   correctly place mass of poison axially.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        blockMesh : iterable</span>
<span class="sd">            a list of floats describing the upper mesh points of each block in cm.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        makeAxialSnapList : Builds the lookup table used by this method</span>
<span class="sd">        getAxialMesh : builds a mesh compatible with this</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Just adjust the heights and everything else will fall into place</span>
        <span class="n">zBottom</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">belowFuelColumn</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">topIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Reference uniform mesh not being applied to </span><span class="si">{}</span><span class="s2">. It was likely &quot;</span>
                <span class="s2">&quot;excluded through the setting `nonUniformAssemFlags`.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">type</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">isFuel</span><span class="p">():</span>
                <span class="n">belowFuelColumn</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">topIndex</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">topIndex</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">topIndex</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">blockMesh</span><span class="p">):</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;index </span><span class="si">{0}</span><span class="s2"> does not exist in topvals (len:</span><span class="si">{1}</span><span class="s2">). 0D case? Skipping snap&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">topIndex</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">blockMesh</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="k">return</span>

            <span class="n">newTop</span> <span class="o">=</span> <span class="n">blockMesh</span><span class="p">[</span><span class="n">topIndex</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">newTop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Skipping axial snapping on </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">conserveMassFlag</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                <span class="n">conserveMass</span><span class="p">,</span> <span class="n">adjustList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shouldMassBeConserved</span><span class="p">(</span>
                    <span class="n">belowFuelColumn</span><span class="p">,</span> <span class="n">b</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">conserveMass</span> <span class="o">=</span> <span class="n">conserveMassFlag</span>

            <span class="n">b</span><span class="o">.</span><span class="n">setHeight</span><span class="p">(</span>
                <span class="n">newTop</span> <span class="o">-</span> <span class="n">zBottom</span><span class="p">,</span> <span class="n">conserveMass</span><span class="o">=</span><span class="n">conserveMass</span><span class="p">,</span> <span class="n">adjustList</span><span class="o">=</span><span class="n">adjustList</span>
            <span class="p">)</span>
            <span class="n">zBottom</span> <span class="o">=</span> <span class="n">newTop</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">calculateZCoords</span><span class="p">()</span></div>

<div class="viewcode-block" id="Assembly.setBlockHeights"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.setBlockHeights">[docs]</a>    <span class="k">def</span> <span class="nf">setBlockHeights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blockHeights</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the block heights of all blocks in the assembly.&quot;&quot;&quot;</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">blockHeights</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setBlockMesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.dump"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fName</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pickle the assembly and write it to a file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fName</span><span class="p">:</span>
            <span class="n">fName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;.dump.pkl&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fName</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pkl</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pkl</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.getBlocks"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getBlocks">[docs]</a>    <span class="k">def</span> <span class="nf">getBlocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get blocks in an assembly from bottom to top.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or list of Flags, optional</span>
<span class="sd">            Restrict returned blocks to those of this type.</span>
<span class="sd">        exact : bool, optional</span>
<span class="sd">            If true, will only return if there&#39;s an exact match in typeSpec</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        blocks : list</span>
<span class="sd">            List of blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">typeSpec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildrenWithFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="n">exact</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.getBlocksAndZ"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getBlocksAndZ">[docs]</a>    <span class="k">def</span> <span class="nf">getBlocksAndZ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">returnBottomZ</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">returnTopZ</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get blocks and their z-coordinates from bottom to top.</span>

<span class="sd">        This method is useful when you need to know the z-coord of a block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeSpec : Flags or list of Flags, optional</span>
<span class="sd">            Block type specification to restrict to</span>

<span class="sd">        returnBottomZ : bool, optional</span>
<span class="sd">            If true, will return bottom coordinates instead of centers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        blocksAndCoords, list</span>
<span class="sd">            (block, zCoord) tuples</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        for block, bottomZ in a.getBlocksAndZ(returnBottomZ=True):</span>
<span class="sd">            print({0}&#39;s bottom mesh point is {1}&#39;.format(block, bottomZ))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">returnBottomZ</span> <span class="ow">and</span> <span class="n">returnTopZ</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both returnTopZ and returnBottomZ are set to `True`&quot;</span><span class="p">)</span>

        <span class="n">blocks</span><span class="p">,</span> <span class="n">zCoords</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">bottom</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">bottom</span> <span class="o">+</span> <span class="n">top</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">):</span>
                <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">returnBottomZ</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">bottom</span>
                <span class="k">elif</span> <span class="n">returnTopZ</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">top</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">mid</span>
                <span class="n">zCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">top</span>

        <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">zCoords</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.hasContinuousCoolantChannel"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.hasContinuousCoolantChannel">[docs]</a>    <span class="k">def</span> <span class="nf">hasContinuousCoolantChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">containsAtLeastOneChildWithFlags</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">COOLANT</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Assembly.getFirstBlock"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getFirstBlock">[docs]</a>    <span class="k">def</span> <span class="nf">getFirstBlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exact</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bs</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Assembly.getFirstBlockByType"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getFirstBlockByType">[docs]</a>    <span class="k">def</span> <span class="nf">getFirstBlockByType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeName</span><span class="p">):</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">b</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">blocks</span><span class="o">.</span><span class="n">Block</span><span class="p">)</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">==</span> <span class="n">typeName</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">bs</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Assembly.getBlockAtElevation"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getBlockAtElevation">[docs]</a>    <span class="k">def</span> <span class="nf">getBlockAtElevation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elevation</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the block at a specified axial dimension elevation (given in cm).</span>

<span class="sd">        If height matches the exact top of the block, the block is considered at that</span>
<span class="sd">        height.</span>

<span class="sd">        Used as a way to determine what block the control rod will be modifying with a</span>
<span class="sd">        mergeBlocks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elevation : float</span>
<span class="sd">            The elevation of interest to grab a block (cm)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        targetBlock : block</span>
<span class="sd">            The block that exists at the specified height in the reactor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bottomOfBlock</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">topOfBlock</span> <span class="o">=</span> <span class="n">bottomOfBlock</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">topOfBlock</span> <span class="o">&gt;</span> <span class="n">elevation</span>
                <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">topOfBlock</span> <span class="o">-</span> <span class="n">elevation</span><span class="p">)</span> <span class="o">/</span> <span class="n">elevation</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="n">bottomOfBlock</span> <span class="o">&lt;</span> <span class="n">elevation</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">b</span>
            <span class="n">bottomOfBlock</span> <span class="o">=</span> <span class="n">topOfBlock</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Assembly.getBIndexFromZIndex"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getBIndexFromZIndex">[docs]</a>    <span class="k">def</span> <span class="nf">getBIndexFromZIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zIndex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the ARMI block axial index corresponding to a DIF3D node axial index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        zIndex : float</span>
<span class="sd">            The axial index (beginning with 0) of a DIF3D node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bIndex : int</span>
<span class="sd">            The axial index (beginning with 0) of the ARMI block containing the</span>
<span class="sd">            DIF3D node corresponding to zIndex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">zIndexTot</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">bIndex</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">zIndexTot</span> <span class="o">+=</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">axMesh</span>
            <span class="k">if</span> <span class="n">zIndexTot</span> <span class="o">&gt;=</span> <span class="n">zIndex</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">bIndex</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># no block index found</span></div>

<div class="viewcode-block" id="Assembly.getBlocksBetweenElevations"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getBlocksBetweenElevations">[docs]</a>    <span class="k">def</span> <span class="nf">getBlocksBetweenElevations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zLower</span><span class="p">,</span> <span class="n">zUpper</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return block(s) between two axial elevations and their corresponding heights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        zLower, zUpper : float</span>
<span class="sd">            Elevations in cm where blocks should be found.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        blockInfo : list</span>
<span class="sd">            list of (blockObj, overlapHeightInCm) tuples</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        If the block structure looks like:</span>
<span class="sd">         50.0 to 100.0 Block3</span>
<span class="sd">         25.0 to 50.0  Block2</span>
<span class="sd">         0.0 to 25.0   Block1</span>

<span class="sd">        Then,</span>

<span class="sd">        &gt;&gt;&gt; a.getBlocksBetweenElevations(0,50)</span>
<span class="sd">        [(Block1, 25.0), (Block2, 25.0)]</span>

<span class="sd">        &gt;&gt;&gt; a.getBlocksBetweenElevations(0,30)</span>
<span class="sd">        [(Block1, 25.0), (Block2, 5.0)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">EPS</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="n">blocksHere</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">allMeshPoints</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span> <span class="o">&gt;=</span> <span class="n">zLower</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">zbottom</span> <span class="o">&lt;=</span> <span class="n">zUpper</span><span class="p">:</span>
                <span class="n">allMeshPoints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">zbottom</span><span class="p">)</span>
                <span class="n">allMeshPoints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span><span class="p">)</span>
                <span class="c1"># at least some of this block overlaps the window of interest</span>
                <span class="n">top</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span><span class="p">,</span> <span class="n">zUpper</span><span class="p">)</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">zbottom</span><span class="p">,</span> <span class="n">zLower</span><span class="p">)</span>
                <span class="n">heightHere</span> <span class="o">=</span> <span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span>

                <span class="c1"># Filter out blocks that have an extremely small height fraction</span>
                <span class="k">if</span> <span class="n">heightHere</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">getHeight</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">EPS</span><span class="p">:</span>
                    <span class="n">blocksHere</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">heightHere</span><span class="p">))</span>

        <span class="n">totalHeight</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">allMeshPoints</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">allMeshPoints</span><span class="p">)</span>
        <span class="c1"># The expected height snaps to the minimum height that is requested</span>
        <span class="n">expectedHeight</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">allMeshPoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">allMeshPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zUpper</span> <span class="o">-</span> <span class="n">zLower</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_b</span><span class="p">,</span> <span class="n">height</span> <span class="ow">in</span> <span class="n">blocksHere</span><span class="p">:</span>
            <span class="n">totalHeight</span> <span class="o">+=</span> <span class="n">height</span>

        <span class="c1"># Verify that the heights of all the blocks are equal to the expected</span>
        <span class="c1"># height for the given zUpper and zLower.</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">totalHeight</span> <span class="o">-</span> <span class="n">expectedHeight</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The cumulative height of </span><span class="si">{</span><span class="n">blocksHere</span><span class="si">}</span><span class="s2"> is </span><span class="si">{</span><span class="n">totalHeight</span><span class="si">}</span><span class="s2"> cm &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;and does not equal the expected height of </span><span class="si">{</span><span class="n">expectedHeight</span><span class="si">}</span><span class="s2"> cm.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;All mesh points: </span><span class="si">{</span><span class="n">allMeshPoints</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Upper mesh point: </span><span class="si">{</span><span class="n">zUpper</span><span class="si">}</span><span class="s2"> cm</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Lower mesh point: </span><span class="si">{</span><span class="n">zLower</span><span class="si">}</span><span class="s2"> cm</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">blocksHere</span></div>

<div class="viewcode-block" id="Assembly.getParamValuesAtZ"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getParamValuesAtZ">[docs]</a>    <span class="k">def</span> <span class="nf">getParamValuesAtZ</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">elevations</span><span class="p">,</span> <span class="n">interpType</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">fillValue</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">NaN</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolates a param axially to find it at any value of elevation z.</span>

<span class="sd">        By default, assumes that all parameters are for the center of a block. So for</span>
<span class="sd">        parameters such as THoutletTemperature that are defined on the top, this may be</span>
<span class="sd">        off. See the paramDefinedAt parameters.</span>

<span class="sd">        Defaults to linear interpolations.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This caches interpolators for each param and must be cleared if new params are</span>
<span class="sd">        set or new heights are set.</span>

<span class="sd">        WARNING:</span>
<span class="sd">        Fails when requested to extrapolate.With higher order splines it is possible</span>
<span class="sd">        to interpolate non-physical values, for example a negative flux or dpa. Please</span>
<span class="sd">        use caution when going off default in interpType and be certain that</span>
<span class="sd">        interpolated values are physical.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param : str</span>
<span class="sd">            the parameter to interpolate</span>

<span class="sd">        elevations : array of float</span>
<span class="sd">            the elevations from the bottom of the assembly in cm at which you want the</span>
<span class="sd">            point.</span>

<span class="sd">        interpType: str or int</span>
<span class="sd">            used in interp1d. interp1d documention: Specifies the kind of interpolation</span>
<span class="sd">            as a string (&#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">            where &#39;slinear&#39;, &#39;quadratic&#39; and &#39;cubic&#39; refer to a spline interpolation of</span>
<span class="sd">            first, second or third order) or as an integer specifying the order of the</span>
<span class="sd">            spline interpolator to use. Default is &#39;linear&#39;.</span>

<span class="sd">        fillValue: str</span>
<span class="sd">            Rough pass through to scipy.interpolate.interp1d. If &#39;extend&#39;, then the</span>
<span class="sd">            lower and upper bounds are used as the extended value. If &#39;extrapolate&#39;,</span>
<span class="sd">            then extrapolation is permitted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        valAtZ : numpy.ndarray</span>
<span class="sd">            This will be of the shape (z,data-shape)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">interpolator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParamOfZFunction</span><span class="p">(</span>
            <span class="n">param</span><span class="p">,</span> <span class="n">interpType</span><span class="o">=</span><span class="n">interpType</span><span class="p">,</span> <span class="n">fillValue</span><span class="o">=</span><span class="n">fillValue</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">elevations</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembly.getParamOfZFunction"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getParamOfZFunction">[docs]</a>    <span class="k">def</span> <span class="nf">getParamOfZFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">interpType</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">fillValue</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">NaN</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolates a param axially to find it at any value of elevation z.</span>

<span class="sd">        By default, assumes that all parameters are for the center of a block. So for</span>
<span class="sd">        parameters such as THoutletTemperature that are defined on the top, this may be</span>
<span class="sd">        off. See the paramDefinedAt parameters.</span>

<span class="sd">        Defaults to linear interpolations.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This caches interpolators for each param and must be cleared if new params are</span>
<span class="sd">        set or new heights are set.</span>

<span class="sd">        WARNING: Fails when requested to extrapololate. With higher order splines it is</span>
<span class="sd">        possible to interpolate nonphysical values, for example a negative flux or dpa.</span>
<span class="sd">        Please use caution when going off default in interpType and be certain that</span>
<span class="sd">        interpolated values are physical.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param : str</span>
<span class="sd">            the parameter to interpolate</span>

<span class="sd">        interpType: str or int</span>
<span class="sd">            used in interp1d. interp1d documention: Specifies the kind of interpolation</span>
<span class="sd">            as a string (&#39;linear&#39;, &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;</span>
<span class="sd">            where &#39;slinear&#39;, &#39;quadratic&#39; and &#39;cubic&#39; refer to a spline interpolation of</span>
<span class="sd">            first, second or third order) or as an integer specifying the order of the</span>
<span class="sd">            spline interpolator to use. Default is &#39;linear&#39;.</span>

<span class="sd">        fillValue: float</span>
<span class="sd">            Rough pass through to scipy.interpolate.interp1d. If &#39;extend&#39;, then the</span>
<span class="sd">            lower and upper bounds are used as the extended value. If &#39;extrapolate&#39;,</span>
<span class="sd">            then extrapolation is permitted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        valAtZ : numpy.ndarray</span>
<span class="sd">            This will be of the shape (z,data-shape)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paramDef</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">paramDefs</span><span class="p">[</span><span class="n">param</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paramDef</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="n">ParamLocation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Cannot interpolate on `</span><span class="si">{}</span><span class="s2">`. The ParamDefinition does not define a &quot;</span>
                <span class="s2">&quot;valid location `</span><span class="si">{}</span><span class="s2">`.</span><span class="se">\n</span><span class="s2">Valid locations are </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">param</span><span class="p">,</span>
                    <span class="n">paramDef</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                    <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">pl</span><span class="p">)</span> <span class="k">for</span> <span class="n">pl</span> <span class="ow">in</span> <span class="n">ParamLocation</span><span class="p">]),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">atCenter</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span>
            <span class="n">paramDef</span><span class="o">.</span><span class="n">location</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">ParamLocation</span><span class="o">.</span><span class="n">CENTROID</span> <span class="o">|</span> <span class="n">ParamLocation</span><span class="o">.</span><span class="n">VOLUME_INTEGRATED</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAxialMesh</span><span class="p">(</span><span class="n">atCenter</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">paramDef</span><span class="o">.</span><span class="n">location</span> <span class="o">&amp;</span> <span class="n">ParamLocation</span><span class="o">.</span><span class="n">BOTTOM</span><span class="p">:</span>
            <span class="n">z</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">z</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildParamValues</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="n">boundsError</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">fillValue</span> <span class="o">==</span> <span class="s2">&quot;extend&quot;</span><span class="p">:</span>
            <span class="n">boundsError</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fillValue</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">fillValue</span> <span class="o">=</span> <span class="n">values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">values</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s1">&#39;Unsupported shape (</span><span class="si">{}</span><span class="s1">) returned from getChildParamValues(&quot;</span><span class="si">{}</span><span class="s1">&quot;).&#39;</span>
                    <span class="s2">&quot;Shape must be 1 or 2 dimensions&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="n">interpolater</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
            <span class="n">z</span><span class="p">,</span>
            <span class="n">values</span><span class="p">,</span>
            <span class="n">kind</span><span class="o">=</span><span class="n">interpType</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fillValue</span><span class="p">,</span>
            <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">bounds_error</span><span class="o">=</span><span class="n">boundsError</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">interpolater</span></div>

<div class="viewcode-block" id="Assembly.reestablishBlockOrder"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.reestablishBlockOrder">[docs]</a>    <span class="k">def</span> <span class="nf">reestablishBlockOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        After children have been mixed up axially, this re-locates each block with the proper axial mesh.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        calculateZCoords : updates the ztop/zbottom params on each block after</span>
<span class="sd">            reordering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># replace grid with one that has the right number of locations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">axialUnitGrid</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">armiObject</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">zi</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">b</span><span class="o">.</span><span class="n">spatialLocator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zi</span><span class="p">]</span>
            <span class="c1"># update the name too. NOTE: You must update the history tracker.</span>
            <span class="n">b</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">makeName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span><span class="p">,</span> <span class="n">zi</span><span class="p">))</span></div>

<div class="viewcode-block" id="Assembly.countBlocksWithFlags"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.countBlocksWithFlags">[docs]</a>    <span class="k">def</span> <span class="nf">countBlocksWithFlags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blockTypeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of blocks of a specified type.</span>

<span class="sd">        blockTypeSpec : Flags or list</span>
<span class="sd">            Restrict to only these types of blocks. typeSpec is None, return all of the</span>
<span class="sd">            blocks</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        blockCounter : int</span>
<span class="sd">            number of blocks of this type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">blockTypeSpec</span><span class="p">))</span></div>

<div class="viewcode-block" id="Assembly.getDim"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getDim">[docs]</a>    <span class="k">def</span> <span class="nf">getDim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">dimName</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search through blocks in this assembly and find the first component of compName.</span>
<span class="sd">        Then, look on that component for dimName.</span>

<span class="sd">        Example: getDim(Flags.WIRE, &#39;od&#39;) will return a wire&#39;s OD in cm.</span>

<span class="sd">        .. impl:: Assembly dimensions are retrievable.</span>
<span class="sd">            :id: I_ARMI_ASSEM_DIMS3</span>
<span class="sd">            :implements: R_ARMI_ASSEM_DIMS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># prefer fuel blocks.</span>
        <span class="n">bList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bList</span><span class="p">:</span>
            <span class="c1"># no fuel blocks. take first block.</span>
            <span class="n">bList</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bList</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">getDim</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">dimName</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dim</span>

        <span class="c1"># return none if there is nothing to return</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Assembly.getSymmetryFactor"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.getSymmetryFactor">[docs]</a>    <span class="k">def</span> <span class="nf">getSymmetryFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the symmetry factor of this assembly.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getSymmetryFactor</span><span class="p">()</span></div>

<div class="viewcode-block" id="Assembly.rotate"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.Assembly.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rad</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rotates the spatial variables on an assembly by the specified angle.</span>

<span class="sd">        Each block on the assembly is rotated in turn.</span>

<span class="sd">        .. impl:: An assembly can be rotated about its z-axis.</span>
<span class="sd">            :id: I_ARMI_SHUFFLE_ROTATE</span>
<span class="sd">            :implements: R_ARMI_SHUFFLE_ROTATE</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rad: float</span>
<span class="sd">            number (in radians) specifying the angle of counter clockwise rotation</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        rad must be in 60-degree increments! (i.e., PI/6, PI/3, PI, 2 * PI/3, 5 * PI/6, etc)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBlocks</span><span class="p">():</span>
            <span class="n">b</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HexAssembly"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.HexAssembly">[docs]</a><span class="k">class</span> <span class="nc">HexAssembly</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Placeholder, so users can explicitly define a hex-based assembly.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="CartesianAssembly"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.CartesianAssembly">[docs]</a><span class="k">class</span> <span class="nc">CartesianAssembly</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="RZAssembly"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.RZAssembly">[docs]</a><span class="k">class</span> <span class="nc">RZAssembly</span><span class="p">(</span><span class="n">Assembly</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RZAssembly are assemblies in RZ geometry; they need to be different objects than</span>
<span class="sd">    HexAssembly because they use different locations and need to have Radial Meshes in</span>
<span class="sd">    their setting.</span>

<span class="sd">    note ThRZAssemblies should be a subclass of Assemblies (similar to Hex-Z) because</span>
<span class="sd">    they should have a common place to put information about subdividing the global mesh</span>
<span class="sd">    for transport - this is similar to how blocks have &#39;AxialMesh&#39; in their blocks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">assemNum</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">Assembly</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">assemNum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">RadMesh</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="RZAssembly.radialOuter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.RZAssembly.radialOuter">[docs]</a>    <span class="k">def</span> <span class="nf">radialOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the outer radial boundary of this assembly.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.blocks.ThRZBlock.radialOuter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">radialOuter</span><span class="p">()</span></div>

<div class="viewcode-block" id="RZAssembly.radialInner"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.RZAssembly.radialInner">[docs]</a>    <span class="k">def</span> <span class="nf">radialInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the inner radial boundary of this assembly.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.blocks.ThRZBlock.radialInner</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">radialInner</span><span class="p">()</span></div>

<div class="viewcode-block" id="RZAssembly.thetaOuter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.RZAssembly.thetaOuter">[docs]</a>    <span class="k">def</span> <span class="nf">thetaOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the outer azimuthal boundary of this assembly.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.blocks.ThRZBlock.thetaOuter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">thetaOuter</span><span class="p">()</span></div>

<div class="viewcode-block" id="RZAssembly.thetaInner"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.RZAssembly.thetaInner">[docs]</a>    <span class="k">def</span> <span class="nf">thetaInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the outer azimuthal boundary of this assembly.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.blocks.ThRZBlock.thetaInner</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">thetaInner</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="ThRZAssembly"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.assemblies.html#armi.reactor.assemblies.ThRZAssembly">[docs]</a><span class="k">class</span> <span class="nc">ThRZAssembly</span><span class="p">(</span><span class="n">RZAssembly</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ThRZAssembly are assemblies in ThetaRZ geometry, they need to be different objects</span>
<span class="sd">    than HexAssembly because they use different locations and need to have Radial Meshes</span>
<span class="sd">    in their setting.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is a subclass of RZAssemblies, which is its a subclass of the Generics Assembly</span>
<span class="sd">    Object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">assemNum</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">RZAssembly</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">assemNum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">AziMesh</span> <span class="o">=</span> <span class="mi">1</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2009-2024, TerraPower, LLC.
      <span class="lastupdated">Last updated on 2024-01-22.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
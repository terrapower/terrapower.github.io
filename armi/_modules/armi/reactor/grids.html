

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>armi.reactor.grids &mdash; ARMI 0.2.5 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_fixes.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/armiicon_16x16.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="../../../_static/assets/jsonview.bundle.js"></script>
        <script src="../../../_static/assets/jsonview_loader.js"></script>
        <script src="../../../_static/sphinx-needs/libs/html/datatables.min.js"></script>
        <script src="../../../_static/sphinx-needs/libs/html/datatables_loader.js"></script>
        <script src="../../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >
          

          
            <a href="../../../index.html" class="icon icon-home"> ARMI
          

          
            
            <img src="../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../requirements/index.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../.apidocs/modules.html">API Docs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ARMI</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../armi.html">armi</a> &raquo;</li>
        
          <li><a href="../reactor.html">armi.reactor</a> &raquo;</li>
        
      <li>armi.reactor.grids</li>
    
    
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for armi.reactor.grids</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This contains structured meshes in multiple geometries and spatial locators (i.e. locations).</span>

<span class="sd">:py:class:`Grids &lt;Grid&gt;` are objects that map indices (i, j, k) to spatial locations</span>
<span class="sd">(x,y,z) or (t,r,z).  They are useful for arranging things in reactors, such as:</span>

<span class="sd">* Fuel assemblies in a reactor</span>
<span class="sd">* Plates in a heat exchanger</span>
<span class="sd">* Pins in a fuel assembly</span>
<span class="sd">* Blocks in a fuel assembly (1-D)</span>

<span class="sd">Fast reactors often use a hexagonal grid, while other reactors may be better suited for</span>
<span class="sd">Cartesian or RZT grids. This module contains representations of all these.</span>

<span class="sd">``Grid``\ s can be defined by any arbitrary combination of absolute grid boundaries and</span>
<span class="sd">unit step directions.</span>

<span class="sd">Associated with grids are :py:class:`IndexLocations &lt;IndexLocation&gt;`. Each of these maps</span>
<span class="sd">to a single cell in a grid, or to an arbitrary point in the continuous space represented</span>
<span class="sd">by a grid. When a `Grid`` is built, it builds a collection of ``IndexLocation``\ s, one</span>
<span class="sd">for each cell.</span>

<span class="sd">In the ARMI :py:mod:`armi.reactor` module, each object is assigned a locator either from</span>
<span class="sd">a grid or in arbitrary, continuous space (using a :py:class:`CoordinateLocation`) on the</span>
<span class="sd">``spatialLocator`` attribute.</span>

<span class="sd">Below is a basic example of how to use a 2-D grid::</span>

<span class="sd">    &gt;&gt;&gt; grid = CartesianGrid.fromRectangle(1.0, 1.0)  # 1 cm square-pitch Cartesian grid</span>
<span class="sd">    &gt;&gt;&gt; location = grid[1,2,0]</span>
<span class="sd">    &gt;&gt;&gt; location.getGlobalCoordinates()</span>
<span class="sd">    array([ 1.,  2.,  0.])</span>

<span class="sd">Grids can be chained together in a parent-child relationship. This is often used in ARMI</span>
<span class="sd">where a 1-D axial grid (e.g. in an assembly) is being positioned in a core or spent-fuel</span>
<span class="sd">pool. See example in</span>
<span class="sd">:py:meth:`armi.reactor.tests.test_grids.TestSpatialLocator.test_recursion`.</span>

<span class="sd">The &quot;radial&quot; (ring, position) indexing used in DIF3D can be converted to and from the</span>
<span class="sd">more quasi-Cartesian indexing in a hex mesh easily with the utility methods</span>
<span class="sd">:py:meth:`HexGrid.getRingPos` and :py:func:`indicesToRingPos`.</span>

<span class="sd">This module is designed to satisfy the spatial arrangement requirements of :py:mod:`the</span>
<span class="sd">Reactor package &lt;armi.reactor&gt;`.</span>

<span class="sd">Throughout the module, the term **global** refers to the top-level coordinate system</span>
<span class="sd">while the word **local** refers to within the current coordinate system defined by the</span>
<span class="sd">current grid.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy.linalg</span>


<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">hexagon</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="kn">import</span> <span class="n">geometry</span>

<span class="c1"># data structure for database-serialization of grids</span>
<span class="n">GridParameters</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span>
    <span class="s2">&quot;GridParameters&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;unitSteps&quot;</span><span class="p">,</span> <span class="s2">&quot;bounds&quot;</span><span class="p">,</span> <span class="s2">&quot;unitStepLimits&quot;</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="s2">&quot;geomType&quot;</span><span class="p">,</span> <span class="s2">&quot;symmetry&quot;</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">TAU</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">2.0</span>
<span class="n">BOUNDARY_0_DEGREES</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">BOUNDARY_60_DEGREES</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">BOUNDARY_120_DEGREES</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">BOUNDARY_CENTER</span> <span class="o">=</span> <span class="mi">4</span>

<span class="n">COS30</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
<span class="n">SIN30</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">2.0</span>
<span class="c1"># going CCW from &quot;position 1&quot; (top right)</span>
<span class="n">TRIANGLES_IN_HEXAGON</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="p">(</span><span class="o">+</span><span class="n">COS30</span><span class="p">,</span> <span class="n">SIN30</span><span class="p">),</span>
        <span class="p">(</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="p">(</span><span class="o">-</span><span class="n">COS30</span><span class="p">,</span> <span class="n">SIN30</span><span class="p">),</span>
        <span class="p">(</span><span class="o">-</span><span class="n">COS30</span><span class="p">,</span> <span class="o">-</span><span class="n">SIN30</span><span class="p">),</span>
        <span class="p">(</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">),</span>
        <span class="p">(</span><span class="o">+</span><span class="n">COS30</span><span class="p">,</span> <span class="o">-</span><span class="n">SIN30</span><span class="p">),</span>
    <span class="p">]</span>
<span class="p">)</span>


<div class="viewcode-block" id="LocationBase"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.LocationBase">[docs]</a><span class="k">class</span> <span class="nc">LocationBase</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A namedtuple-like object for storing location information.</span>

<span class="sd">    It&#39;s immutable (you can&#39;t set things after construction) and has names.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This was originally a namedtuple but there was a somewhat unbelievable</span>
<span class="sd">    bug in Python 2.7.8 where unpickling a reactor full of these ended up</span>
<span class="sd">    inexplicably replacing one of them with an AssemblyParameterCollection.</span>
<span class="sd">    The bug did not show up in Python 3.</span>

<span class="sd">    Converting to this class solved that problem.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_i&quot;</span><span class="p">,</span> <span class="s2">&quot;_j&quot;</span><span class="p">,</span> <span class="s2">&quot;_k&quot;</span><span class="p">,</span> <span class="s2">&quot;_grid&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">=</span> <span class="n">i</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_j</span> <span class="o">=</span> <span class="n">j</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">grid</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2"> @ (</span><span class="si">{}</span><span class="s2">,</span><span class="si">{:}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">)&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used in pickling and deepcopy, this detaches the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unpickle a locator, the grid will attach itself if it was also pickled, otherwise this will</span>
<span class="sd">        be detached.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">i</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">j</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_j</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">k</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a hash so we can use these as dict keys w/o having exact object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Including the ``grid`` attribute may be more robust; however, using only (i, j, k) allows</span>
<span class="sd">        dictionaries to use IndexLocations and (i,j,k) tuples interchangeably.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">i</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">j</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">k</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A Locationbase is less than another if the pseudo-radius is less, or if equal, in order</span>
<span class="sd">        any index is less.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; grid = grids.HexGrid.fromPitch(1.0)</span>
<span class="sd">        &gt;&gt;&gt; grid[0, 0, 0] &lt; grid[2, 3, 4]   # the &quot;radius&quot; is less</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; grid[2, 3, 4] &lt; grid[2, 3, 4]   # they are equal</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; grid[2, 3, 4] &lt; grid[-2, 3, 4]  # 2 is greater than -2</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; grid[-2, 3, 4] &lt; grid[2, 3, 4]  # -2 is less than 2</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; grid[1, 3, 4] &lt; grid[-2, 3, 4]  # the &quot;radius&quot; is less</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">selfIndices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">thatIndices</span> <span class="o">=</span> <span class="n">that</span><span class="o">.</span><span class="n">indices</span>
        <span class="c1"># this is not really r, but it is fast and consistent</span>
        <span class="n">selfR</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">selfIndices</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">thatR</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">thatIndices</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># this cannot be reduced to</span>
        <span class="c1">#   return selfR &lt; thatR or (selfIndices &lt; thatIndices).any()</span>
        <span class="c1"># because the comparison is not symmetric.</span>
        <span class="k">if</span> <span class="n">selfR</span> <span class="o">&lt;</span> <span class="n">thatR</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lt</span><span class="p">,</span> <span class="n">eq</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">selfIndices</span> <span class="o">&lt;</span> <span class="n">thatIndices</span><span class="p">,</span> <span class="n">selfIndices</span> <span class="o">==</span> <span class="n">thatIndices</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">eq</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">return</span> <span class="n">lt</span>

            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns 3, the number of directions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">3</span>

<div class="viewcode-block" id="LocationBase.associate"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.LocationBase.associate">[docs]</a>    <span class="k">def</span> <span class="nf">associate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-assign locator to another Grid.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">grid</span></div></div>


<div class="viewcode-block" id="IndexLocation"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.IndexLocation">[docs]</a><span class="k">class</span> <span class="nc">IndexLocation</span><span class="p">(</span><span class="n">LocationBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An immutable location representing one cell in a grid.</span>

<span class="sd">    The locator is intimately tied to a grid and together, they represent</span>
<span class="sd">    a grid cell somewhere in the coordinate system of the grid.</span>

<span class="sd">    ``grid`` is not in the constructor (must be added after construction ) because</span>
<span class="sd">    the extra argument (grid) gives an inconsistency between __init__ and __new__.</span>
<span class="sd">    Unfortunately this decision makes whipping up IndexLocations on the fly awkward.</span>
<span class="sd">    But perhaps that&#39;s ok because they should only be created by their grids.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable adding with other objects like this and/or 3-tuples.</span>

<span class="sd">        Tuples are needed so we can terminate the recursive additions with a (0,0,0) basis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># New location is not associated with any particular grid.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">that</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">that</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">that</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="kc">None</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">that</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">that</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">that</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="kc">None</span>
        <span class="p">)</span>

<div class="viewcode-block" id="IndexLocation.detachedCopy"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.IndexLocation.detachedCopy">[docs]</a>    <span class="k">def</span> <span class="nf">detachedCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of this locator that is not associated with a grid.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.reactors.detach : uses this</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parentLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the spatialLocator of the ArmiObject that this locator&#39;s grid is anchored to.</span>

<span class="sd">        For example, if this is one of many spatialLocators in a 2-D grid representing</span>
<span class="sd">        a reactor, then the ``parentLocation`` is the spatialLocator of the reactor, which</span>
<span class="sd">        will often be a ``CoordinateLocation``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>  <span class="c1"># performance matters a lot here so we remove a dot</span>
        <span class="c1"># check for None rather than __nonzero__ for speed (otherwise it checks the length)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">grid</span><span class="o">.</span><span class="n">armiObject</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">grid</span><span class="o">.</span><span class="n">armiObject</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">grid</span><span class="o">.</span><span class="n">armiObject</span><span class="o">.</span><span class="n">spatialLocator</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the non-grid indices (i,j,k) of this locator.</span>

<span class="sd">        This strips off the annoying ``grid`` tagalong which is there to ensure proper</span>
<span class="sd">        equality (i.e. (0,0,0) in a storage rack is not equal to (0,0,0) in a core).</span>

<span class="sd">        It is a numpy array for two reasons:</span>

<span class="sd">        1. It can be added and subtracted for the recursive computations</span>
<span class="sd">           through different coordinate systems</span>
<span class="sd">        2. It can be written/read from the database.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>

<div class="viewcode-block" id="IndexLocation.getCompleteIndices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.IndexLocation.getCompleteIndices">[docs]</a>    <span class="k">def</span> <span class="nf">getCompleteIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform the indices of this object up to the top mesh.</span>

<span class="sd">        The top mesh is either the one where there&#39;s no more parent (true top)</span>
<span class="sd">        or when an axis gets added twice. Unlike with coordinates,</span>
<span class="sd">        you can only add each index axis one time. Thus a *complete*</span>
<span class="sd">        set of indices is one where an index for each axis has been defined</span>
<span class="sd">        by a set of 1, 2, or 3 nested grids.</span>

<span class="sd">        This is useful for getting the reactor-level (i,j,k) indices of an object</span>
<span class="sd">        in a multi-layered 2-D(assemblies in core)/1-D(blocks in assembly) mesh</span>
<span class="sd">        like the one mapping blocks up to reactor in Hex reactors.</span>

<span class="sd">        The benefit of that particular mesh over a 3-D one is that different</span>
<span class="sd">        assemblies can have different axial meshes, a common situation.</span>

<span class="sd">        It will just return local indices for pin-meshes inside of blocks.</span>

<span class="sd">        A tuple is returned so that it is easy to compare pairs of indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parentLocation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parentLocation</span>  <span class="c1"># to avoid evaluating property if&#39;s twice</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
        <span class="k">if</span> <span class="n">parentLocation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parentLocation</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">addingIsValid</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">parentLocation</span><span class="o">.</span><span class="n">grid</span>
            <span class="p">):</span>
                <span class="n">indices</span> <span class="o">+=</span> <span class="n">parentLocation</span><span class="o">.</span><span class="n">indices</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndexLocation.getLocalCoordinates"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.IndexLocation.getLocalCoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">getLocalCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nativeCoords</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the coordinates of the center of the mesh cell here in cm.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot get local coordinates of </span><span class="si">{}</span><span class="s2"> because grid is None.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">nativeCoords</span><span class="o">=</span><span class="n">nativeCoords</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndexLocation.getGlobalCoordinates"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.IndexLocation.getGlobalCoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">getGlobalCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nativeCoords</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get coordinates in global 3D space of the centroid of this object.&quot;&quot;&quot;</span>
        <span class="n">parentLocation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parentLocation</span>  <span class="c1"># to avoid evaluating property if&#39;s twice</span>
        <span class="k">if</span> <span class="n">parentLocation</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">(</span>
                <span class="n">nativeCoords</span><span class="o">=</span><span class="n">nativeCoords</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">parentLocation</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">(</span><span class="n">nativeCoords</span><span class="o">=</span><span class="n">nativeCoords</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">(</span><span class="n">nativeCoords</span><span class="o">=</span><span class="n">nativeCoords</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndexLocation.getGlobalCellBase"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.IndexLocation.getGlobalCellBase">[docs]</a>    <span class="k">def</span> <span class="nf">getGlobalCellBase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the cell base (i.e. &quot;bottom left&quot;), in global coordinate system.&quot;&quot;&quot;</span>
        <span class="n">parentLocation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parentLocation</span>  <span class="c1"># to avoid evaluating property if&#39;s twice</span>
        <span class="k">if</span> <span class="n">parentLocation</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parentLocation</span><span class="o">.</span><span class="n">getGlobalCellBase</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getCellBase</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getCellBase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndexLocation.getGlobalCellTop"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.IndexLocation.getGlobalCellTop">[docs]</a>    <span class="k">def</span> <span class="nf">getGlobalCellTop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the cell top (i.e. &quot;top right&quot;), in global coordinate system.&quot;&quot;&quot;</span>
        <span class="n">parentLocation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parentLocation</span>  <span class="c1"># to avoid evaluating property if&#39;s twice</span>
        <span class="k">if</span> <span class="n">parentLocation</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parentLocation</span><span class="o">.</span><span class="n">getGlobalCellTop</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getCellTop</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getCellTop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndexLocation.getRingPos"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.IndexLocation.getRingPos">[docs]</a>    <span class="k">def</span> <span class="nf">getRingPos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ring and position of this locator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">())</span></div>

<div class="viewcode-block" id="IndexLocation.getSymmetricEquivalents"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.IndexLocation.getSymmetricEquivalents">[docs]</a>    <span class="k">def</span> <span class="nf">getSymmetricEquivalents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get symmetrically-equivalent locations, based on Grid symmetry.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Grid.getSymmetricEquivalents</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getSymmetricEquivalents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndexLocation.distanceTo"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.IndexLocation.distanceTo">[docs]</a>    <span class="k">def</span> <span class="nf">distanceTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the distance from this locator to another.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">())</span>
                    <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">())</span>
                <span class="p">)</span>
                <span class="o">**</span> <span class="mi">2</span>
            <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="MultiIndexLocation"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.MultiIndexLocation">[docs]</a><span class="k">class</span> <span class="nc">MultiIndexLocation</span><span class="p">(</span><span class="n">IndexLocation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A collection of index locations that can be used as a spatialLocator.</span>

<span class="sd">    This allows components with multiplicity&gt;1 to have location information</span>
<span class="sd">    within a parent grid. The implication is that there are multiple</span>
<span class="sd">    discrete components, each one residing in one of the actual locators</span>
<span class="sd">    underlying this collection.</span>

<span class="sd">    This class contains an implementation that allows a multi-index</span>
<span class="sd">    location to be used in the ARMI data model similar to a</span>
<span class="sd">    individual IndexLocation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># MIL&#39;s cannot be hashed, so we need to scrape off the implementation from</span>
    <span class="c1"># LocationBase. This raises some interesting questions of substitutability of the</span>
    <span class="c1"># various Location classes, which should be addressed.</span>
    <span class="fm">__hash__</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="n">IndexLocation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used in pickling and deepcopy, this detaches the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unpickle a locator, the grid will attach itself if it was also pickled, otherwise this will</span>
<span class="sd">        be detached.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span> <span class="o">=</span> <span class="n">state</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2"> with </span><span class="si">{}</span><span class="s2"> locations&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">)</span>

<div class="viewcode-block" id="MultiIndexLocation.detachedCopy"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.MultiIndexLocation.detachedCopy">[docs]</a>    <span class="k">def</span> <span class="nf">detachedCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">MultiIndexLocation</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">loc</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span></div>

<div class="viewcode-block" id="MultiIndexLocation.associate"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.MultiIndexLocation.associate">[docs]</a>    <span class="k">def</span> <span class="nf">associate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">:</span>
            <span class="n">loc</span><span class="o">.</span><span class="n">associate</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiIndexLocation.getCompleteIndices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.MultiIndexLocation.getCompleteIndices">[docs]</a>    <span class="k">def</span> <span class="nf">getCompleteIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Multi locations cannot do this yet.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiIndexLocation.append"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.MultiIndexLocation.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">:</span> <span class="n">IndexLocation</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">location</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiIndexLocation.extend"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.MultiIndexLocation.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">IndexLocation</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">locations</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiIndexLocation.pop"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.MultiIndexLocation.pop">[docs]</a>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">:</span> <span class="n">IndexLocation</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">location</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return indices for all locations.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Notice that this returns a list of all of the indices, unlike the ``indices()``</span>
<span class="sd">        implementation for :py:class:`IndexLocation`. This is intended to make the</span>
<span class="sd">        behavior of getting the indices from the Locator symmetric with passing a list</span>
<span class="sd">        of indices to the Grid&#39;s ``__getitem__()`` function, which constructs and</span>
<span class="sd">        returns a ``MultiIndexLocation`` containing those indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">loc</span><span class="o">.</span><span class="n">indices</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">]</span></div>


<div class="viewcode-block" id="CoordinateLocation"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CoordinateLocation">[docs]</a><span class="k">class</span> <span class="nc">CoordinateLocation</span><span class="p">(</span><span class="n">IndexLocation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A triple representing a point in space.</span>

<span class="sd">    This is still associated with a grid. The grid defines the continuous coordinate</span>
<span class="sd">    space and axes that the location is within. This also links to the composite tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

<div class="viewcode-block" id="CoordinateLocation.getLocalCoordinates"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CoordinateLocation.getLocalCoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">getLocalCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nativeCoords</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return x,y,z coordinates in cm within the grid&#39;s coordinate system.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span></div>

<div class="viewcode-block" id="CoordinateLocation.getCompleteIndices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CoordinateLocation.getCompleteIndices">[docs]</a>    <span class="k">def</span> <span class="nf">getCompleteIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Top of chain. Stop recursion and return basis.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="CoordinateLocation.getGlobalCellBase"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CoordinateLocation.getGlobalCellBase">[docs]</a>    <span class="k">def</span> <span class="nf">getGlobalCellBase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span></div>

<div class="viewcode-block" id="CoordinateLocation.getGlobalCellTop"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CoordinateLocation.getGlobalCellTop">[docs]</a>    <span class="k">def</span> <span class="nf">getGlobalCellTop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span></div></div>


<div class="viewcode-block" id="Grid"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid">[docs]</a><span class="k">class</span> <span class="nc">Grid</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A connected set of cells characterized by indices mapping to space and vice versa.</span>

<span class="sd">    The cells may be characterized by any mixture of regular repeating steps and</span>
<span class="sd">    user-defined steps in any direction.</span>

<span class="sd">    For example, a 2-D hex lattice has constant, regular steps whereas a 3-D hex mesh</span>
<span class="sd">    may have user-defined axial meshes. Similar for Cartesian, RZT, etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unitSteps : tuple of tuples, optional</span>
<span class="sd">        Describes the grid spatially as a function on indices.</span>
<span class="sd">        Each tuple describes how each ``(x,y,or z)`` dimension is influenced by</span>
<span class="sd">        ``(i,j,k)``. In other words, it is::</span>

<span class="sd">            (dxi, dxj, jxk), (dyi, dyj, dyk), (dzi, dzj, dzk)</span>

<span class="sd">        where ``dmn`` is the distance (in cm) that dimension ``m`` will change as a</span>
<span class="sd">        function of index ``n``.</span>

<span class="sd">        Unit steps are used as a generic method for defining repetitive grids in a</span>
<span class="sd">        variety of geometries, including hexagonal and Cartesian.  The tuples are not</span>
<span class="sd">        vectors in the direction of the translation, but rather grouped by direction. If</span>
<span class="sd">        the bounds argument is described for a direction, the bounds will be used rather</span>
<span class="sd">        than the unit step information.  The default of (0, 0, 0) makes all dimensions</span>
<span class="sd">        insensitive to indices since the coordinates are calculated by the dot product</span>
<span class="sd">        of this and the indices.  With this default, any dimension that is desired to</span>
<span class="sd">        change with indices should be defined with bounds. RZtheta grids are created</span>
<span class="sd">        exclusively with bounds.</span>

<span class="sd">    bounds : 3-tuple</span>
<span class="sd">        Absolute increasing bounds in cm including endpoints of a non-uniform grid.</span>
<span class="sd">        Each item represents the boundaries in the associated direction.  Use Nones when</span>
<span class="sd">        unitSteps should be applied instead. Most useful for thetaRZ grids or other</span>
<span class="sd">        non-uniform grids.</span>

<span class="sd">    unitStepLimits : 3-tuple</span>
<span class="sd">        The limit of the steps in all three directions. This constrains step-defined</span>
<span class="sd">        grids to be finite so we can populate them with SpatialLocator objects.</span>

<span class="sd">    offset : 3-tuple, optional</span>
<span class="sd">        Offset in cm for each axis. By default the center of the (0,0,0)-th object is in</span>
<span class="sd">        the center of the grid.  Offsets can move it so that the (0,0,0)-th object can</span>
<span class="sd">        be fully within a quadrant (i.e. in a Cartesian grid).</span>

<span class="sd">    armiObject : ArmiObject, optional</span>
<span class="sd">        The ArmiObject that this grid describes. For example if it&#39;s a 1-D assembly</span>
<span class="sd">        grid, the armiObject is the assembly. Note that ``self.armiObject.spatialGrid``</span>
<span class="sd">        is ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A 2D a rectangular grid with width (x) 2 and height (y) 3 would be::</span>

<span class="sd">    &gt;&gt;&gt; grid = Grid(unitSteps=((2, 0, 0), (0, 3, 0),(0, 0, 0)))</span>

<span class="sd">    A regular hex grid with pitch 1 is::</span>

<span class="sd">    &gt;&gt;&gt; grid = Grid(unitSteps= ((sqrt(3)/2, 0.0, 0.0), (0.5, 1.0, 0.0), (0, 0, 0))</span>

<span class="sd">    .. note:: For this unit hex the magnitude of the vector constructed using the</span>
<span class="sd">              0th index of each tuple is 1.0.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Each dimension must either be defined through unitSteps or bounds.</span>
<span class="sd">    The combination of unitSteps with bounds was settled upon after some struggle to</span>
<span class="sd">    have one unified definition of a grid (i.e. just bounds). A hexagonal grid is</span>
<span class="sd">    somewhat challenging to represent with bounds because the axes are not orthogonal,</span>
<span class="sd">    so a unit-direction vector plus bounds would be required. And then the bounds would</span>
<span class="sd">    be wasted space because they can be derived simply by unit steps. Memory efficiency</span>
<span class="sd">    is important in this object so the compact representation of</span>
<span class="sd">    unitSteps-when-possible, bounds-otherwise was settled upon.</span>

<span class="sd">    Design considerations include:</span>

<span class="sd">    * unitSteps are more intuitive as operations starting from the center of a cell,</span>
<span class="sd">      particularly with hexagons and rectangles. Otherwise the 0,0 position of a hexagon</span>
<span class="sd">      in the center of 1/3-symmetric hexagon is at the phantom bottom left of the</span>
<span class="sd">      hexagon.</span>

<span class="sd">    * Users generally prefer to input mesh bounds rather than centers (e.g. starting at</span>
<span class="sd">      0.5 instead of 0.0 in a unit mesh is weird).</span>

<span class="sd">    * If we store bounds, computing bounds is simple and computing centers takes ~2x the</span>
<span class="sd">      effort. If we store centers, it&#39;s the opposite.</span>

<span class="sd">    * Regardless of how we store things, we&#39;ll need a Grid that has the lower-left</span>
<span class="sd">      assembly fully inside the problem (i.e. for full core Cartesian) as well as</span>
<span class="sd">      another one that has the lower-left assembly half-way or quarter-way sliced off</span>
<span class="sd">      (for 1/2, 1/4, and 1/8 symmetries).  The ``offset`` parameter handles this.</span>

<span class="sd">    * Looking up mesh boundaries (to define a mesh in another code) is generally more</span>
<span class="sd">      common than looking up centers (for plotting or measuring distance).</span>

<span class="sd">    * A grid can be anchored to the object that it is in with a backreference. This</span>
<span class="sd">      gives it the ability to traverse the composite tree and map local to global</span>
<span class="sd">      locations without having to duplicate the composite pattern on grids. This remains</span>
<span class="sd">      optional so grids can be used for non-reactor-package reasons.  It may seem</span>
<span class="sd">      slightly cleaner to set the armiObject to the parent&#39;s spatialLocator itself</span>
<span class="sd">      but the major disadvantage of this is that when an object moves, the armiObject</span>
<span class="sd">      would have to be updated. By anchoring directly to Composite objects, the parent</span>
<span class="sd">      is always up to date no matter where or how things get moved.</span>

<span class="sd">    * Unit step calculations use dot products and must not be polluted by the bound</span>
<span class="sd">      indices. Thus we reduce the size of the unitSteps tuple accordingly.</span>

<span class="sd">    .. impl:: ARMI supports a number of structured mesh options.</span>
<span class="sd">       :id: IMPL_REACTOR_MESH_0</span>
<span class="sd">       :links: REQ_REACTOR_MESH</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">unitSteps</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">unitStepLimits</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">geomType</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">symmetry</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">armiObject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># these lists contain the indices representing which dimensions for which steps</span>
        <span class="c1"># are used, or for which bounds are used. index 0 is x direction, etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundDims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dimensionIndex</span><span class="p">,</span> <span class="n">bound</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bounds</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimensionIndex</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_boundDims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimensionIndex</span><span class="p">)</span>

        <span class="c1"># numpy prefers tuples like this to do slicing on arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundDims</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundDims</span><span class="p">),)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span><span class="p">),)</span>

        <span class="n">unitSteps</span> <span class="o">=</span> <span class="n">_tuplify</span><span class="p">(</span><span class="n">unitSteps</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unitStepLimits</span> <span class="o">=</span> <span class="n">_tuplify</span><span class="p">(</span><span class="n">unitStepLimits</span><span class="p">)</span>

        <span class="c1"># only represent unit steps in dimensions they&#39;re being used so as to not</span>
        <span class="c1"># pollute the dot product. This may reduce the length of this from 3 to 2 or 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unitSteps</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># indices -&gt; SpatialLocator map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">armiObject</span> <span class="o">=</span> <span class="n">armiObject</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buildLocations</span><span class="p">()</span>  <span class="c1"># locations are owned by a grid, so the grid builds them.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backup</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># for retainState</span>

        <span class="p">(</span><span class="n">_ii</span><span class="p">,</span> <span class="n">iLen</span><span class="p">),</span> <span class="p">(</span><span class="n">_ji</span><span class="p">,</span> <span class="n">jLen</span><span class="p">),</span> <span class="p">(</span><span class="n">_ki</span><span class="p">,</span> <span class="n">kLen</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getIndexBounds</span><span class="p">()</span>
        <span class="c1"># True if only contains k-cells.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isAxialOnly</span> <span class="o">=</span> <span class="n">iLen</span> <span class="o">==</span> <span class="n">jLen</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">kLen</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="c1"># geometric metadata encapsulated here because it&#39;s related to the grid.</span>
        <span class="c1"># They do not impact the grid object itself.</span>
        <span class="c1"># Notice that these are stored using their string representations, rather than</span>
        <span class="c1"># the GridType enum. This avoids the danger of deserializing an enum value from</span>
        <span class="c1"># an old version of the code that may have had different numeric values.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geomType</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">geomType</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_symmetry</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">symmetry</span><span class="p">)</span>

<div class="viewcode-block" id="Grid.reduce"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.reduce">[docs]</a>    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of arguments used to create this Grid.</span>

<span class="sd">        This is very much like the argument tuple from ``__reduce__``, but we do not</span>
<span class="sd">        implement ``__reduce__`` for real, because we are generally happy with</span>
<span class="sd">        ``__getstate__`` and ``__setstate__`` for pickling purposes. However, getting</span>
<span class="sd">        these arguments to ``__init__`` is useful for storing Grids to the database, as</span>
<span class="sd">        they are more stable (less likely to change) than the actual internal state of</span>
<span class="sd">        the objects.</span>

<span class="sd">        The return value should be hashable, such that a set of these can be created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">)</span>

        <span class="n">bounds</span> <span class="o">=</span> <span class="n">_tuplify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">)</span>

        <span class="c1"># recreate a constructor-friendly version of `_unitSteps` from live data (may have been reduced from</span>
        <span class="c1"># length 3 to length 2 or 1 based on mixing the step-based definition and the bounds-based definition</span>
        <span class="c1"># described in Design Considerations above.)</span>
        <span class="c1"># We don&#39;t just save the original tuple passed in because that may miss transformations that</span>
        <span class="c1"># occur between instantiation and reduction.</span>
        <span class="n">unitSteps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">compressedSteps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">[:])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="c1"># Recall _stepDims are stored as a single-value tuple (for numpy indexing)</span>
            <span class="c1"># So this just is grabbing the actual data.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">unitSteps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compressedSteps</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Add dummy value which will never get used (it gets reduced away)</span>
                <span class="n">unitSteps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">unitSteps</span> <span class="o">=</span> <span class="n">_tuplify</span><span class="p">(</span><span class="n">unitSteps</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">GridParameters</span><span class="p">(</span>
            <span class="n">unitSteps</span><span class="p">,</span>
            <span class="n">bounds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unitStepLimits</span><span class="p">,</span>
            <span class="n">offset</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_geomType</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_symmetry</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geomType</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="o">.</span><span class="n">fromStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_geomType</span><span class="p">)</span>

    <span class="nd">@geomType</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">geomType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geomType</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geomType</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">GeomType</span><span class="o">.</span><span class="n">fromAny</span><span class="p">(</span><span class="n">geomType</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">geometry</span><span class="o">.</span><span class="n">SymmetryType</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">geometry</span><span class="o">.</span><span class="n">SymmetryType</span><span class="o">.</span><span class="n">fromStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symmetry</span><span class="p">)</span>

    <span class="nd">@symmetry</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symmetry</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">SymmetryType</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_symmetry</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">SymmetryType</span><span class="o">.</span><span class="n">fromAny</span><span class="p">(</span><span class="n">symmetry</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>

    <span class="nd">@offset</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">offset</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2"> -- </span><span class="si">{}</span><span class="se">\n</span><span class="s2">Bounds:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))]</span>
            <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;  </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">]</span>
            <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;Steps:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">]</span>
            <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;  </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">]</span>
            <span class="o">+</span> <span class="p">[</span>
                <span class="s2">&quot;Anchor: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">armiObject</span><span class="p">),</span>
                <span class="s2">&quot;Offset: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">),</span>
                <span class="s2">&quot;Num Locations: </span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pickling removes reference to ``armiObject``</span>

<span class="sd">        Removing the ``armiObject`` allows us to pickle an assembly without pickling the entire</span>
<span class="sd">        reactor. An ``Assembly.spatialLocator.grid.armiObject`` is the reactor, by removing the link</span>
<span class="sd">        here, we still have spatial orientation, but are not required to pickle the entire reactor</span>
<span class="sd">        to pickle an assembly.</span>

<span class="sd">        This relies on the ``armiObject.__setstate__`` to assign itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;armiObject&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pickling removes reference to ``armiObject``</span>

<span class="sd">        This relies on the ``ArmiObject.__setstate__`` to assign itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_indices</span><span class="p">,</span> <span class="n">locator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">locator</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ijk</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a location by (i, j, k) indices. If it does not exist, create a new one and return it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ijk : tuple of indices or list of the same</span>
<span class="sd">            If provided a tuple, an IndexLocation will be created (if necessary) and</span>
<span class="sd">            returned. If provided a list, each element will create a new IndexLocation</span>
<span class="sd">            (if necessary), and a MultiIndexLocation containing all of the passed</span>
<span class="sd">            indices will be returned.</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        The method is defaultdict-like, in that it will create a new location on the fly. However,</span>
<span class="sd">        the class itself is not really a dictionary, it is just index-able. For example, there is no</span>
<span class="sd">        desire to have a ``__setitem__`` method, because the only way to create a location is by</span>
<span class="sd">        retrieving it or through ``buildLocations``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ijk</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">ijk</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">IndexLocation</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ijk</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">MultiIndexLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">locators</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ijk</span><span class="p">]</span>
            <span class="n">val</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">locators</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Unsupported index type `</span><span class="si">{}</span><span class="s2">` for `</span><span class="si">{}</span><span class="s2">`&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ijk</span><span class="p">),</span> <span class="n">ijk</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">)</span>

<div class="viewcode-block" id="Grid.items"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return list of ((i, j, k), IndexLocation) tuples.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="o">.</span><span class="n">items</span><span class="p">()</span></div>

<div class="viewcode-block" id="Grid.backUp"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.backUp">[docs]</a>    <span class="k">def</span> <span class="nf">backUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gather internal info that should be restored within a retainState.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span></div>

<div class="viewcode-block" id="Grid.restoreBackup"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.restoreBackup">[docs]</a>    <span class="k">def</span> <span class="nf">restoreBackup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backup</span></div>

<div class="viewcode-block" id="Grid.getCoordinates"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getCoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">getCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">nativeCoords</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the coordinates of the center of the mesh cell at the given given indices in cm.&quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluateMesh</span><span class="p">(</span>
            <span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroidBySteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroidByBounds</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Grid.getCellBase"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getCellBase">[docs]</a>    <span class="k">def</span> <span class="nf">getCellBase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the mesh base (lower left) of this mesh cell in cm&quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluateMesh</span><span class="p">(</span>
            <span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshBaseBySteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshBaseByBounds</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Grid.getCellTop"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getCellTop">[docs]</a>    <span class="k">def</span> <span class="nf">getCellTop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the mesh top (upper right) of this mesh cell in cm&quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluateMesh</span><span class="p">(</span>
            <span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshBaseBySteps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshBaseByBounds</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Grid.locatorInDomain"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.locatorInDomain">[docs]</a>    <span class="k">def</span> <span class="nf">locatorInDomain</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">:</span> <span class="n">LocationBase</span><span class="p">,</span> <span class="n">symmetryOverlap</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the passed locator is in the domain represented by the Grid.</span>

<span class="sd">        For instance, if we have a 1/3rd core hex grid, this would return False for</span>
<span class="sd">        locators that are outside of the first third of the grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        locator : LocationBase</span>
<span class="sd">            The location to test</span>
<span class="sd">        symmetryOverlap : bool, optional</span>
<span class="sd">            Whether grid locations along the symmetry line should be considered &quot;in the</span>
<span class="sd">            represented domain&quot;. This can be useful when assemblies are split along the</span>
<span class="sd">            domain boundary, with fractions of the assembly on either side.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not implemented on base Grid type.&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_evaluateMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">stepOperator</span><span class="p">,</span> <span class="n">boundsOperator</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate some function of indices on this grid.</span>

<span class="sd">        Recall from above that steps are mesh centered and bounds are mesh edged.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method may be able to be simplified. Complications from arbitrary</span>
<span class="sd">        mixtures of bounds-based and step-based meshing caused it to get bad.</span>
<span class="sd">        These were separate subclasses first, but in practice almost all cases have some mix</span>
<span class="sd">        of step-based (hexagons, squares), and bounds based (radial, zeta).</span>

<span class="sd">        Improvements welcome!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boundCoords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">boundCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">boundsOperator</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">bounds</span><span class="p">))</span>

        <span class="c1"># limit step operator to the step dimensions</span>
        <span class="n">stepCoords</span> <span class="o">=</span> <span class="n">stepOperator</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span><span class="p">])</span>

        <span class="c1"># now mix/match bounds coords with step coords appropriately.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span><span class="p">]</span> <span class="o">=</span> <span class="n">stepCoords</span>
        <span class="n">result</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundDims</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundCoords</span>
        <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>

    <span class="k">def</span> <span class="nf">_centroidBySteps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_meshBaseBySteps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_centroidBySteps</span><span class="p">(</span><span class="n">indices</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centroidBySteps</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_centroidByBounds</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># avoid wrap-around</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Bounds-defined indices may not be negative.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bounds</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_meshBaseByBounds</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Bounds-defined indices may not be negative.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bounds</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

<div class="viewcode-block" id="Grid.getNeighboringCellIndices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getNeighboringCellIndices">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getNeighboringCellIndices</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the indices of the immediate neighbors of a mesh point in the plane.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span></div>

<div class="viewcode-block" id="Grid.getSymmetricEquivalents"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getSymmetricEquivalents">[docs]</a>    <span class="k">def</span> <span class="nf">getSymmetricEquivalents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of grid indices that contain matching contents based on symmetry.</span>

<span class="sd">        The length of the list will depend on the type of symmetry being used, and</span>
<span class="sd">        potentially the location of the requested indices. E.g.,</span>
<span class="sd">        third-core will return the two sets of indices at the matching location in the</span>
<span class="sd">        other two thirds of the grid, unless it is the central location, in which case</span>
<span class="sd">        no indices will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Grid.getAboveAndBelowCellIndices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getAboveAndBelowCellIndices">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getAboveAndBelowCellIndices</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="Grid.cellIndicesContainingPoint"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.cellIndicesContainingPoint">[docs]</a>    <span class="k">def</span> <span class="nf">cellIndicesContainingPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the indices of a mesh cell that contains a point.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Grid.overlapsWhichSymmetryLine"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.overlapsWhichSymmetryLine">[docs]</a>    <span class="k">def</span> <span class="nf">overlapsWhichSymmetryLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Grid.getLabel"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getLabel">[docs]</a>    <span class="k">def</span> <span class="nf">getLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a string label from a 0-based spatial locator.</span>

<span class="sd">        Returns a string representing i, j, and k indices of the locator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">03d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">j</span><span class="si">:</span><span class="s2">03d</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;-</span><span class="si">{</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s2">03d</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">label</span></div>

<div class="viewcode-block" id="Grid.getIndexBounds"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getIndexBounds">[docs]</a>    <span class="k">def</span> <span class="nf">getIndexBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get min index and number of indices in this grid.</span>

<span class="sd">        Step-defined grids would be infinite but for the step limits defined in the constructor.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This produces output that is intended to be passed to a ``range`` statement.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexBounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">minMax</span><span class="p">,</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitStepLimits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indexBounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minMax</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexBounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indexBounds</span><span class="p">)</span></div>

<div class="viewcode-block" id="Grid.getBounds"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getBounds">[docs]</a>    <span class="k">def</span> <span class="nf">getBounds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
        <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the grid bounds for each dimension, if present.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span></div>

<div class="viewcode-block" id="Grid.getLocatorFromRingAndPos"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getLocatorFromRingAndPos">[docs]</a>    <span class="k">def</span> <span class="nf">getLocatorFromRingAndPos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the location based on ring and position.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ring : int</span>
<span class="sd">            Ring number (1-based indexing)</span>
<span class="sd">        pos : int</span>
<span class="sd">            Position number (1-based indexing)</span>
<span class="sd">        k : int, optional</span>
<span class="sd">            Axial index (0-based indexing)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getIndicesFromRingAndPos</span>
<span class="sd">            This implements the transform into i, j indices based on ring and position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getIndicesFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span></div>

<div class="viewcode-block" id="Grid.getIndicesFromRingAndPos"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getIndicesFromRingAndPos">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getIndicesFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return i, j indices given ring and position.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This should be implemented as a staticmethod, since no Grids currently in</span>
<span class="sd">        exsistence actually need any instance data to perform this task, and</span>
<span class="sd">        staticmethods provide the convenience of calling the method without an instance</span>
<span class="sd">        of the class in the first place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Base Grid does not know about ring/pos&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Grid.getMinimumRings"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getMinimumRings">[docs]</a>    <span class="k">def</span> <span class="nf">getMinimumRings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum number of rings needed to fit ``n`` objects.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        While this is useful and safe for answering the question of &quot;how many rings do I</span>
<span class="sd">        need to hold N things?&quot;, is generally not safe to use it to answer &quot;I have N</span>
<span class="sd">        things; within how many rings are they distributed?&quot;. This function provides a</span>
<span class="sd">        lower bound, assuming that objects are densely-packed. If they are not actually</span>
<span class="sd">        densely packed, this may be unphysical.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Base grid does not know about rings&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Grid.getPositionsInRing"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getPositionsInRing">[docs]</a>    <span class="k">def</span> <span class="nf">getPositionsInRing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of positions within a ring.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Base grid does not know about rings&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Grid.getRingPos"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getRingPos">[docs]</a>    <span class="k">def</span> <span class="nf">getRingPos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get ring and position number in this grid.</span>

<span class="sd">        For non-hex grids this is just i and j.</span>

<span class="sd">        A tuple is returned so that it is easy to compare pairs of indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Regular grids dont really know about ring and position. We can try to see if</span>
        <span class="c1"># their parent does!</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">armiObject</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">armiObject</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">armiObject</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">armiObject</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="c1"># For compatibility&#39;s sake, return __something__. TODO: We may want to just</span>
        <span class="c1"># throw here, to be honest.</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span></div>

<div class="viewcode-block" id="Grid.getAllIndices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.getAllIndices">[docs]</a>    <span class="k">def</span> <span class="nf">getAllIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all possible indices in this grid.&quot;&quot;&quot;</span>
        <span class="n">iBounds</span><span class="p">,</span> <span class="n">jBounds</span><span class="p">,</span> <span class="n">kBounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getIndexBounds</span><span class="p">()</span>
        <span class="n">allIndices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">iBounds</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">jBounds</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">kBounds</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">allIndices</span></div>

<div class="viewcode-block" id="Grid.buildLocations"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.Grid.buildLocations">[docs]</a>    <span class="k">def</span> <span class="nf">buildLocations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Populate all grid cells with a characteristic SpatialLocator.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAllIndices</span><span class="p">():</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">IndexLocation</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_locations</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">loc</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pitch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The pitch of the grid.</span>

<span class="sd">        Assumes 2-d unit-step defined (works for cartesian)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO move this to the CartesianGrid</span>
        <span class="n">pitch</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">pitch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grid </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> does not have a defined pitch.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pitch</span></div>


<div class="viewcode-block" id="CartesianGrid"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CartesianGrid">[docs]</a><span class="k">class</span> <span class="nc">CartesianGrid</span><span class="p">(</span><span class="n">Grid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Grid class representing a conformal Cartesian mesh.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In Cartesian, (i, j, k) indices map to (x, y, z) coordinates.</span>
<span class="sd">    In an axial plane (i, j) are as follows::</span>

<span class="sd">        (-1, 1) ( 0, 1) ( 1, 1)</span>
<span class="sd">        (-1, 0) ( 0, 0) ( 1, 0)</span>
<span class="sd">        (-1,-1) ( 0,-1) ( 1,-1)</span>

<span class="sd">    The concepts of ring and position are a bit tricker in Cartesian grids than in Hex,</span>
<span class="sd">    because unlike in the Hex case, there is no guaranteed center location. For example,</span>
<span class="sd">    when using a CartesianGrid to lay out assemblies in a core, there is only a single</span>
<span class="sd">    central location if the number of assemblies in the core is odd-by-odd; in an</span>
<span class="sd">    even-by-even case, there are four center-most assemblies. Therefore, the number of</span>
<span class="sd">    locations per ring will vary depending on the &quot;through center&quot; nature of</span>
<span class="sd">    ``symmetry``.</span>

<span class="sd">    Furthermore, notice that in the &quot;through center&quot; (odd-by-odd) case, the central</span>
<span class="sd">    index location, (0,0) is typically centered at the origin (0.0, 0.0), whereas with</span>
<span class="sd">    the &quot;not through center&quot; (even-by-even) case, the (0,0) index location is offset,</span>
<span class="sd">    away from the origin.</span>

<span class="sd">    These concepts are illustrated in the example drawings below.</span>

<span class="sd">    .. figure:: ../.static/through-center.png</span>
<span class="sd">        :width: 400px</span>
<span class="sd">        :align: center</span>

<span class="sd">        Grid example where the axes pass through the &quot;center assembly&quot; (odd-by-odd).</span>
<span class="sd">        Note that ring 1 only has one location in it.</span>

<span class="sd">    .. figure:: ../.static/not-through-center.png</span>
<span class="sd">        :width: 400px</span>
<span class="sd">        :align: center</span>

<span class="sd">        Grid example where the axes lie between the &quot;center assemblies&quot; (even-by-even).</span>
<span class="sd">        Note that ring 1 has four locations, and that the center of the (0, 0)-index</span>
<span class="sd">        location is offset from the origin.</span>

<span class="sd">    .. impl:: ARMI supports a Cartesian mesh.</span>
<span class="sd">       :id: IMPL_REACTOR_MESH_1</span>
<span class="sd">       :links: REQ_REACTOR_MESH</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CartesianGrid.fromRectangle"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CartesianGrid.fromRectangle">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromRectangle</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">numRings</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">isOffset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">armiObject</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a finite step-based 2-D Cartesian grid based on a width and height in cm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        width : float</span>
<span class="sd">            Width of the unit rectangle</span>
<span class="sd">        height : float</span>
<span class="sd">            Height of the unit rectangle</span>
<span class="sd">        numRings : int</span>
<span class="sd">            Number of rings that the grid should span</span>
<span class="sd">        symmetry : str</span>
<span class="sd">            The symmetry condition (see :py:mod:`armi.reactor.geometry`)</span>
<span class="sd">        isOffset : bool</span>
<span class="sd">            If True, the origin of the Grid&#39;s coordinate system will be placed at the</span>
<span class="sd">            bottom-left corner of the center-most cell. Otherwise, the origin will be</span>
<span class="sd">            placed at the center of the center-most cell.</span>
<span class="sd">        armiObject : ArmiObject</span>
<span class="sd">            An object in a Composite model that the Grid should be bound to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unitSteps</span> <span class="o">=</span> <span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span> <span class="k">if</span> <span class="n">isOffset</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">unitSteps</span><span class="o">=</span><span class="n">unitSteps</span><span class="p">,</span>
            <span class="n">unitStepLimits</span><span class="o">=</span><span class="p">((</span><span class="o">-</span><span class="n">numRings</span><span class="p">,</span> <span class="n">numRings</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">numRings</span><span class="p">,</span> <span class="n">numRings</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
            <span class="n">armiObject</span><span class="o">=</span><span class="n">armiObject</span><span class="p">,</span>
            <span class="n">symmetry</span><span class="o">=</span><span class="n">symmetry</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CartesianGrid.getRingPos"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CartesianGrid.getRingPos">[docs]</a>    <span class="k">def</span> <span class="nf">getRingPos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ring and position from indices.</span>

<span class="sd">        Ring is the Manhattan distance from (0, 0) to the passed indices. Position</span>
<span class="sd">        counts up around the ring counter-clockwise from the quadrant 1 diagonal, like</span>
<span class="sd">        this::</span>

<span class="sd">            7   6  5  4  3  2  1</span>
<span class="sd">            8         |       24</span>
<span class="sd">            9         |       23</span>
<span class="sd">            10 -------|------ 22</span>
<span class="sd">            11        |       21</span>
<span class="sd">            12        |       20</span>
<span class="sd">            13 14 15 16 17 18 19</span>

<span class="sd">        Grids that split the central locations have 1 location in in inner-most ring,</span>
<span class="sd">        whereas grids without split central locations will have 4.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is needed to support GUI, but should not often be used.</span>
<span class="sd">        i, j (0-based) indices are much more useful. For example:</span>

<span class="sd">        &gt;&gt;&gt; locator = core.spatialGrid[i, j, 0] # 3rd index is 0 for assembly</span>
<span class="sd">        &gt;&gt;&gt; a = core.childrenByLocator[locator]</span>

<span class="sd">        &gt;&gt;&gt; a = core.childrenByLocator[core.spatialGrid[i, j, 0]] # one liner</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isThroughCenter</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">split</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mf">0.5</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mf">0.5</span>

        <span class="n">ring</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">split</span><span class="p">:</span>
            <span class="n">ring</span> <span class="o">+=</span> <span class="mf">0.5</span>

        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">ring</span><span class="p">:</span>
            <span class="c1"># region 1</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="n">i</span> <span class="o">+</span> <span class="n">ring</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="n">ring</span><span class="p">:</span>
            <span class="c1"># region 2</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">ring</span> <span class="o">-</span> <span class="n">j</span>
        <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="n">ring</span><span class="p">:</span>
            <span class="c1"># region 3</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">ring</span> <span class="o">+</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># region 4</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">ring</span> <span class="o">+</span> <span class="n">j</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="CartesianGrid.getIndicesFromRingAndPos"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CartesianGrid.getIndicesFromRingAndPos">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getIndicesFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Not implemented for Cartesian-see getRingPos notes.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Cartesian should not need need ring/pos, use i, j indices.&quot;</span>
            <span class="s2">&quot;See getRingPos doc string notes for more information/example.&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CartesianGrid.getMinimumRings"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CartesianGrid.getMinimumRings">[docs]</a>    <span class="k">def</span> <span class="nf">getMinimumRings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the minimum number of rings needed to fit ``n`` objects.&quot;&quot;&quot;</span>
        <span class="n">numPositions</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ring</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">ringPositions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPositionsInRing</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
            <span class="n">numPositions</span> <span class="o">+=</span> <span class="n">ringPositions</span>
            <span class="k">if</span> <span class="n">numPositions</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">ring</span></div>

<div class="viewcode-block" id="CartesianGrid.getPositionsInRing"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CartesianGrid.getPositionsInRing">[docs]</a>    <span class="k">def</span> <span class="nf">getPositionsInRing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of positions within a ring.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The number of positions within a ring will change</span>
<span class="sd">        depending on whether the central position in the</span>
<span class="sd">        grid is at origin, or if origin is the point</span>
<span class="sd">        where 4 positions meet (i.e., the ``_isThroughCenter``</span>
<span class="sd">        method returns True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ringPositions</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isThroughCenter</span><span class="p">()</span> <span class="k">else</span> <span class="mi">4</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ringPositions</span> <span class="o">=</span> <span class="p">(</span><span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isThroughCenter</span><span class="p">():</span>
                <span class="n">ringPositions</span> <span class="o">+=</span> <span class="mi">4</span>
        <span class="k">return</span> <span class="n">ringPositions</span></div>

<div class="viewcode-block" id="CartesianGrid.locatorInDomain"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CartesianGrid.locatorInDomain">[docs]</a>    <span class="k">def</span> <span class="nf">locatorInDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">,</span> <span class="n">symmetryOverlap</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">QUARTER_CORE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">locator</span><span class="o">.</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">locator</span><span class="o">.</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="CartesianGrid.changePitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CartesianGrid.changePitch">[docs]</a>    <span class="k">def</span> <span class="nf">changePitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xw</span><span class="p">,</span> <span class="n">yw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the pitch of a Cartesian grid.</span>

<span class="sd">        This also scales the offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xwOld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ywOld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(((</span><span class="n">xw</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">yw</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span>
        <span class="p">]</span>
        <span class="n">newOffsetX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">xw</span> <span class="o">/</span> <span class="n">xwOld</span>
        <span class="n">newOffsetY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">yw</span> <span class="o">/</span> <span class="n">ywOld</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">newOffsetX</span><span class="p">,</span> <span class="n">newOffsetY</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span></div>

<div class="viewcode-block" id="CartesianGrid.getSymmetricEquivalents"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.CartesianGrid.getSymmetricEquivalents">[docs]</a>    <span class="k">def</span> <span class="nf">getSymmetricEquivalents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="n">symmetry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span>  <span class="c1"># construct the symmetry object once up top</span>
        <span class="n">isRotational</span> <span class="o">=</span> <span class="n">symmetry</span><span class="o">.</span><span class="n">boundary</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">PERIODIC</span>

        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">FULL_CORE</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">QUARTER_CORE</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">symmetry</span><span class="o">.</span><span class="n">isThroughCenterAssembly</span><span class="p">:</span>
                <span class="c1"># some locations lie on the symmetric boundary</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># on the split corner, so the location is its own symmetric</span>
                    <span class="c1"># equivalent</span>
                    <span class="k">return</span> <span class="p">[]</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">isRotational</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">j</span><span class="p">)]</span>
                <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">isRotational</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">)]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">[(</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Math is a bit easier for the split case, since there is an actual</span>
                    <span class="c1"># center location for (0, 0)</span>
                    <span class="k">if</span> <span class="n">isRotational</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">[(</span><span class="o">-</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">)]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">[(</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">j</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># most objects have 3 equivalents. the bottom-left corner of Quadrant I</span>
                <span class="c1"># is (0, 0), so to reflect, add one and negate each index in</span>
                <span class="c1"># combination. To rotate, first flip the indices for the Quadrant II and</span>
                <span class="c1"># Quadrant IV</span>
                <span class="k">if</span> <span class="n">isRotational</span><span class="p">:</span>
                    <span class="c1"># rotational</span>
                    <span class="c1">#        QII           QIII          QIV</span>
                    <span class="k">return</span> <span class="p">[(</span><span class="o">-</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># reflective</span>
                    <span class="c1">#        QII           QIII          QIV</span>
                    <span class="k">return</span> <span class="p">[(</span><span class="o">-</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">EIGHTH_CORE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Eighth-core symmetry isn&#39;t fully implemented for grids yet!&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Unhandled symmetry condition for </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span>
                <span class="p">)</span>
            <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_isThroughCenter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return whether the central cells are split through the middle for symmetry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="HexGrid"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid">[docs]</a><span class="k">class</span> <span class="nc">HexGrid</span><span class="p">(</span><span class="n">Grid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Has 6 neighbors in plane.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In an axial plane (i, j) are as follows (second one is pointedEndUp)::</span>


<span class="sd">                    ( 0, 1)</span>
<span class="sd">             (-1, 1)       ( 1, 0)</span>
<span class="sd">                    ( 0, 0)</span>
<span class="sd">             (-1, 0)       ( 1,-1)</span>
<span class="sd">                    ( 0,-1)</span>


<span class="sd">                ( 0, 1) ( 1, 0)</span>

<span class="sd">            (-1, 1) ( 0, 0) ( 1,-1)</span>

<span class="sd">                (-1, 0) ( 0,-1)</span>

<span class="sd">    .. impl:: ARMI supports a Hexagonal mesh.</span>
<span class="sd">       :id: IMPL_REACTOR_MESH_2</span>
<span class="sd">       :links: REQ_REACTOR_MESH</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HexGrid.fromPitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.fromPitch">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fromPitch</span><span class="p">(</span><span class="n">pitch</span><span class="p">,</span> <span class="n">numRings</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">armiObject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pointedEndUp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a finite step-based 2-D hex grid from a hex pitch in cm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pitch : float</span>
<span class="sd">            Hex pitch (flat-to-flat) in cm</span>
<span class="sd">        numRings : int, optional</span>
<span class="sd">            The number of rings in the grid to pre-populate with locatator objects.</span>
<span class="sd">            Even if positions are not pre-populated, locators will be generated</span>
<span class="sd">            there on the fly.</span>
<span class="sd">        armiObject : ArmiObject, optional</span>
<span class="sd">            The object that this grid is anchored to (i.e. the reactor for a grid of</span>
<span class="sd">            assemblies)</span>
<span class="sd">        pointedEndUp : bool, optional</span>
<span class="sd">            Rotate the hexagons 30 degrees so that the pointed end faces up instead of</span>
<span class="sd">            the flat.</span>
<span class="sd">        symmetry : string, optional</span>
<span class="sd">            A string representation of the symmetry options for the grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        HexGrid</span>
<span class="sd">            A functional hexagonal grid object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">pitch</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pointedEndUp</span><span class="p">:</span>
            <span class="c1"># rotated 30 degrees CCW from normal</span>
            <span class="c1"># increases in i move you in x and y</span>
            <span class="c1"># increases in j also move you in x and y</span>
            <span class="n">unitSteps</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">pitch</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="n">pitch</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">side</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">side</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># x direction is only a function of i because j-axis is vertical.</span>
            <span class="c1"># y direction is a function of both.</span>
            <span class="n">unitSteps</span> <span class="o">=</span> <span class="p">((</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">side</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="n">pitch</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">HexGrid</span><span class="p">(</span>
            <span class="n">unitSteps</span><span class="o">=</span><span class="n">unitSteps</span><span class="p">,</span>
            <span class="n">unitStepLimits</span><span class="o">=</span><span class="p">((</span><span class="o">-</span><span class="n">numRings</span><span class="p">,</span> <span class="n">numRings</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">numRings</span><span class="p">,</span> <span class="n">numRings</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="n">armiObject</span><span class="o">=</span><span class="n">armiObject</span><span class="p">,</span>
            <span class="n">symmetry</span><span class="o">=</span><span class="n">symmetry</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pitch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the hex-pitch of a regular hexagonal array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.grids.HexGrid.fromPitch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="HexGrid.indicesToRingPos"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.indicesToRingPos">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">indicesToRingPos</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert spatialLocator indices to ring/position.</span>

<span class="sd">        One benefit it has is that it never has negative numbers.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Ring, pos index system goes in counterclockwise hex rings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">i</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">i</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="o">-</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="o">-</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">j</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">i</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="o">-</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span>

        <span class="n">positionBase</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">edge</span> <span class="o">*</span> <span class="p">(</span><span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ring</span><span class="p">,</span> <span class="n">positionBase</span> <span class="o">+</span> <span class="n">offset</span></div>

<div class="viewcode-block" id="HexGrid.getMinimumRings"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.getMinimumRings">[docs]</a>    <span class="k">def</span> <span class="nf">getMinimumRings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum number of rings needed to fit ``n`` objects.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        ``self`` is not used because hex grids always behave the same w.r.t.</span>
<span class="sd">        rings/positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numRingsToHoldNumCells</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexGrid.getPositionsInRing"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.getPositionsInRing">[docs]</a>    <span class="k">def</span> <span class="nf">getPositionsInRing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of positions within a ring.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numPositionsInRing</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexGrid.getNeighboringCellIndices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.getNeighboringCellIndices">[docs]</a>    <span class="k">def</span> <span class="nf">getNeighboringCellIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indices of the immediate neighbors of a mesh point in the plane.</span>

<span class="sd">        Note that these neighbors are ordered counter-clockwise beginning from the</span>
<span class="sd">        30 or 60 degree direction. Exact direction is dependent on pointedEndUp arg.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span>
            <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span>
            <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span>
            <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="HexGrid.getLabel"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.getLabel">[docs]</a>    <span class="k">def</span> <span class="nf">getLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hex labels start at 1, and are ring/position based rather than i,j.</span>

<span class="sd">        This difference is partially because ring/pos is easier to understand in hex</span>
<span class="sd">        geometry, and partially because it is used in some codes ARMI originally was focused</span>
<span class="sd">        on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ring</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Grid</span><span class="o">.</span><span class="n">getLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Grid</span><span class="o">.</span><span class="n">getLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_indicesAndEdgeFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="n">ring</span> <span class="o">=</span> <span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">position</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">ring</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Position in center ring must be 1, not </span><span class="si">{</span><span class="n">position</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="c1"># Edge indicates which edge of the ring in which the hexagon resides.</span>
        <span class="c1"># Edge 0 is the NE edge, edge 1 is the N edge, etc.</span>
        <span class="c1"># Offset is (0-based) index of the hexagon in that edge. For instance,</span>
        <span class="c1"># ring 3, pos 12 resides in edge 5 at index 1; it is the second hexagon</span>
        <span class="c1"># in ring 3, edge 5.</span>
        <span class="n">edge</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span>  <span class="c1"># = pos//ring, pos%ring</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">ring</span> <span class="o">-</span> <span class="n">offset</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="k">elif</span> <span class="n">edge</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">ring</span>
        <span class="k">elif</span> <span class="n">edge</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="n">ring</span>
            <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span> <span class="o">+</span> <span class="n">ring</span>
        <span class="k">elif</span> <span class="n">edge</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="n">ring</span> <span class="o">+</span> <span class="n">offset</span>
            <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span>
        <span class="k">elif</span> <span class="n">edge</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">offset</span>
            <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="n">ring</span>
        <span class="k">elif</span> <span class="n">edge</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">ring</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">ring</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Edge </span><span class="si">{}</span><span class="s2"> is invalid. From ring </span><span class="si">{}</span><span class="s2">, pos </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">edge</span>

<div class="viewcode-block" id="HexGrid.getIndicesFromRingAndPos"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.getIndicesFromRingAndPos">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getIndicesFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">_edge</span> <span class="o">=</span> <span class="n">HexGrid</span><span class="o">.</span><span class="n">_indicesAndEdgeFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span></div>

<div class="viewcode-block" id="HexGrid.getRingPos"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.getRingPos">[docs]</a>    <span class="k">def</span> <span class="nf">getRingPos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get 1-based ring and position from normal indices.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        getIndicesFromRingAndPos : does the reverse</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">HexGrid</span><span class="o">.</span><span class="n">indicesToRingPos</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexGrid.overlapsWhichSymmetryLine"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.overlapsWhichSymmetryLine">[docs]</a>    <span class="k">def</span> <span class="nf">overlapsWhichSymmetryLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of which lines of symmetry this is on.</span>

<span class="sd">        If none, returns []</span>
<span class="sd">        If on a line of symmetry in 1/6 geometry, returns a list containing a 6.</span>
<span class="sd">        If on a line of symmetry in 1/3 geometry, returns a list containing a 3.</span>
<span class="sd">        Only the 1/3 core view geometry is actually coded in here right now.</span>

<span class="sd">        Being &quot;on&quot; a symmetry line means the line goes through the middle of you.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">symmetryLine</span> <span class="o">=</span> <span class="n">BOUNDARY_CENTER</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">:</span>
            <span class="c1"># edge 1: 1/3 symmetry line (bottom horizontal side in 1/3 core view, theta = 0)</span>
            <span class="n">symmetryLine</span> <span class="o">=</span> <span class="n">BOUNDARY_0_DEGREES</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># edge 2: 1/6 symmetry line (bisects 1/3 core view, theta = pi/3)</span>
            <span class="n">symmetryLine</span> <span class="o">=</span> <span class="n">BOUNDARY_60_DEGREES</span>
        <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># edge 3: 1/3 symmetry line (left oblique side in 1/3 core view, theta = 2*pi/3)</span>
            <span class="n">symmetryLine</span> <span class="o">=</span> <span class="n">BOUNDARY_120_DEGREES</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">symmetryLine</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">symmetryLine</span></div>

<div class="viewcode-block" id="HexGrid.getSymmetricEquivalents"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.getSymmetricEquivalents">[docs]</a>    <span class="k">def</span> <span class="nf">getSymmetricEquivalents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">THIRD_CORE</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">boundary</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">BoundaryType</span><span class="o">.</span><span class="n">PERIODIC</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">HexGrid</span><span class="o">.</span><span class="n">_getSymmetricIdenticalsThird</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">FULL_CORE</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Unhandled symmetry condition for HexGrid: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_getSymmetricIdenticalsThird</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This works by rotating the indices by 120 degrees twice, counterclockwise.&quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">identicals</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">identicals</span>

<div class="viewcode-block" id="HexGrid.triangleCoords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.triangleCoords">[docs]</a>    <span class="k">def</span> <span class="nf">triangleCoords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return 6 coordinate pairs representing the centers of the 6 triangles in a hexagon centered here.</span>

<span class="sd">        Ignores z-coordinate and only operates in 2D for now.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCoordinates</span><span class="p">(</span><span class="n">indices</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pitch</span> <span class="o">/</span> <span class="mf">3.0</span>
        <span class="k">return</span> <span class="n">xy</span> <span class="o">+</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">TRIANGLES_IN_HEXAGON</span></div>

<div class="viewcode-block" id="HexGrid.changePitch"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.changePitch">[docs]</a>    <span class="k">def</span> <span class="nf">changePitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newPitchCm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change the hex pitch.&quot;&quot;&quot;</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">newPitchCm</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unitSteps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">((</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">side</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="n">newPitchCm</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">newPitchCm</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_stepDims</span><span class="p">]</span></div>

<div class="viewcode-block" id="HexGrid.locatorInDomain"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.locatorInDomain">[docs]</a>    <span class="k">def</span> <span class="nf">locatorInDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">,</span> <span class="n">symmetryOverlap</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="c1"># This will include the &quot;top&quot; 120-degree symmetry lines. This is to support</span>
        <span class="c1"># adding of edge assemblies.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">geometry</span><span class="o">.</span><span class="n">DomainType</span><span class="o">.</span><span class="n">THIRD_CORE</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isInFirstThird</span><span class="p">(</span><span class="n">locator</span><span class="p">,</span> <span class="n">includeTopEdge</span><span class="o">=</span><span class="n">symmetryOverlap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="HexGrid.isInFirstThird"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.isInFirstThird">[docs]</a>    <span class="k">def</span> <span class="nf">isInFirstThird</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">,</span> <span class="n">includeTopEdge</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if locator is in first third of hex grid.&quot;&quot;&quot;</span>
        <span class="n">ring</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">(</span><span class="n">locator</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">maxPosTotal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPositionsInRing</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>

        <span class="n">maxPos1</span> <span class="o">=</span> <span class="n">ring</span> <span class="o">+</span> <span class="n">ring</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">maxPos2</span> <span class="o">=</span> <span class="n">maxPosTotal</span> <span class="o">-</span> <span class="n">ring</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># odd ring. Upper edge assem typically not included.</span>
            <span class="k">if</span> <span class="n">includeTopEdge</span><span class="p">:</span>
                <span class="n">maxPos1</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">maxPos2</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># make a table to understand this.</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">maxPos1</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">maxPos2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="HexGrid.generateSortedHexLocationList"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.generateSortedHexLocationList">[docs]</a>    <span class="k">def</span> <span class="nf">generateSortedHexLocationList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nLocs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a list IndexLocations, sorted based on their distance from the center.</span>

<span class="sd">        IndexLocation are taken from a full core.</span>

<span class="sd">        Ties between locations with the same distance (e.g. A3001 and A3003) are broken</span>
<span class="sd">        by ring number then position number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first, roughly calculate how many rings need to be created to cover nLocs worth of assemblies</span>
        <span class="n">nLocs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nLocs</span><span class="p">)</span>  <span class="c1"># need to make this an integer</span>

        <span class="c1"># next, generate a list of locations and corresponding distances</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numRingsToHoldNumCells</span><span class="p">(</span><span class="n">nLocs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPositionsInRing</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">positions</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getIndicesFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                <span class="n">locs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
        <span class="c1"># round to avoid differences due to floating point math</span>
        <span class="n">locs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">loc</span><span class="p">:</span> <span class="p">(</span>
                <span class="nb">round</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()),</span> <span class="mi">6</span><span class="p">),</span>
                <span class="n">loc</span><span class="o">.</span><span class="n">i</span><span class="p">,</span>  <span class="c1"># loc.i=ring</span>
                <span class="n">loc</span><span class="o">.</span><span class="n">j</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># loc.j= pos</span>
        <span class="k">return</span> <span class="n">locs</span><span class="p">[:</span><span class="n">nLocs</span><span class="p">]</span></div>

    <span class="c1"># TODO: this is only used by testing and another method that just needs the count of assemblies</span>
    <span class="c1">#       in a ring, not the actual positions</span>
<div class="viewcode-block" id="HexGrid.allPositionsInThird"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.HexGrid.allPositionsInThird">[docs]</a>    <span class="k">def</span> <span class="nf">allPositionsInThird</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">includeEdgeAssems</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of all the positions in a ring (in the first third)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ring : int</span>
<span class="sd">            The ring to check</span>
<span class="sd">        includeEdgeAssems : bool, optional</span>
<span class="sd">            If True, include repeated positions in odd ring numbers. Default: False</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Rings start at 1, positions start at 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        positions : int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPositionsInRing</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getIndicesFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">IndexLocation</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isInFirstThird</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">includeEdgeAssems</span><span class="p">):</span>
                <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">positions</span></div></div>


<div class="viewcode-block" id="ThetaRZGrid"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.ThetaRZGrid">[docs]</a><span class="k">class</span> <span class="nc">ThetaRZGrid</span><span class="p">(</span><span class="n">Grid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A grid characterized by azimuthal, radial, and zeta indices.</span>

<span class="sd">    The angular meshes are limited to 0 to 2pi radians. R and Zeta are as in other</span>
<span class="sd">    meshes.</span>

<span class="sd">    See Figure 2.2 in Derstine 1984, ANL. [DIF3D]_.</span>

<span class="sd">    .. impl:: ARMI supports an RZTheta mesh.</span>
<span class="sd">       :id: IMPL_REACTOR_MESH_3</span>
<span class="sd">       :links: REQ_REACTOR_MESH</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ThetaRZGrid.fromGeom"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.ThetaRZGrid.fromGeom">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fromGeom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">armiObject</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build 2-D R-theta grid based on a Geometry object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geomInfo : list</span>
<span class="sd">            list of ((indices), assemName) tuples for all positions in core with input</span>
<span class="sd">            in radians</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.systemLayoutInput.SystemLayoutInput.readGeomXML : produces the geomInfo</span>
<span class="sd">        structure</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; grid = grids.ThetaRZGrid.fromGeom(geomInfo)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">allIndices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">indices</span> <span class="k">for</span> <span class="n">indices</span><span class="p">,</span> <span class="n">_assemName</span> <span class="ow">in</span> <span class="n">geom</span><span class="o">.</span><span class="n">assemTypeByIndices</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="c1"># create ordered lists of all unique theta and R points</span>
        <span class="n">thetas</span><span class="p">,</span> <span class="n">radii</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">rad1</span><span class="p">,</span> <span class="n">rad2</span><span class="p">,</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">,</span> <span class="n">_numAzi</span><span class="p">,</span> <span class="n">_numRadial</span> <span class="ow">in</span> <span class="n">allIndices</span><span class="p">:</span>
            <span class="n">radii</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rad1</span><span class="p">)</span>
            <span class="n">radii</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rad2</span><span class="p">)</span>
            <span class="n">thetas</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span>
            <span class="n">thetas</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span>
        <span class="n">radii</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">radii</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">thetaRadians</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">thetas</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ThetaRZGrid</span><span class="p">(</span>
            <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">thetaRadians</span><span class="p">,</span> <span class="n">radii</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)),</span> <span class="n">armiObject</span><span class="o">=</span><span class="n">armiObject</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ThetaRZGrid.getRingPos"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.ThetaRZGrid.getRingPos">[docs]</a>    <span class="k">def</span> <span class="nf">getRingPos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="ThetaRZGrid.getIndicesFromRingAndPos"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.ThetaRZGrid.getIndicesFromRingAndPos">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getIndicesFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="ThetaRZGrid.getCoordinates"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.ThetaRZGrid.getCoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">getCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">nativeCoords</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">meshCoords</span> <span class="o">=</span> <span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">getCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">theta</span> <span class="o">&lt;=</span> <span class="n">TAU</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid theta value: </span><span class="si">{}</span><span class="s2">. Check mesh.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">nativeCoords</span><span class="p">:</span>
            <span class="c1"># return Theta, R, Z values directly.</span>
            <span class="k">return</span> <span class="n">meshCoords</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># return x, y ,z</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">r</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">r</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">z</span><span class="p">))</span></div>

<div class="viewcode-block" id="ThetaRZGrid.indicesOfBounds"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.ThetaRZGrid.indicesOfBounds">[docs]</a>    <span class="k">def</span> <span class="nf">indicesOfBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rad0</span><span class="p">,</span> <span class="n">rad1</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return indices corresponding to upper and lower radial and theta bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rad0 : float</span>
<span class="sd">            inner radius of control volume</span>
<span class="sd">        rad1 : float</span>
<span class="sd">            outer radius of control volume</span>
<span class="sd">        theta0 : float</span>
<span class="sd">            inner azimuthal location of control volume in radians</span>
<span class="sd">        theta1 : float</span>
<span class="sd">            inner azimuthal of control volume in radians</span>
<span class="sd">        sigma: float</span>
<span class="sd">            acceptable relative error (i.e. if one of the positions in the mesh are within</span>
<span class="sd">            this error it&#39;ll act the same if it matches a position in the mesh)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple : i, j, k of given bounds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">theta0</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">())</span>
        <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rad0</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">())</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="ThetaRZGrid.locatorInDomain"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.ThetaRZGrid.locatorInDomain">[docs]</a>    <span class="k">def</span> <span class="nf">locatorInDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">,</span> <span class="n">symmetryOverlap</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ThetaRZGrids do not check for bounds, though they could if that becomes a</span>
<span class="sd">        problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span></div></div>


<div class="viewcode-block" id="axialUnitGrid"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.axialUnitGrid">[docs]</a><span class="k">def</span> <span class="nf">axialUnitGrid</span><span class="p">(</span><span class="n">numCells</span><span class="p">,</span> <span class="n">armiObject</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a 1-D unit grid in the k-direction based on a number of times. Each mesh is 1cm wide.</span>

<span class="sd">    numCells + 1 mesh boundaries are added, since one block would require a bottom and a</span>
<span class="sd">    top.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># need float bounds or else we truncate integers</span>
    <span class="k">return</span> <span class="n">Grid</span><span class="p">(</span>
        <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numCells</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)),</span>
        <span class="n">armiObject</span><span class="o">=</span><span class="n">armiObject</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="locatorLabelToIndices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.locatorLabelToIndices">[docs]</a><span class="k">def</span> <span class="nf">locatorLabelToIndices</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a locator label to numerical i,j,k indices.</span>

<span class="sd">    If there are only i,j  indices, make the last item None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intVals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intVals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">intVals</span> <span class="o">=</span> <span class="p">(</span><span class="n">intVals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intVals</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">intVals</span></div>


<div class="viewcode-block" id="addingIsValid"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.grids.html#armi.reactor.grids.addingIsValid">[docs]</a><span class="k">def</span> <span class="nf">addingIsValid</span><span class="p">(</span><span class="n">myGrid</span><span class="p">,</span> <span class="n">parentGrid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    True if adding a indices from one grid to another is considered valid.</span>

<span class="sd">    In ARMI we allow the addition of a 1-D axial grid with a 2-D grid.</span>
<span class="sd">    We do not allow any other kind of adding. This enables the 2D/1D</span>
<span class="sd">    grid layout in Assemblies/Blocks but does not allow 2D indexing</span>
<span class="sd">    in pins to become inconsistent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">myGrid</span><span class="o">.</span><span class="n">isAxialOnly</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">parentGrid</span><span class="o">.</span><span class="n">isAxialOnly</span></div>


<span class="k">def</span> <span class="nf">_tuplify</span><span class="p">(</span><span class="n">maybeArray</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maybeArray</span><span class="p">,</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">maybeArray</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="k">else</span> <span class="n">row</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">maybeArray</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">maybeArray</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2009-2023, TerraPower, LLC.
      <span class="lastupdated">
        Last updated on 2023-02-08.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
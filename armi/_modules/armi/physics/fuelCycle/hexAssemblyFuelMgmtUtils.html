

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>armi.physics.fuelCycle.hexAssemblyFuelMgmtUtils &mdash; ARMI 0.2.5 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/theme_fixes.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/armiicon_16x16.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="../../../../_static/assets/jsonview.bundle.js"></script>
        <script src="../../../../_static/assets/jsonview_loader.js"></script>
        <script src="../../../../_static/sphinx-needs/libs/html/datatables.min.js"></script>
        <script src="../../../../_static/sphinx-needs/libs/html/datatables_loader.js"></script>
        <script src="../../../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> ARMI
          

          
            
            <img src="../../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../requirements/index.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../.apidocs/modules.html">API Docs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ARMI</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../armi.html">armi</a> &raquo;</li>
        
          <li><a href="../fuelCycle.html">armi.physics.fuelCycle</a> &raquo;</li>
        
      <li>armi.physics.fuelCycle.hexAssemblyFuelMgmtUtils</li>
    
    
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for armi.physics.fuelCycle.hexAssemblyFuelMgmtUtils</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2022 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is a selection of fuel management utilities that seem generally useful enough to</span>
<span class="sd">keep in ARMI, but they still only apply to hex assembly reactors.</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">We are keeping these in ARMI even if they appear unused internally.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">runLog</span>
<span class="kn">from</span> <span class="nn">armi.reactor.flags</span> <span class="kn">import</span> <span class="n">Flags</span>
<span class="kn">from</span> <span class="nn">armi.utils.mathematics</span> <span class="kn">import</span> <span class="n">findClosest</span>


<div class="viewcode-block" id="getOptimalAssemblyOrientation"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.hexAssemblyFuelMgmtUtils.html#armi.physics.fuelCycle.hexAssemblyFuelMgmtUtils.getOptimalAssemblyOrientation">[docs]</a><span class="k">def</span> <span class="nf">getOptimalAssemblyOrientation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">aPrev</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get optimal assembly orientation/rotation to minimize peak burnup.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Works by placing the highest-BU pin in the location (of 6 possible locations) with lowest</span>
<span class="sd">    expected pin power. We evaluated &quot;expected pin power&quot; based on the power distribution in</span>
<span class="sd">    aPrev, which is the previous assembly located here. If aPrev has no pin detail, then we must use its</span>
<span class="sd">    corner fast fluxes to make an estimate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : Assembly object</span>
<span class="sd">        The assembly that is being rotated.</span>

<span class="sd">    aPrev : Assembly object</span>
<span class="sd">        The assembly that previously occupied this location (before the last shuffle).</span>

<span class="sd">        If the assembly &quot;a&quot; was not shuffled, then &quot;aPrev&quot; = &quot;a&quot;.</span>

<span class="sd">        If &quot;aPrev&quot; has pin detail, then we will determine the orientation of &quot;a&quot; based on</span>
<span class="sd">        the pin powers of &quot;aPrev&quot; when it was located here.</span>

<span class="sd">        If &quot;aPrev&quot; does NOT have pin detail, then we will determine the orientation of &quot;a&quot; based on</span>
<span class="sd">        the corner fast fluxes in &quot;aPrev&quot; when it was located here.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rot : int</span>
<span class="sd">        An integer from 0 to 5 representing the &quot;orientation&quot; of the assembly.</span>
<span class="sd">        This orientation is relative to the current assembly orientation.</span>
<span class="sd">        rot = 0 corresponds to no rotation.</span>
<span class="sd">        rot represents the number of pi/3 counterclockwise rotations for the default orientation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; getOptimalAssemblyOrientation(a, aPrev)</span>
<span class="sd">    4</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    rotateAssemblies : calls this to figure out how to rotate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># determine whether or not aPrev had pin details</span>
    <span class="n">fuelPrev</span> <span class="o">=</span> <span class="n">aPrev</span><span class="o">.</span><span class="n">getFirstBlock</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fuelPrev</span><span class="p">:</span>
        <span class="n">aPrevDetailFlag</span> <span class="o">=</span> <span class="n">fuelPrev</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinLocation</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">aPrevDetailFlag</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">rot</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># default: no rotation</span>
    <span class="c1"># First get pin index of maximum BU in this assembly.</span>
    <span class="n">_maxBuAssem</span><span class="p">,</span> <span class="n">maxBuBlock</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">getMaxParam</span><span class="p">(</span><span class="s2">&quot;percentBuMax&quot;</span><span class="p">,</span> <span class="n">returnObj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">maxBuBlock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># no max block. They&#39;re all probably zero</span>
        <span class="k">return</span> <span class="n">rot</span>

    <span class="c1"># start at 0 instead of 1</span>
    <span class="n">maxBuPinIndexAssem</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxBuBlock</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBuMaxPinLocation</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bIndexMaxBu</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">maxBuBlock</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">maxBuPinIndexAssem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Don&#39;t bother rotating if the highest-BU pin is the central pin. End this method.</span>
        <span class="k">return</span> <span class="n">rot</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># transfer percentBuMax rotated pin index to non-rotated pin index</span>
        <span class="k">if</span> <span class="n">aPrevDetailFlag</span><span class="p">:</span>
            <span class="c1"># aPrev has pin detail</span>
            <span class="c1"># Determine which of 6 possible rotated pin indices had the lowest power when aPrev was here.</span>
            <span class="n">prevAssemPowHereMIN</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">possibleRotation</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                <span class="c1"># get rotated pin index</span>
                <span class="n">indexLookup</span> <span class="o">=</span> <span class="n">maxBuBlock</span><span class="o">.</span><span class="n">rotatePins</span><span class="p">(</span><span class="n">possibleRotation</span><span class="p">,</span> <span class="n">justCompute</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># rotated index of highest-BU pin</span>
                <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">indexLookup</span><span class="p">[</span><span class="n">maxBuPinIndexAssem</span><span class="p">])</span>
                <span class="c1"># get pin power at this index in the previously assembly located here</span>
                <span class="c1"># power previously at rotated index</span>
                <span class="n">prevAssemPowHere</span> <span class="o">=</span> <span class="n">aPrev</span><span class="p">[</span><span class="n">bIndexMaxBu</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">linPowByPin</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">prevAssemPowHere</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;Previous power in rotation </span><span class="si">{0}</span><span class="s2"> where pinLoc=</span><span class="si">{1}</span><span class="s2"> is </span><span class="si">{2:.4E}</span><span class="s2"> W/cm&quot;</span>
                        <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">possibleRotation</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">prevAssemPowHere</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">prevAssemPowHere</span> <span class="o">&lt;</span> <span class="n">prevAssemPowHereMIN</span><span class="p">:</span>
                        <span class="n">prevAssemPowHereMIN</span> <span class="o">=</span> <span class="n">prevAssemPowHere</span>
                        <span class="n">rot</span> <span class="o">=</span> <span class="n">possibleRotation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot perform detailed rotation analysis without pin-level &quot;</span>
                <span class="s2">&quot;flux information.&quot;</span>
            <span class="p">)</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Best relative rotation is </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rot</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rot</span></div>


<div class="viewcode-block" id="buildRingSchedule"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.hexAssemblyFuelMgmtUtils.html#armi.physics.fuelCycle.hexAssemblyFuelMgmtUtils.buildRingSchedule">[docs]</a><span class="k">def</span> <span class="nf">buildRingSchedule</span><span class="p">(</span>
    <span class="n">maxRingInCore</span><span class="p">,</span>
    <span class="n">chargeRing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dischargeRing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">jumpRingFrom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">jumpRingTo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">coarseFactor</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a ring schedule for shuffling.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    General enough to do convergent, divergent, or any combo, plus jumprings.</span>

<span class="sd">    The center of the core is ring 1, based on the DIF3D numbering scheme.</span>

<span class="sd">    Jump ring behavior can be generalized by first building a base ring list</span>
<span class="sd">    where assemblies get charged to H and discharge from A::</span>

<span class="sd">        [A,B,C,D,E,F,G,H]</span>

<span class="sd">    If a jump should be placed where it jumps from ring G to C, reversed back to F, and then discharges from A,</span>
<span class="sd">    we simply reverse the sublist [C,D,E,F], leaving us with::</span>

<span class="sd">        [A,B,F,E,D,C,G,H]</span>

<span class="sd">    A less-complex, more standard convergent-divergent scheme is a subcase of this, where the</span>
<span class="sd">    sublist [A,B,C,D,E] or so is reversed, leaving::</span>

<span class="sd">        [E,D,C,B,A,F,G,H]</span>

<span class="sd">    So the task of this function is simply to determine what subsection, if any, to reverse of</span>
<span class="sd">    the baselist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    maxRingInCore : int</span>
<span class="sd">        The number of rings in the hex assembly reactor.</span>

<span class="sd">    chargeRing : int, optional</span>
<span class="sd">        The peripheral ring into which an assembly enters the core. Default is outermost ring.</span>

<span class="sd">    dischargeRing : int, optional</span>
<span class="sd">        The last ring an assembly sits in before discharging. Default is jumpRing-1</span>

<span class="sd">    jumpRingFrom : int</span>
<span class="sd">        The last ring an assembly sits in before jumping to the center</span>

<span class="sd">    jumpRingTo : int, optional</span>
<span class="sd">        The inner ring into which a jumping assembly jumps. Default is 1.</span>

<span class="sd">    coarseFactor : float, optional</span>
<span class="sd">        A number between 0 and 1 where 0 hits all rings and 1 only hits the outer, rJ, center, and rD rings.</span>
<span class="sd">        This allows coarse shuffling, with large jumps. Default: 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ringSchedule : list</span>
<span class="sd">        A list of rings in order from discharge to charge.</span>

<span class="sd">    ringWidths : list</span>
<span class="sd">        A list of integers corresponding to the ringSchedule determining the widths of each ring area</span>

<span class="sd">    Examples</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; f.buildRingSchedule(17,1,jumpRingFrom=14)</span>
<span class="sd">    ([13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 14, 15, 16, 17],</span>
<span class="sd">    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dischargeRing</span> <span class="o">&gt;</span> <span class="n">maxRingInCore</span><span class="p">:</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Discharge ring </span><span class="si">{</span><span class="n">dischargeRing</span><span class="si">}</span><span class="s2"> is outside the core (max </span><span class="si">{</span><span class="n">maxRingInCore</span><span class="si">}</span><span class="s2">). &quot;</span>
            <span class="s2">&quot;Changing it to be the max ring&quot;</span>
        <span class="p">)</span>
        <span class="n">dischargeRing</span> <span class="o">=</span> <span class="n">maxRingInCore</span>
    <span class="k">if</span> <span class="n">chargeRing</span> <span class="o">&gt;</span> <span class="n">maxRingInCore</span><span class="p">:</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Charge ring </span><span class="si">{</span><span class="n">chargeRing</span><span class="si">}</span><span class="s2"> is outside the core (max </span><span class="si">{</span><span class="n">maxRingInCore</span><span class="si">}</span><span class="s2">). &quot;</span>
            <span class="s2">&quot;Changing it to be the max ring.&quot;</span>
        <span class="p">)</span>
        <span class="n">chargeRing</span> <span class="o">=</span> <span class="n">maxRingInCore</span>

    <span class="c1"># process arguments</span>
    <span class="k">if</span> <span class="n">dischargeRing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># No discharge ring given, so we default to converging from outside to inside</span>
        <span class="c1"># and therefore discharging from the center</span>
        <span class="n">dischargeRing</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">chargeRing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Charge ring not specified. Since we default to convergent shuffling, we</span>
        <span class="c1"># must insert the fuel at the periphery.</span>
        <span class="n">chargeRing</span> <span class="o">=</span> <span class="n">maxRingInCore</span>
    <span class="k">if</span> <span class="n">jumpRingFrom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">jumpRingFrom</span> <span class="o">&lt;</span> <span class="n">maxRingInCore</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;JumpRingFrom </span><span class="si">{</span><span class="n">jumpRingFrom</span><span class="si">}</span><span class="s2"> is not in the core.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">jumpRingTo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">jumpRingTo</span> <span class="o">&lt;</span> <span class="n">maxRingInCore</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;JumpRingTo </span><span class="si">{</span><span class="n">jumpRingTo</span><span class="si">}</span><span class="s2"> is not in the core.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">chargeRing</span> <span class="o">&gt;</span> <span class="n">dischargeRing</span> <span class="ow">and</span> <span class="n">jumpRingTo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># a convergent shuffle with no jumping. By setting</span>
        <span class="c1"># jumpRingTo to be 1, no jumping will be activated</span>
        <span class="c1"># in the later logic.</span>
        <span class="n">jumpRingTo</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">jumpRingTo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># divergent case. Disable jumpring by putting jumpring at periphery.</span>
        <span class="n">jumpRingTo</span> <span class="o">=</span> <span class="n">maxRingInCore</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">chargeRing</span> <span class="o">&gt;</span> <span class="n">dischargeRing</span>
        <span class="ow">and</span> <span class="n">jumpRingFrom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">jumpRingFrom</span> <span class="o">&lt;</span> <span class="n">jumpRingTo</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot have outward jumps in convergent cases.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">chargeRing</span> <span class="o">&lt;</span> <span class="n">dischargeRing</span>
        <span class="ow">and</span> <span class="n">jumpRingFrom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">jumpRingFrom</span> <span class="o">&gt;</span> <span class="n">jumpRingTo</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot have inward jumps in divergent cases.&quot;</span><span class="p">)</span>

    <span class="c1"># step 1: build the base rings</span>
    <span class="n">numSteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">dischargeRing</span> <span class="o">-</span> <span class="n">chargeRing</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">coarseFactor</span><span class="p">))</span>
    <span class="c1"># don&#39;t let it be smaller than 2 because linspace(1,5,1)= [1], linspace(1,5,2)= [1,5]</span>
    <span class="n">numSteps</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">numSteps</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">baseRings</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">dischargeRing</span><span class="p">,</span> <span class="n">chargeRing</span><span class="p">,</span> <span class="n">numSteps</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="c1"># eliminate duplicates.</span>
    <span class="n">newBaseRings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">br</span> <span class="ow">in</span> <span class="n">baseRings</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">br</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">newBaseRings</span><span class="p">:</span>
            <span class="n">newBaseRings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">br</span><span class="p">)</span>

    <span class="n">baseRings</span> <span class="o">=</span> <span class="n">newBaseRings</span>

    <span class="c1"># build widths</span>
    <span class="n">widths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ring</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">baseRings</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="c1"># 0 is the most restrictive, meaning don&#39;t even look in other rings.</span>
        <span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">baseRings</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ring</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># add the last ring with width 0.</span>

    <span class="c1"># step 2: locate which rings should be reversed to give the jump-ring effect.</span>
    <span class="k">if</span> <span class="n">jumpRingFrom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_closestRingFrom</span><span class="p">,</span> <span class="n">jumpRingFromIndex</span> <span class="o">=</span> <span class="n">findClosest</span><span class="p">(</span>
            <span class="n">baseRings</span><span class="p">,</span> <span class="n">jumpRingFrom</span><span class="p">,</span> <span class="n">indx</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">_closestRingTo</span><span class="p">,</span> <span class="n">jumpRingToIndex</span> <span class="o">=</span> <span class="n">findClosest</span><span class="p">(</span><span class="n">baseRings</span><span class="p">,</span> <span class="n">jumpRingTo</span><span class="p">,</span> <span class="n">indx</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">jumpRingToIndex</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># step 3: build the final ring list, potentially with a reversed section</span>
    <span class="n">newBaseRings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">newWidths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># add in the non-reversed section before the reversed section</span>

    <span class="k">if</span> <span class="n">jumpRingFrom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">newBaseRings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">baseRings</span><span class="p">[:</span><span class="n">jumpRingToIndex</span><span class="p">])</span>
        <span class="n">newWidths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">widths</span><span class="p">[:</span><span class="n">jumpRingToIndex</span><span class="p">])</span>
        <span class="c1"># add in reversed section that is jumped</span>
        <span class="n">newBaseRings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">baseRings</span><span class="p">[</span><span class="n">jumpRingToIndex</span><span class="p">:</span><span class="n">jumpRingFromIndex</span><span class="p">]))</span>
        <span class="n">newWidths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">jumpRingToIndex</span><span class="p">:</span><span class="n">jumpRingFromIndex</span><span class="p">]))</span>
        <span class="c1"># add the rest.</span>
        <span class="n">newBaseRings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">baseRings</span><span class="p">[</span><span class="n">jumpRingFromIndex</span><span class="p">:])</span>
        <span class="n">newWidths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">jumpRingFromIndex</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># no jump section. Just fill in the rest.</span>
        <span class="n">newBaseRings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">baseRings</span><span class="p">[</span><span class="n">jumpRingToIndex</span><span class="p">:])</span>
        <span class="n">newWidths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">jumpRingToIndex</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">newBaseRings</span><span class="p">,</span> <span class="n">newWidths</span></div>


<div class="viewcode-block" id="buildConvergentRingSchedule"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.hexAssemblyFuelMgmtUtils.html#armi.physics.fuelCycle.hexAssemblyFuelMgmtUtils.buildConvergentRingSchedule">[docs]</a><span class="k">def</span> <span class="nf">buildConvergentRingSchedule</span><span class="p">(</span><span class="n">chargeRing</span><span class="p">,</span> <span class="n">dischargeRing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">coarseFactor</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a ring schedule for convergent shuffling from chargeRing to dischargeRing</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chargeRing : int</span>
<span class="sd">        The peripheral ring into which an assembly enters the core. A good default is</span>
<span class="sd">        outermost ring: ``r.core.getNumRings()``.</span>

<span class="sd">    dischargeRing : int, optional</span>
<span class="sd">        The last ring an assembly sits in before discharging. If no discharge, this is the one that</span>
<span class="sd">        gets placed where the charge happens. Default: Innermost ring</span>

<span class="sd">    coarseFactor : float, optional</span>
<span class="sd">        A number between 0 and 1 where 0 hits all rings and 1 only hits the outer, rJ, center, and rD rings.</span>
<span class="sd">        This allows coarse shuffling, with large jumps. Default: 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    convergent : list</span>
<span class="sd">        A list of rings in order from discharge to charge.</span>

<span class="sd">    conWidths : list</span>
<span class="sd">        A list of integers corresponding to the ringSchedule determining the widths of each ring area</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># step 1: build the convergent rings</span>
    <span class="n">numSteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">chargeRing</span> <span class="o">-</span> <span class="n">dischargeRing</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">coarseFactor</span><span class="p">))</span>
    <span class="c1"># don&#39;t let it be smaller than 2 because linspace(1,5,1)= [1], linspace(1,5,2)= [1,5]</span>
    <span class="n">numSteps</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">numSteps</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">convergent</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">dischargeRing</span><span class="p">,</span> <span class="n">chargeRing</span><span class="p">,</span> <span class="n">numSteps</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># step 2. eliminate duplicates</span>
    <span class="n">convergent</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">convergent</span><span class="p">)))</span>

    <span class="c1"># step 3. compute widths</span>
    <span class="n">conWidths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ring</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">convergent</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">conWidths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convergent</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ring</span><span class="p">)</span>
    <span class="n">conWidths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># step 4. assemble and return</span>
    <span class="k">return</span> <span class="n">convergent</span><span class="p">,</span> <span class="n">conWidths</span></div>


<span class="k">def</span> <span class="nf">_buildEqRingScheduleHelper</span><span class="p">(</span><span class="n">ringSchedule</span><span class="p">,</span> <span class="n">numRings</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    turns ringScheduler into explicit list of rings</span>

<span class="sd">    Pulled out of buildEqRingSchedule for testing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ringSchedule : list</span>
<span class="sd">        List of ring bounds that is required to be an even number of entries.  These</span>
<span class="sd">        entries then are used in a from - to approach to add the rings.  The from ring will</span>
<span class="sd">        always be included.</span>

<span class="sd">    numRings : int</span>
<span class="sd">        The number of rings in the hex assembly reactor.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ringList : list</span>
<span class="sd">        List of all rings in the order they should be shuffled.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; _buildEqRingScheduleHelper([1,5])</span>
<span class="sd">    [1,2,3,4,5]</span>

<span class="sd">    &gt;&gt;&gt; _buildEqRingScheduleHelper([1,5,9,6])</span>
<span class="sd">    [1,2,3,4,5,9,8,7,6]</span>

<span class="sd">    &gt;&gt;&gt; _buildEqRingScheduleHelper([9,5,3,4,1,2])</span>
<span class="sd">    [9,8,7,6,5,3,4,1,2]</span>

<span class="sd">    &gt;&gt;&gt; _buildEqRingScheduleHelper([2,5,1,1])</span>
<span class="sd">    [2,3,4,5,1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ringSchedule</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Ring schedule: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ringSchedule</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Ring schedule does not have an even number of entries.&quot;</span><span class="p">)</span>

    <span class="n">ringList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ringSchedule</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">fromRing</span> <span class="o">=</span> <span class="n">ringSchedule</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">toRing</span> <span class="o">=</span> <span class="n">ringSchedule</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">numRings</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">toRing</span> <span class="o">-</span> <span class="n">fromRing</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">ringList</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">fromRing</span><span class="p">,</span> <span class="n">toRing</span><span class="p">,</span> <span class="n">numRings</span><span class="p">)])</span>

    <span class="c1"># eliminate doubles (but allow a ring to show up multiple times)</span>
    <span class="n">newList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lastRing</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">ringList</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="o">!=</span> <span class="n">lastRing</span><span class="p">:</span>
            <span class="n">newList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="o">&gt;</span> <span class="n">numRings</span><span class="p">:</span>
            <span class="c1"># error checking</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Ring </span><span class="si">{0}</span><span class="s2"> in eqRingSchedule larger than largest ring in reactor </span><span class="si">{1}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Adjust shuffling.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">numRings</span><span class="p">),</span>
                <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;too many rings&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">lastRing</span> <span class="o">=</span> <span class="n">ring</span>

    <span class="k">return</span> <span class="n">newList</span>


<span class="k">def</span> <span class="nf">_squaredDistanceFromOrigin</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the squared distance from the origin of an assembly.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Just a helper for ``buildEqRingSchedule()``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a: Assembly</span>
<span class="sd">        Fully initialize Assembly object; already part of a reactor core.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float: Distance from reactor center</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">())</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">origin</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_assemAngle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the angle of the Assembly, in the reactor core.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Just a helper for ``buildEqRingSchedule()``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a: Assembly</span>
<span class="sd">        Fully initialize Assembly object; already part of a reactor core.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float: Angle position of assembly around the reactor core</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<div class="viewcode-block" id="buildEqRingSchedule"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.hexAssemblyFuelMgmtUtils.html#armi.physics.fuelCycle.hexAssemblyFuelMgmtUtils.buildEqRingSchedule">[docs]</a><span class="k">def</span> <span class="nf">buildEqRingSchedule</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="n">ringSchedule</span><span class="p">,</span> <span class="n">circularRingOrder</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expands simple ringSchedule input into full-on location schedule</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    core : Core object</span>
<span class="sd">        Fully initialized Core object, for a hex assembly reactor.</span>

<span class="sd">    ringSchedule : list</span>
<span class="sd">        List of ring bounds that is required to be an even number of entries.  These</span>
<span class="sd">        entries then are used in a from - to approach to add the rings.  The from ring will</span>
<span class="sd">        always be included.</span>

<span class="sd">    circularRingOrder : str</span>
<span class="sd">        From the circularRingOrder setting. Valid values include angle and distanceSmart,</span>
<span class="sd">        anything else will</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list: location schedule</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># start by expanding the user-input eqRingSchedule list into a list containing</span>
    <span class="c1"># all the rings as it goes.</span>
    <span class="n">ringList</span> <span class="o">=</span> <span class="n">_buildEqRingScheduleHelper</span><span class="p">(</span><span class="n">ringSchedule</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">getNumRings</span><span class="p">())</span>

    <span class="c1"># now build the locationSchedule ring by ring using this ringSchedule</span>
    <span class="n">lastRing</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">locationSchedule</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">ringList</span><span class="p">:</span>
        <span class="n">assemsInRing</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">getAssembliesInRing</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">circularRingOrder</span> <span class="o">==</span> <span class="s2">&quot;angle&quot;</span><span class="p">:</span>
            <span class="n">sorter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">_assemAngle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">circularRingOrder</span> <span class="o">==</span> <span class="s2">&quot;distanceSmart&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lastRing</span> <span class="o">==</span> <span class="n">ring</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># converging. Put things on the outside first.</span>
                <span class="n">sorter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="o">-</span><span class="n">_squaredDistanceFromOrigin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># diverging. Put things on the inside first.</span>
                <span class="n">sorter</span> <span class="o">=</span> <span class="n">_squaredDistanceFromOrigin</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># purely based on distance. Can mix things up in convergent-divergent cases. Prefer distanceSmart</span>
            <span class="n">sorter</span> <span class="o">=</span> <span class="n">_squaredDistanceFromOrigin</span>

        <span class="n">assemsInRing</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">assemsInRing</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sorter</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemsInRing</span><span class="p">:</span>
            <span class="n">locationSchedule</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">())</span>
        <span class="n">lastRing</span> <span class="o">=</span> <span class="n">ring</span>

    <span class="k">return</span> <span class="n">locationSchedule</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2009-2022, TerraPower, LLC.
      <span class="lastupdated">
        Last updated on 2022-12-15.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
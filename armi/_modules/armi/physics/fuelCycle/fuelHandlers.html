

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>armi.physics.fuelCycle.fuelHandlers &mdash; ARMI 0.6.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme_fixes.css?v=2b77b304" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-dataframe.css?v=e5fbc548" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-data-viewer/jsonview.bundle.css?v=f6ef2277" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/libs/html/datatables.min.css?v=4b4fd840" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/need_links.css?v=2150a916" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/need_toggle.css?v=5c6620df" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/need_style.css?v=678fb11e" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/need_core.css?v=f5b60a78" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/needstable.css?v=5e1b6797" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/modern.css?v=803738c0" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-test-results/common.css?v=9ec2c1d5" />

  
    <link rel="shortcut icon" href="../../../../_static/armiicon_16x16.ico"/>
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=b8503983"></script>
      <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="../../../../_static/sphinx-data-viewer/jsonview.bundle.js?v=18cd53c5"></script>
      <script src="../../../../_static/sphinx-data-viewer/jsonview_loader.js?v=f7ff7e7d"></script>
      <script src="../../../../_static/sphinx-needs/libs/html/datatables.min.js?v=8a4aee21"></script>
      <script src="../../../../_static/sphinx-needs/libs/html/datatables_loader.js?v=a2cae175"></script>
      <script src="../../../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js?v=dca66431"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            ARMI
              <img src="../../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../qa_docs/index.html">QA Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../.apidocs/modules.html">API Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #233C5B" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ARMI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../../armi.html">armi</a></li>
          <li class="breadcrumb-item"><a href="../fuelCycle.html">armi.physics.fuelCycle</a></li>
      <li class="breadcrumb-item active">armi.physics.fuelCycle.fuelHandlers</li>
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for armi.physics.fuelCycle.fuelHandlers</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module handles fuel management operations such as shuffling, rotation, and</span>
<span class="sd">fuel processing (in fluid systems).</span>

<span class="sd">The :py:class:`FuelHandlerInterface` instantiates a ``FuelHandler``, which is typically a user-defined</span>
<span class="sd">subclass the :py:class:`FuelHandler` object in custom shuffle-logic input files.</span>
<span class="sd">Users point to the code modules with their custom fuel handlers using the</span>
<span class="sd">``shuffleLogic`` and ``fuelHandlerName`` settings, as described in :ref:`fuel-management-input`.</span>
<span class="sd">These subclasses override ``chooseSwaps`` that determine</span>
<span class="sd">the particular shuffling of a case.</span>

<span class="sd">This module also handles repeat shuffles when doing a restart.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># ruff: noqa: F401</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ruamel.yaml</span><span class="w"> </span><span class="kn">import</span> <span class="n">YAML</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ruamel.yaml.constructor</span><span class="w"> </span><span class="kn">import</span> <span class="n">DuplicateKeyError</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">armi</span><span class="w"> </span><span class="kn">import</span> <span class="n">runLog</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.physics.fuelCycle</span><span class="w"> </span><span class="kn">import</span> <span class="n">assemblyRotationAlgorithms</span> <span class="k">as</span> <span class="n">rotAlgos</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.physics.fuelCycle.fuelHandlerFactory</span><span class="w"> </span><span class="kn">import</span> <span class="n">fuelHandlerFactory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.physics.fuelCycle.fuelHandlerInterface</span><span class="w"> </span><span class="kn">import</span> <span class="n">FuelHandlerInterface</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.physics.fuelCycle.settings</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">CONF_ASSEMBLY_ROTATION_ALG</span><span class="p">,</span>
    <span class="n">CONF_SHUFFLE_SEQUENCE_FILE</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor</span><span class="w"> </span><span class="kn">import</span> <span class="n">grids</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.flags</span><span class="w"> </span><span class="kn">import</span> <span class="n">Flags</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.parameters</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParamLocation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.utils.customExceptions</span><span class="w"> </span><span class="kn">import</span> <span class="n">InputError</span>


<div class="viewcode-block" id="AssemblyMove">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.AssemblyMove">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">eq</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AssemblyMove</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Description of an individual shuffle move.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fromLoc : str</span>
<span class="sd">        Original location label.</span>
<span class="sd">    toLoc : str</span>
<span class="sd">        Destination location label.</span>
<span class="sd">    enrichList : list[float]</span>
<span class="sd">        Axial U235 weight percent enrichment values for each block.</span>
<span class="sd">    assemType : str, optional</span>
<span class="sd">        Type of assembly that is moving.</span>
<span class="sd">    nameAtDischarge : str, optional</span>
<span class="sd">        Name of the assembly moving (for SFP/delete interactions).</span>
<span class="sd">    rotation : float, optional</span>
<span class="sd">        Degrees of manual rotation to apply after shuffling.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fromLoc</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">toLoc</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">enrichList</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">assemType</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">nameAtDischarge</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">rotation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="ProcessMoveListResult">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.ProcessMoveListResult">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ProcessMoveListResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Container for the results of :meth:`FuelHandler.processMoveList`.&quot;&quot;&quot;</span>

    <span class="n">loadChains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
    <span class="n">loopChains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
    <span class="n">enriches</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span>
    <span class="n">loadChargeTypes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
    <span class="n">loadNames</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
    <span class="n">dischargeDests</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">rotations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span>
    <span class="n">alreadyDone</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span></div>



<div class="viewcode-block" id="FuelHandler">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FuelHandler</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A fuel handling machine can move fuel around the core and reactor.</span>

<span class="sd">    It makes decisions on how to shuffle fuel based on user specifications.</span>
<span class="sd">    It provides some supervisory data tracking, such as having the ability</span>
<span class="sd">    to print out information about all moves that happened in a cycle (without</span>
<span class="sd">    the user needing to explicitly track this information).</span>

<span class="sd">    To use this, simply create an input Python file and point to it by path</span>
<span class="sd">    with the ``fuelHandler`` setting. In that file, subclass this object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">DISCHARGE_LOCS</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s2">&quot;SFP&quot;</span><span class="p">,</span> <span class="s2">&quot;Delete&quot;</span><span class="p">})</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special strings to indicate an assembly is no longer in the core.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
        <span class="c1"># we need access to the operator to find the core, get settings, grab other interfaces, etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">o</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moved</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pendingRotations</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Link to the current cycle number.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This retains backwards compatibility with previous fuel handler inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cycle</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Link to the Case Settings object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">cs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Link to the Reactor object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">r</span>

<div class="viewcode-block" id="FuelHandler.outage">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.outage">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">outage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulates a reactor reload outage. Moves and tracks fuel.</span>

<span class="sd">        This sets the moveList structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot perform two outages with same FuelHandler instance.&quot;</span><span class="p">)</span>

        <span class="c1"># determine if a repeat shuffle is occurring or a new shuffle pattern</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_SHUFFLE_SEQUENCE_FILE</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_SHUFFLE_SEQUENCE_FILE</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                    <span class="s2">&quot;Requested shuffle sequence file </span><span class="si">{0}</span><span class="s2"> does not exist. Cannot perform shuffling. &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_SHUFFLE_SEQUENCE_FILE</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="s2">&quot;Applying shuffle sequence from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_SHUFFLE_SEQUENCE_FILE</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">performShuffle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_SHUFFLE_SEQUENCE_FILE</span><span class="p">],</span> <span class="n">yaml</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">]:</span>
            <span class="c1"># repeated shuffle</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Requested repeat shuffle file </span><span class="si">{0}</span><span class="s2"> does not exist. Cannot perform shuffling. &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="s2">&quot;Repeating a shuffling pattern from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">performShuffle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Normal shuffle from user-provided shuffle logic input</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chooseSwaps</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="c1"># do rotations if pin-level details are available (requires fluxRecon plugin)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;fluxRecon&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_ASSEMBLY_ROTATION_ALG</span><span class="p">]:</span>
            <span class="c1"># Rotate assemblies ONLY IF at least some assemblies have pin detail</span>
            <span class="c1"># The user can choose the algorithm method name directly in the settings</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rotAlgos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_ASSEMBLY_ROTATION_ALG</span><span class="p">]):</span>
                <span class="n">rotationMethod</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rotAlgos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_ASSEMBLY_ROTATION_ALG</span><span class="p">])</span>
                <span class="n">rotationMethod</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;FuelHandler </span><span class="si">{0}</span><span class="s2"> does not have a rotation algorithm called </span><span class="si">{1}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">Change your </span><span class="si">{2}</span><span class="s2"> setting&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">rotAlgos</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_ASSEMBLY_ROTATION_ALG</span><span class="p">],</span>
                        <span class="n">CONF_ASSEMBLY_ROTATION_ALG</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">for</span> <span class="n">loc</span><span class="p">,</span> <span class="n">deg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pendingRotations</span><span class="p">:</span>
            <span class="n">assem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblyWithStringLocation</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">assem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No assembly found at </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2"> for manual rotation&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rotating assembly </span><span class="si">{</span><span class="n">assem</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2"> by </span><span class="si">{</span><span class="n">deg</span><span class="si">}</span><span class="s2"> degrees CCW from shuffle file&quot;</span><span class="p">)</span>
            <span class="n">assem</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">deg</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pendingRotations</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># inform the reactor of how many moves occurred so it can put the number in the database.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
            <span class="n">numMoved</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span>

            <span class="c1"># tell the reactor which assemblies moved where</span>
            <span class="c1"># also tell enrichments of each block in case there&#39;s some autoboosting going on.</span>
            <span class="c1"># This is also essential for repeating shuffles in later restart runs.</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">setMoveList</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cycle</span><span class="p">,</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">lastLocationLabel</span><span class="p">,</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">(),</span>
                        <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">getUraniumMassEnrich</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">],</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">getType</span><span class="p">(),</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span>
                    <span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="s2">&quot;A fuel management error has occurred. &quot;</span><span class="p">)</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="s2">&quot;Trying operation on assembly </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="s2">&quot;The moved list is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">))</span>
                    <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numMoved</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">numMoves</span> <span class="o">=</span> <span class="n">numMoved</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">setBlockMassParams</span><span class="p">()</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="s2">&quot;Fuel handler performed </span><span class="si">{0}</span><span class="s2"> assembly shuffles.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numMoved</span><span class="p">))</span>

        <span class="c1"># now wipe out the self.moved version so it doesn&#39;t transmit the assemblies during distributeState</span>
        <span class="n">moved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moved</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">moved</span></div>


<div class="viewcode-block" id="FuelHandler.chooseSwaps">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.chooseSwaps">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">chooseSwaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shuffleFactors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Moves the fuel around or otherwise processes it between cycles.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="FuelHandler.getFactorList">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.getFactorList">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">getFactorList</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fallBack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return factors between 0 and 1 that control fuel management.</span>

<span class="sd">        This is the default shuffle control function. Usually you would override this</span>
<span class="sd">        with your own in a custom shuffleLogic.py file. For more details about how this</span>
<span class="sd">        works, refer to :ref:`fuel-management-input`.</span>

<span class="sd">        This will get bound to the default FuelHandler as a static method below. This is</span>
<span class="sd">        done to allow a user to mix and match FuelHandler class implementations and</span>
<span class="sd">        getFactorList implementations at run time.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Ultimately, this approach will likely get replaced using the plugin framework, but</span>
<span class="sd">        we aren&#39;t there yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># prefer to keep these 0 through 1 since this is what the branch search can do.</span>
        <span class="n">defaultFactorList</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;eqShuffles&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="n">factorSearchFlags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">defaultFactorList</span><span class="p">,</span> <span class="n">factorSearchFlags</span></div>


<div class="viewcode-block" id="FuelHandler.prepCore">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.prepCore">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepCore</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aux function to run before XS generation (do moderation, etc).&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compareAssem</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether the candidate assembly should replace the current ideal assembly.</span>

<span class="sd">        Given a candidate tuple (diff1, a1) and current tuple (diff2, a2), decide whether the</span>
<span class="sd">        candidate is better than the current ideal. This first compares the diff1 and diff2 values.</span>
<span class="sd">        If diff1 is sufficiently less than diff2, a1 wins, returning True. Otherwise, False. If</span>
<span class="sd">        diff1 and diff2 are sufficiently close, the assembly with the lesser assemNum wins. This</span>
<span class="sd">        should result in a more stable comparison than on floating-point comparisons alone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span> <span class="o">&lt;</span> <span class="n">current</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_getParamMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">paramName</span><span class="p">,</span> <span class="n">blockLevelMax</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get assembly/block-level maximum parameter value in assembly.&quot;&quot;&quot;</span>
        <span class="n">multiplier</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">getSymmetryFactor</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">multiplier</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># handle special case: volume-integrated parameters where symmetry factor is not 1</span>
            <span class="k">if</span> <span class="n">blockLevelMax</span><span class="p">:</span>
                <span class="n">paramCollection</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">p</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">paramCollection</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">p</span>
            <span class="n">isVolumeIntegrated</span> <span class="o">=</span> <span class="n">paramCollection</span><span class="o">.</span><span class="n">paramDefs</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span><span class="o">.</span><span class="n">location</span> <span class="o">==</span> <span class="n">ParamLocation</span><span class="o">.</span><span class="n">VOLUME_INTEGRATED</span>
            <span class="n">multiplier</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">getSymmetryFactor</span><span class="p">()</span> <span class="k">if</span> <span class="n">isVolumeIntegrated</span> <span class="k">else</span> <span class="mf">1.0</span>

        <span class="k">if</span> <span class="n">blockLevelMax</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">getChildParamValues</span><span class="p">(</span><span class="n">paramName</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="n">multiplier</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span> <span class="o">*</span> <span class="n">multiplier</span>

<div class="viewcode-block" id="FuelHandler.findAssembly">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.findAssembly">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">findAssembly</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">targetRing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">compareTo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">forceSide</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclusions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mandatoryLocations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">zoneList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">excludedLocations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">minParam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">minVal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxParam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxVal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">findMany</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exactType</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">acceptFirstCandidateRing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">blockLevelMax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">findFromSfp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">maxNumAssems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">circularRingFlag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search reactor for assemblies with various criterion. Primarily for shuffling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        targetRing : int, optional</span>
<span class="sd">            The ring in which to search</span>

<span class="sd">        width : tuple of integers</span>
<span class="sd">            A (size, side) tuple where size is the number of rings on either side to also check.</span>
<span class="sd">            side=1: only look in higher, -1: only look lower, 0: both sides</span>

<span class="sd">        param : string, optional</span>
<span class="sd">            A block (if blockLevelMax) or assem level param name such as &#39;power&#39; or &#39;percentBu&#39;</span>
<span class="sd">            (requires compareTo).</span>

<span class="sd">        compareTo : float or Assembly instance</span>
<span class="sd">            an assembly to be compared to. Alternatively, a floating point number to compare to.</span>
<span class="sd">            Even more alternatively,  an (assembly,mult) or (float,mult) tuple where mult is a</span>
<span class="sd">            multiplier. For example, if you wanted an assembly that had a bu close to half of</span>
<span class="sd">            assembly bob, you&#39;d give param=&#39;percentBu&#39;, compareTo=(bob,0.5) If you want one with a</span>
<span class="sd">            bu close to 0.3, you&#39;d do param=&#39;percentBu&#39;,compareTo=0.3. Yes, if you give a (float,</span>
<span class="sd">            multiplier) tuple the code will still work as expected.</span>

<span class="sd">        forceSide : bool, optional</span>
<span class="sd">            requires the found assembly to have either 1: higher, -1: lower, None: any param than</span>
<span class="sd">            compareTo</span>

<span class="sd">        exclusions : list, optional</span>
<span class="sd">            List of assemblies that will be excluded from the search</span>

<span class="sd">        minParam : float or list, optional</span>
<span class="sd">            a parameter to compare to minVal for setting lower bounds. If list, must correspond to</span>
<span class="sd">            parameters in minVal in order.</span>

<span class="sd">        maxParam : float or list, optional</span>
<span class="sd">            a parameter to compare to maxVal for setting upper bounds of acceptable assemblies.</span>
<span class="sd">            If list, must correspond to parameters in maxVal in order.</span>

<span class="sd">        minVal : float or list, optional</span>
<span class="sd">            a value or a (parameter, multiplier) tuple for setting lower bounds</span>

<span class="sd">            For instance, if minParam=&#39;timeToLimit&#39; and minVal=10, only assemblies with timeToLimit</span>
<span class="sd">            higher than 10 will be returned. (Of course, there is also maxParam and maxVal)</span>

<span class="sd">        maxVal : float or list, optional</span>
<span class="sd">            a value or a (parameter, multiplier) tuple for setting upper bounds</span>

<span class="sd">        mandatoryLocations : list, optional</span>
<span class="sd">            A list of string-representations of locations in the core for limiting the search to</span>
<span class="sd">            several places. Any locations also included in `excludedLocations` will be excluded.</span>

<span class="sd">        excludedLocations : list, optional</span>
<span class="sd">            a list of string-representations of locations in the core that will be excluded from</span>
<span class="sd">            the search</span>

<span class="sd">        zoneList : list, optional</span>
<span class="sd">            name of a zone defined in settings.py that will be picked from. Under development</span>

<span class="sd">        findMany : bool, optional</span>
<span class="sd">            If True, will return a list of assembies that match. Don&#39;t give a param.</span>

<span class="sd">        typeSpec : Flags or list of Flags, optional</span>
<span class="sd">            only assemblies with this type list will be returned. If none, only fuel will be found.</span>

<span class="sd">        coords : tuple, optional</span>
<span class="sd">            x,y tuple in cm. the fuel handler will try to find an assembly with a center closest to</span>
<span class="sd">            that point</span>

<span class="sd">        exactType : bool, optional</span>
<span class="sd">            require type to be exactly equal to what&#39;s in the type list. So</span>
<span class="sd">            Flags.IGNITER | Flags.FUEL is not Flags.INNER | Flags.IGNITER | Flags.FUEL</span>

<span class="sd">        acceptFirstCandidateRing : bool, optional</span>
<span class="sd">            takes the first assembly found in the earliest ring (without searching all rings for a</span>
<span class="sd">            maxBu, for example) So if the candidate rings are 1-10 and we&#39;re looking for igniter</span>
<span class="sd">            fuel with a maxBurnup, we don&#39;t get the max burnup in all those rings, but rather the</span>
<span class="sd">            igniter with the max burnup in the ring closest to 1. If there are no igniters until</span>
<span class="sd">            ring 4, you will get an igniter in ring 4.</span>

<span class="sd">        blockLevelMax : bool, optional</span>
<span class="sd">            If true, the param to search for will be built as the maximum block-level param of this</span>
<span class="sd">            name instead of the assembly param. This avoids the need to assign assembly level params</span>
<span class="sd">            sometimes.</span>
<span class="sd">            default: false.</span>

<span class="sd">        findFromSfp : bool, optional</span>
<span class="sd">            If true, will look in the spent-fuel pool instead of in the core.</span>

<span class="sd">        maxNumAssems : int, optional</span>
<span class="sd">            The maximum number of assemblies to return. Only relevant if findMany==True</span>

<span class="sd">        circularRingFlag : bool, optional</span>
<span class="sd">            Toggle using rings that are based on distance from the center of the reactor</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The call signature on this method may have gotten slightly out of hand as valuable</span>
<span class="sd">        capabilities were added in fuel management studies. For additional expansion, it may be</span>
<span class="sd">        worth reconsidering the design of these query operations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Assembly instance or assemList of assembly instances that match criteria, or None if none</span>
<span class="sd">        match</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This returns the feed fuel assembly in ring 4 that has a burnup closest to 100%</span>
<span class="sd">        (the highest burnup assembly)::</span>

<span class="sd">            feed = self.findAssembly(</span>
<span class="sd">                targetRing=4, width=(0, 0), param=&quot;maxPercentBu&quot;, compareTo=100, typeSpec=Flags.FEED | Flags.FUEL</span>
<span class="sd">            )</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># list for storing multiple results if findMany is true.</span>
        <span class="n">assemList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># process input arguments</span>
        <span class="k">if</span> <span class="n">targetRing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># look through the full core</span>
            <span class="n">targetRing</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">width</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclusions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclusions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">minVal</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># list given with multiple mins</span>
            <span class="n">minVals</span> <span class="o">=</span> <span class="n">minVal</span>
            <span class="n">minParams</span> <span class="o">=</span> <span class="n">minParam</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minVals</span> <span class="o">=</span> <span class="p">[</span><span class="n">minVal</span><span class="p">]</span>
            <span class="n">minParams</span> <span class="o">=</span> <span class="p">[</span><span class="n">minParam</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maxVal</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">maxVals</span> <span class="o">=</span> <span class="n">maxVal</span>
            <span class="n">maxParams</span> <span class="o">=</span> <span class="n">maxParam</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># just one given. put it in a list so the below machinery can handle it.</span>
            <span class="n">maxVals</span> <span class="o">=</span> <span class="p">[</span><span class="n">maxVal</span><span class="p">]</span>
            <span class="n">maxParams</span> <span class="o">=</span> <span class="p">[</span><span class="n">maxParam</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">typeSpec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># restrict motions to fuel only</span>
            <span class="c1"># not really necessary. take this default out if you want to move control rods, etc.</span>
            <span class="n">typeSpec</span> <span class="o">=</span> <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span>

        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e60</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># compareTo can either be a tuple, a value, or an assembly</span>
        <span class="c1"># if it&#39;s a tuple, it can either be an int/float and a multiplier, or an assembly and a multiplier</span>
        <span class="c1"># if it&#39;s not a tuple, the multiplier will be assumed to be 1.0</span>

        <span class="n">mult</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># if no mult brought in, just assume 1.0</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compareTo</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># tuple (assem or int/float, multiplier) brought in.</span>
            <span class="c1"># separate it</span>
            <span class="n">compareTo</span><span class="p">,</span> <span class="n">mult</span> <span class="o">=</span> <span class="n">compareTo</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compareTo</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="c1"># floating point or int.</span>
            <span class="n">compVal</span> <span class="o">=</span> <span class="n">compareTo</span> <span class="o">*</span> <span class="n">mult</span>
        <span class="k">elif</span> <span class="n">param</span><span class="p">:</span>
            <span class="c1"># assume compareTo is an assembly</span>
            <span class="n">compVal</span> <span class="o">=</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">_getParamMax</span><span class="p">(</span><span class="n">compareTo</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">blockLevelMax</span><span class="p">)</span> <span class="o">*</span> <span class="n">mult</span>

        <span class="k">if</span> <span class="n">coords</span><span class="p">:</span>
            <span class="c1"># find the assembly closest to xt,yt if coords are given without considering params.</span>
            <span class="n">aTarg</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">minD</span> <span class="o">=</span> <span class="mf">1e10</span>
            <span class="n">xt</span><span class="p">,</span> <span class="n">yt</span> <span class="o">=</span> <span class="n">coords</span>  <span class="c1"># assume (x,y) tuple</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">()</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">yt</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xt</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">minD</span><span class="p">:</span>
                    <span class="n">minD</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="n">aTarg</span> <span class="o">=</span> <span class="n">a</span>

            <span class="k">return</span> <span class="n">aTarg</span>

        <span class="k">if</span> <span class="n">findFromSfp</span><span class="p">:</span>
            <span class="c1"># hack to enable SFP searching.</span>
            <span class="n">candidateRings</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SFP&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># set up candidateRings based on targetRing and width. The target rings comes first b/c it is preferred.</span>
            <span class="n">candidateRings</span> <span class="o">=</span> <span class="p">[</span><span class="n">targetRing</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">width</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># 0 or -1 implies that the inner rings can be added.</span>
                <span class="k">for</span> <span class="n">inner</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">candidateRings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">targetRing</span> <span class="o">-</span> <span class="n">inner</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># +1 to get 1,2,3 instead of 0,1,2</span>
            <span class="k">if</span> <span class="n">width</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if 1, add in the outer rings</span>
                <span class="k">for</span> <span class="n">outer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">candidateRings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">targetRing</span> <span class="o">+</span> <span class="n">outer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># get lists of assemblies in each candidate ring. Do it in this order in case we prefer ones in the first.</span>
        <span class="c1"># scan through all assemblies and find the one (or more) that best fits the criteria</span>
        <span class="k">for</span> <span class="n">ringI</span><span class="p">,</span> <span class="n">assemsInRings</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getAssembliesInRings</span><span class="p">(</span><span class="n">candidateRings</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">exactType</span><span class="p">,</span> <span class="n">exclusions</span><span class="p">,</span> <span class="n">circularRingFlag</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemsInRings</span><span class="p">:</span>
                <span class="n">innocent</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Check that this assembly&#39;s minParam is &gt; the minimum for each minParam</span>
                <span class="k">for</span> <span class="n">minIndex</span><span class="p">,</span> <span class="n">minVal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">minVals</span><span class="p">):</span>
                    <span class="n">minParam</span> <span class="o">=</span> <span class="n">minParams</span><span class="p">[</span><span class="n">minIndex</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">minParam</span><span class="p">:</span>
                        <span class="c1"># a minimum was specified. Check to see if we&#39;re ok</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">minVal</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                            <span class="c1"># tuple turned in. it&#39;s a multiplier and a param</span>
                            <span class="n">realMinVal</span> <span class="o">=</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">_getParamMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">minVal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">blockLevelMax</span><span class="p">)</span> <span class="o">*</span> <span class="n">minVal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">realMinVal</span> <span class="o">=</span> <span class="n">minVal</span>

                        <span class="k">if</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">_getParamMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">minParam</span><span class="p">,</span> <span class="n">blockLevelMax</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">realMinVal</span><span class="p">:</span>
                            <span class="c1"># this assembly does not meet the minVal specifications. Skip it.</span>
                            <span class="n">innocent</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>  <span class="c1"># for speed (not a big deal here)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">innocent</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Check upper bounds, to make sure this assembly doesn&#39;t have maxParams&gt;maxVals</span>
                <span class="k">for</span> <span class="n">maxIndex</span><span class="p">,</span> <span class="n">maxVal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">maxVals</span><span class="p">):</span>
                    <span class="n">maxParam</span> <span class="o">=</span> <span class="n">maxParams</span><span class="p">[</span><span class="n">maxIndex</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">maxParam</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maxVal</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                            <span class="c1"># tuple turned in. it&#39;s a multiplier and a param</span>
                            <span class="n">realMaxVal</span> <span class="o">=</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">_getParamMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">maxVal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">blockLevelMax</span><span class="p">)</span> <span class="o">*</span> <span class="n">maxVal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">realMaxVal</span> <span class="o">=</span> <span class="n">maxVal</span>

                        <span class="k">if</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">_getParamMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">maxParam</span><span class="p">,</span> <span class="n">blockLevelMax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">realMaxVal</span><span class="p">:</span>
                            <span class="c1"># this assembly has a maxParam that&#39;s higher than maxVal and therefore</span>
                            <span class="c1"># doesn&#39;t qualify. skip it.</span>
                            <span class="n">innocent</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">innocent</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Check to see if this assembly is in the list of candidate locations. if not, skip it.</span>
                <span class="k">if</span> <span class="n">mandatoryLocations</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mandatoryLocations</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="n">excludedLocations</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="ow">in</span> <span class="n">excludedLocations</span><span class="p">:</span>
                        <span class="c1"># this assembly is in the excluded location list. skip it.</span>
                        <span class="k">continue</span>

                <span class="c1"># only process of the Assembly is in a Zone</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isAssemblyInAZone</span><span class="p">(</span><span class="n">zoneList</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Now find the assembly with the param closest to the target val.</span>
                <span class="k">if</span> <span class="n">param</span><span class="p">:</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">FuelHandler</span><span class="o">.</span><span class="n">_getParamMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">blockLevelMax</span><span class="p">)</span> <span class="o">-</span> <span class="n">compVal</span><span class="p">)</span>

                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">forceSide</span> <span class="o">==</span> <span class="mi">1</span>
                        <span class="ow">and</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">_getParamMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">blockLevelMax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">compVal</span>
                        <span class="ow">and</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">_compareAssem</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">minDiff</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="c1"># forceSide=1, so that means look in rings further out</span>
                        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">(</span>
                        <span class="n">forceSide</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="ow">and</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">_getParamMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">blockLevelMax</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">compVal</span>
                        <span class="ow">and</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">_compareAssem</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">minDiff</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="c1"># forceSide=-1, so that means look in rings closer in from the targetRing</span>
                        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">_compareAssem</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">minDiff</span><span class="p">):</span>
                        <span class="c1"># no preference of which side, just take the one with the closest param.</span>
                        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># no param specified. Just return one closest to the target ring</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">targetRing</span><span class="p">:</span>
                        <span class="c1"># short circuit the search</span>
                        <span class="k">if</span> <span class="n">findMany</span><span class="p">:</span>
                            <span class="n">assemList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">a</span>
                    <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">targetRing</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">targetRing</span><span class="p">),</span>
                            <span class="n">a</span><span class="p">,</span>
                        <span class="p">)</span>

                <span class="k">if</span> <span class="n">findMany</span><span class="p">:</span>
                    <span class="c1"># returning many assemblies. If there&#39;s a param, we&#39;d like it to be honored by</span>
                    <span class="c1"># ordering this list from smallest diff to largest diff.</span>
                    <span class="n">assemList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">ringI</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">acceptFirstCandidateRing</span> <span class="ow">and</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># an acceptable assembly was found in the targetRing (ringI==0)</span>
                <span class="c1"># and the user requested this to be returned. Therefore, return it without</span>
                <span class="c1"># scanning through the additional rings.</span>
                <span class="k">return</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># can&#39;t find assembly in targetRing with close param to compareTo</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">findMany</span><span class="p">:</span>
            <span class="n">assemList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># prefer items that have params that are the closest to the value.</span>
            <span class="c1"># extract the assemblies.</span>
            <span class="n">assemsInRings</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">diff</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemList</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">maxNumAssems</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">assemsInRings</span><span class="p">[:</span><span class="n">maxNumAssems</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">assemsInRings</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="FuelHandler.isAssemblyInAZone">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.isAssemblyInAZone">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">isAssemblyInAZone</span><span class="p">(</span><span class="n">zoneList</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Does the given assembly in one of these zones.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">zoneList</span><span class="p">:</span>
            <span class="c1"># ruff: noqa: SIM110</span>
            <span class="k">for</span> <span class="n">zone</span> <span class="ow">in</span> <span class="n">zoneList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="ow">in</span> <span class="n">zone</span><span class="p">:</span>
                    <span class="c1"># Success!</span>
                    <span class="k">return</span> <span class="kc">True</span>

            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># A little counter-intuitively, if there are no zones, we return True.</span>
            <span class="k">return</span> <span class="kc">True</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_getAssembliesInRings</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ringList</span><span class="p">,</span>
        <span class="n">typeSpec</span><span class="o">=</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span>
        <span class="n">exactType</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">exclusions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">circularRingFlag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find assemblies in particular rings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ringList : list</span>
<span class="sd">            List of integer ring numbers to find assemblies in. Optionally, a string specifying a</span>
<span class="sd">            special location like the SFP (spent fuel pool)</span>

<span class="sd">        typeSpec : Flags or iterable of Flags, optional</span>
<span class="sd">            Flag types to restrict assemblies to</span>

<span class="sd">        exactType : bool, optional</span>
<span class="sd">            Match the type in typelist exactly</span>

<span class="sd">        exclusions : list of Assemblies, optional</span>
<span class="sd">            exclude these assemblies from the results</span>

<span class="sd">        circularRingFlag : bool</span>
<span class="sd">            A flag to toggle on using rings that are based on distance from the center of the reactor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        assemblyList : list</span>
<span class="sd">            List of assemblies in each ring of the ringList. [[a1,a2,a3],[a4,a5,a6,a7],...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;SFP&quot;</span> <span class="ow">in</span> <span class="n">ringList</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">excore</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sfp&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sfpAssems</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> can&#39;t pull from SFP; no SFP is attached to the reactor </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="s2">&quot;To get assemblies from an SFP, you must add an SFP system to the blueprints&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;or otherwise instantiate a SpentFuelPool object as r.excore[&#39;sfp&#39;]&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sfpAssems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">excore</span><span class="p">[</span><span class="s2">&quot;sfp&quot;</span><span class="p">])</span>

        <span class="n">assemblyList</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ringList</span><span class="p">))]</span>  <span class="c1"># empty lists for each ring</span>
        <span class="k">if</span> <span class="n">exclusions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclusions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">exclusions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclusions</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">circularRingFlag</span><span class="p">:</span>
            <span class="n">assemListTmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">assemListTmp2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">ringList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SFP&quot;</span><span class="p">:</span>
                <span class="c1"># kind of a hack for now. Need the capability.</span>
                <span class="n">assemblyList</span> <span class="o">=</span> <span class="n">sfpAssems</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ringNumber</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ringList</span><span class="p">):</span>
                    <span class="n">assemListTmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssembliesInCircularRing</span><span class="p">(</span><span class="n">ringNumber</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">exactType</span><span class="p">,</span> <span class="n">exclusions</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemListTmp</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">exclusions</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exactType</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="c1"># save only the assemblies not in the exclusions and with the proper type</span>
                        <span class="n">assemListTmp2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                    <span class="c1"># make the list of lists of assemblies</span>
                    <span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">assemListTmp2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ringList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SFP&quot;</span><span class="p">:</span>
                <span class="c1"># kind of a hack for now. Need the capability.</span>
                <span class="n">assemList</span> <span class="o">=</span> <span class="n">sfpAssems</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">assemList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">exclusions</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exactType</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;SFP&quot;</span><span class="p">:</span>
                    <span class="n">ring</span> <span class="o">=</span> <span class="s2">&quot;SFP&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ring</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">ringList</span><span class="p">:</span>
                    <span class="c1"># keep it in the right order</span>
                    <span class="n">assemblyList</span><span class="p">[</span><span class="n">ringList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ring</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">assemblyList</span>

<div class="viewcode-block" id="FuelHandler.swapAssemblies">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.swapAssemblies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">swapAssemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Moves a whole assembly from one place to another.</span>

<span class="sd">        .. impl:: User-specified blocks can be left in place during within-core swaps.</span>
<span class="sd">            :id: I_ARMI_SHUFFLE_STATIONARY0</span>
<span class="sd">            :implements: R_ARMI_SHUFFLE_STATIONARY</span>

<span class="sd">            Before assemblies are moved, the ``_transferStationaryBlocks`` class method is called to</span>
<span class="sd">            check if there are any block types specified by the user as stationary via the</span>
<span class="sd">            ``stationaryBlockFlags`` case setting. Using these flags, blocks are gathered from each</span>
<span class="sd">            assembly which should remain stationary and checked to make sure that both assemblies</span>
<span class="sd">            have the same number and same height of stationary blocks. If not, return an error.</span>

<span class="sd">            If all checks pass, the :py:meth:`~armi.reactor.assemblies.Assembly.remove` and</span>
<span class="sd">            :py:meth:`~armi.reactor.assemblies.Assembly.insert` methods are used to swap the</span>
<span class="sd">            stationary blocks between the two assemblies.</span>

<span class="sd">            Once this process is complete, the actual assembly movement can take place. Through this</span>
<span class="sd">            process, the stationary blocks remain in the same core location.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a1 : :py:class:`Assembly &lt;armi.reactor.assemblies.Assembly&gt;`</span>
<span class="sd">            The first assembly</span>
<span class="sd">        a2 : :py:class:`Assembly &lt;armi.reactor.assemblies.Assembly&gt;`</span>
<span class="sd">            The second assembly</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dischargeSwap : swap assemblies where one is outside the core and the other is inside</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">a2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot swap None assemblies. Check your findAssembly results. Skipping swap&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Swapping </span><span class="si">{}</span><span class="s2"> with </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">))</span>
        <span class="c1"># add assemblies into the moved location</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">oldA1Location</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">spatialLocator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transferStationaryBlocks</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
        <span class="n">a1</span><span class="o">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">a2</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
        <span class="n">a2</span><span class="o">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">oldA1Location</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_transferStationaryBlocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assembly1</span><span class="p">,</span> <span class="n">assembly2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exchange the stationary blocks (e.g. grid plate) between the moving assemblies.</span>

<span class="sd">        These blocks in effect are not moved at all.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># grab stationary block flags</span>
        <span class="n">sBFList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">stationaryBlockFlagsList</span>

        <span class="c1"># identify stationary blocks for assembly 1</span>
        <span class="n">a1StationaryBlocks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">block</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">assembly1</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">sbf</span><span class="p">)</span> <span class="k">for</span> <span class="n">sbf</span> <span class="ow">in</span> <span class="n">sBFList</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># identify stationary blocks for assembly 2</span>
        <span class="n">a2StationaryBlocks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">block</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">assembly2</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">sbf</span><span class="p">)</span> <span class="k">for</span> <span class="n">sbf</span> <span class="ow">in</span> <span class="n">sBFList</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># check for any inconsistencies in stationary blocks and ensure alignment</span>
        <span class="k">if</span> <span class="p">[</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">a1StationaryBlocks</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">a2StationaryBlocks</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Different number and/or locations of stationary blocks </span>
<span class="sd">                 between {} (Stationary Blocks: {}) and {} (Stationary Blocks: {}).&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">assembly1</span><span class="p">,</span> <span class="n">a1StationaryBlocks</span><span class="p">,</span> <span class="n">assembly2</span><span class="p">,</span> <span class="n">a2StationaryBlocks</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">a1StationaryBlocks</span> <span class="ow">and</span> <span class="n">a2StationaryBlocks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a1StationaryBlocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span> <span class="o">!=</span> <span class="n">a2StationaryBlocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;Difference in top elevation of stationary blocks </span>
<span class="sd">                     between {} (Stationary Blocks: {}, Elevation at top of stationary blocks {}) </span>
<span class="sd">                     and {} (Stationary Blocks: {}, Elevation at top of stationary blocks {}))&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">assembly1</span><span class="p">,</span>
                        <span class="n">a1StationaryBlocks</span><span class="p">,</span>
                        <span class="n">a1StationaryBlocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span><span class="p">,</span>
                        <span class="n">assembly2</span><span class="p">,</span>
                        <span class="n">a2StationaryBlocks</span><span class="p">,</span>
                        <span class="n">a2StationaryBlocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># swap stationary blocks</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">assem1Block</span><span class="p">,</span> <span class="n">assem1BlockIndex</span><span class="p">),</span> <span class="p">(</span><span class="n">assem2Block</span><span class="p">,</span> <span class="n">assem2BlockIndex</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">a1StationaryBlocks</span><span class="p">,</span> <span class="n">a2StationaryBlocks</span>
        <span class="p">):</span>
            <span class="c1"># remove stationary blocks</span>
            <span class="n">assembly1</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">assem1Block</span><span class="p">)</span>
            <span class="n">assembly2</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">assem2Block</span><span class="p">)</span>
            <span class="c1"># insert stationary blocks</span>
            <span class="n">assembly1</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">assem1BlockIndex</span><span class="p">,</span> <span class="n">assem2Block</span><span class="p">)</span>
            <span class="n">assembly2</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">assem2BlockIndex</span><span class="p">,</span> <span class="n">assem1Block</span><span class="p">)</span>

<div class="viewcode-block" id="FuelHandler.validateLoc">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.validateLoc">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">validateLoc</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate a location label from a shuffle YAML file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : str</span>
<span class="sd">            Location label to validate.</span>
<span class="sd">        cycle : int</span>
<span class="sd">            Cycle currently being processed, used for context in error messages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">DISCHARGE_LOCS</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">grids</span><span class="o">.</span><span class="n">locatorLabelToIndices</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid location label </span><span class="si">{</span><span class="n">loc</span><span class="si">!r}</span><span class="s2"> in cycle </span><span class="si">{</span><span class="n">cycle</span><span class="si">}</span><span class="s2"> in shuffle YAML. &quot;</span>
                <span class="s2">&quot;Location labels must be non-empty and contain integers.&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="FuelHandler.dischargeSwap">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.dischargeSwap">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dischargeSwap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">,</span> <span class="n">toSfp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes one assembly from the core and replace it with another assembly.</span>

<span class="sd">        .. impl:: User-specified blocks can be left in place for the discharge swap.</span>
<span class="sd">            :id: I_ARMI_SHUFFLE_STATIONARY1</span>
<span class="sd">            :implements: R_ARMI_SHUFFLE_STATIONARY</span>

<span class="sd">            Before assemblies are moved, the ``_transferStationaryBlocks`` class method is called to</span>
<span class="sd">            check if there are any block types specified by the user as stationary via the</span>
<span class="sd">            ``stationaryBlockFlags`` case setting. Using these flags, blocks are gathered from each</span>
<span class="sd">            assembly which should remain stationary and checked to make sure that both assemblies</span>
<span class="sd">            have the same number and same height of stationary blocks. If not, return an error.</span>

<span class="sd">            If all checks pass, the :py:meth:`~armi.reactor.assemblies.Assembly.remove` and</span>
<span class="sd">            :py:meth:`~armi.reactor.assemblies.Assembly.insert` methods are used to swap the</span>
<span class="sd">            stationary blocks between the two assemblies.</span>

<span class="sd">            Once this process is complete, the actual assembly movement can take place. Through this</span>
<span class="sd">            process, the stationary blocks from the outgoing assembly remain in the original core</span>
<span class="sd">            position, while the stationary blocks from the incoming assembly are discharged with the</span>
<span class="sd">            outgoing assembly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        incoming : :py:class:`Assembly &lt;armi.reactor.assemblies.Assembly&gt;`</span>
<span class="sd">            The assembly getting swapped into the core.</span>
<span class="sd">        outgoing : :py:class:`Assembly &lt;armi.reactor.assemblies.Assembly&gt;`</span>
<span class="sd">            The assembly getting discharged out the core.</span>
<span class="sd">        toSfp : bool, optional</span>
<span class="sd">            If True, store the discharged assembly in the SFP regardless of the</span>
<span class="sd">            ``trackAssems`` setting.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        swapAssemblies : swaps assemblies that are already in the core</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Discharge swapping </span><span class="si">{}</span><span class="s2"> for </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">incoming</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">outgoing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot discharge swap None assemblies. Check your findAssembly calls. Skipping&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># add assemblies into the moved location</span>
        <span class="c1"># keep it unique so we don&#39;t get artificially inflated numMoves</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transferStationaryBlocks</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">)</span>

        <span class="c1"># replace the goingOut guy.</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">outgoing</span><span class="o">.</span><span class="n">spatialLocator</span>
        <span class="c1"># say it happened at the end of the previous cycle by sending cycle-1</span>
        <span class="c1"># to removeAssembly, which will look up EOC of last cycle,</span>
        <span class="c1"># which, coincidentally is the same time we&#39;re at right now at BOC.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">removeAssembly</span><span class="p">(</span><span class="n">outgoing</span><span class="p">,</span> <span class="n">addToSFP</span><span class="o">=</span><span class="n">toSfp</span><span class="p">)</span>

        <span class="c1"># adjust the assembly multiplicity so that it does not forget how many it really</span>
        <span class="c1"># represents. This allows us to discharge an assembly from any location in</span>
        <span class="c1"># fractional-core models where the central location may only be one assembly,</span>
        <span class="c1"># whereas other locations are more, and keep proper track of things. In the</span>
        <span class="c1"># future, this mechanism may be used to handle symmetry in general.</span>
        <span class="n">outgoing</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">multiplicity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">getSymmetricEquivalents</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">excore</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sfp&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">incoming</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">excore</span><span class="p">[</span><span class="s2">&quot;sfp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
                <span class="c1"># pull it out of the sfp if it&#39;s in there.</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;removing </span><span class="si">{0}</span><span class="s2"> from the sfp&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">incoming</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">excore</span><span class="p">[</span><span class="s2">&quot;sfp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">incoming</span><span class="p">)</span>

        <span class="n">incoming</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">multiplicity</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span></div>


<div class="viewcode-block" id="FuelHandler.swapCascade">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.swapCascade">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">swapCascade</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemList</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform swaps on a list of assemblies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        assemList: list</span>
<span class="sd">            A list of assemblies to be shuffled.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        [goingOut,inter1,inter2,goingIn]  will go to</span>
<span class="sd">        [inter1, inter2, goingIn, goingOut] in terms of positions</span>
<span class="sd">        or, in ASCII art::</span>

<span class="sd">             &gt;---------------v</span>
<span class="sd">             |               |</span>
<span class="sd">            [A  &lt;- B &lt;- C &lt;- D]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first check for duplicates</span>
        <span class="k">for</span> <span class="n">assem</span> <span class="ow">in</span> <span class="n">assemList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">assemList</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">assem</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">assem</span><span class="si">}</span><span class="s2"> is in the cascade more than once.&quot;</span><span class="p">)</span>

        <span class="c1"># now swap</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">assemList</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">levels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">assemList</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Skipping level </span><span class="si">{</span><span class="n">level</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> in the cascade because it is None. Be careful, &quot;</span>
                    <span class="s2">&quot;this might cause an unexpected shuffling order.&quot;</span>
                <span class="p">)</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">swapAssemblies</span><span class="p">(</span><span class="n">assemList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">assemList</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="FuelHandler.performShuffle">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.performShuffle">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">performShuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shuffleFile</span><span class="p">,</span> <span class="n">yaml</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute shuffling instructions from a previous run or YAML file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shuffleFile : str</span>
<span class="sd">            Path to the shuffle sequence file.</span>
<span class="sd">        yaml : bool, optional</span>
<span class="sd">            If True, interpret ``shuffleFile`` as a YAML shuffle sequence.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moved : list</span>
<span class="sd">            List of assemblies that moved this cycle.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Typically the shuffle file from a previous run will be ``caseTitle``-&quot;SHUFFLES.txt&quot;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        doRepeatShuffle : Performs moves as processed by this method</span>
<span class="sd">        processMoveList : Converts a stored list of moves into a functional list of assemblies to swap</span>
<span class="sd">        makeShuffleReport : Creates the file that is processed here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># read moves file</span>
        <span class="k">if</span> <span class="n">yaml</span><span class="p">:</span>
            <span class="n">moves</span><span class="p">,</span> <span class="n">swaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readMovesYaml</span><span class="p">(</span><span class="n">shuffleFile</span><span class="p">)</span>
            <span class="n">cycle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cycle</span>
            <span class="k">if</span> <span class="n">cycle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if cycle is 0, we are at the beginning of the first cycle</span>
                <span class="c1"># this is a special case where we don&#39;t have any moves</span>
                <span class="c1"># so we return an empty list</span>
                <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">moves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readMoves</span><span class="p">(</span><span class="n">shuffleFile</span><span class="p">)</span>
            <span class="n">swaps</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># get the correct cycle number</span>
            <span class="c1"># +1 since cycles starts on 0 and looking for the end of 1st cycle shuffle</span>
            <span class="n">cycle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cycle</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># setup the load and loop chains to be run per cycle</span>
        <span class="n">moveList</span> <span class="o">=</span> <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span>
        <span class="n">swapList</span> <span class="o">=</span> <span class="n">swaps</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">moveData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processMoveList</span><span class="p">(</span><span class="n">moveList</span><span class="p">)</span>

        <span class="c1"># Now have the move locations</span>
        <span class="n">moved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doRepeatShuffle</span><span class="p">(</span>
            <span class="n">moveData</span><span class="o">.</span><span class="n">loadChains</span><span class="p">,</span>
            <span class="n">moveData</span><span class="o">.</span><span class="n">loopChains</span><span class="p">,</span>
            <span class="n">moveData</span><span class="o">.</span><span class="n">enriches</span><span class="p">,</span>
            <span class="n">moveData</span><span class="o">.</span><span class="n">loadChargeTypes</span><span class="p">,</span>
            <span class="n">moveData</span><span class="o">.</span><span class="n">loadNames</span><span class="p">,</span>
            <span class="n">moveData</span><span class="o">.</span><span class="n">dischargeDests</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Apply any swaps after performing cascades</span>
        <span class="k">for</span> <span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span> <span class="ow">in</span> <span class="n">swapList</span><span class="p">:</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblyWithStringLocation</span><span class="p">(</span><span class="n">loc1</span><span class="p">)</span>
            <span class="n">a2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblyWithStringLocation</span><span class="p">(</span><span class="n">loc2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">a2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not perform swap between </span><span class="si">{</span><span class="n">loc1</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">loc2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">swapAssemblies</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
            <span class="n">moved</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pendingRotations</span> <span class="o">=</span> <span class="n">moveData</span><span class="o">.</span><span class="n">rotations</span>

        <span class="k">return</span> <span class="n">moved</span></div>


<div class="viewcode-block" id="FuelHandler.readMoves">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.readMoves">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">readMoves</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads a shuffle output file and sets up the moves dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            The shuffles file to read</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moves : dict</span>
<span class="sd">            A dictionary of all the moves. Keys are the cycle number. Values are a list</span>
<span class="sd">            of :class:`~armi.physics.fuelCycle.fuelHandlers.AssemblyMove` objects, one for each individual</span>
<span class="sd">            move that happened in the cycle. ``oldLoc`` and ``newLoc`` are string</span>
<span class="sd">            representations of the locations and ``enrichList`` is a list of mass</span>
<span class="sd">            enrichments from bottom to top.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        performShuffle : reads this file and executes the shuffling</span>
<span class="sd">        outage : creates the moveList in the first place.</span>
<span class="sd">        makeShuffleReport : writes the file that is read here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Could not find/open repeat shuffle file </span><span class="si">{}</span><span class="s2"> in working directory </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>
            <span class="p">)</span>

        <span class="n">moves</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">numMoves</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;ycle&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="c1"># Used to say &quot;Cycle 1 at 0.0 years&quot;. Now says: &quot;Before cycle 1 at 0.0 years&quot; to be more specific.</span>
                <span class="c1"># This RE allows backwards compatibility.</span>
                <span class="c1"># Later, we removed the at x years</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;ycle (\d+)&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">elif</span> <span class="s2">&quot;assembly&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="c1"># this is the new load style where an actual assembly type is written to the shuffle logic</span>
                <span class="c1"># due to legacy reasons, the assembly type will be put into group 4</span>
                <span class="n">pat</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">r</span><span class="s2">&quot;([A-Za-z0-9!\-]+) moved to ([A-Za-z0-9!\-]+) with assembly type &quot;</span>
                    <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;([A-Za-z0-9!\s]+)\s*(ANAME=\S+)?\s*with enrich list: (.+)&quot;</span>
                <span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s1">&#39;Failed to parse line &quot;</span><span class="si">{0}</span><span class="s1">&quot; in shuffle file&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
                <span class="n">oldLoc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">newLoc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">assemType</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>  <span class="c1"># take off any possible trailing whitespace</span>
                <span class="n">nameAtDischarge</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># will be None for legacy shuffleLogic files. (pre 2013-08)</span>
                <span class="k">if</span> <span class="n">nameAtDischarge</span><span class="p">:</span>
                    <span class="n">nameAtDischarge</span> <span class="o">=</span> <span class="n">nameAtDischarge</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># extract the actual assembly name.</span>
                <span class="n">enrichList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AssemblyMove</span><span class="p">(</span><span class="n">oldLoc</span><span class="p">,</span> <span class="n">newLoc</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">nameAtDischarge</span><span class="p">))</span>
                <span class="n">numMoves</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="s2">&quot;moved&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="c1"># very old shuffleLogic file.</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Using old *.SHUFFLES.txt loading file&quot;</span><span class="p">,</span>
                    <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Using old shuffles file&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
                    <span class="s2">&quot;([A-Za-z0-9!]+) moved to ([A-Za-z0-9!]+) with enrich list: (.+)&quot;</span><span class="p">,</span>
                    <span class="n">line</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s1">&#39;Failed to parse line &quot;</span><span class="si">{0}</span><span class="s1">&quot; in shuffle file&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
                <span class="n">oldLoc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">newLoc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">enrichList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                <span class="c1"># old loading style, just assume that there is a booster as our surrogate</span>
                <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AssemblyMove</span><span class="p">(</span><span class="n">oldLoc</span><span class="p">,</span> <span class="n">newLoc</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">))</span>
                <span class="n">numMoves</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Read </span><span class="si">{0}</span><span class="s2"> moves over </span><span class="si">{1}</span><span class="s2"> cycles&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numMoves</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">moves</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="k">return</span> <span class="n">moves</span></div>


<div class="viewcode-block" id="FuelHandler.readMovesYaml">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.readMovesYaml">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">readMovesYaml</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a shuffle file in YAML format.</span>

<span class="sd">        A cascade with no explicit final location deletes the assembly</span>
<span class="sd">        by default.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            Path to the YAML-formatted shuffle file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moves : dict</span>
<span class="sd">            Mapping of cycle numbers to lists of</span>
<span class="sd">            :class:`~armi.physics.fuelCycle.fuelHandlers.AssemblyMove` objects that</span>
<span class="sd">            describe the shuffle sequence.</span>
<span class="sd">        swaps : dict</span>
<span class="sd">            Mapping of cycle numbers to lists of location-pair tuples describing</span>
<span class="sd">            assemblies to be swapped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1. load YAML file</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
                <span class="n">yaml</span> <span class="o">=</span> <span class="n">YAML</span><span class="p">(</span><span class="n">typ</span><span class="o">=</span><span class="s2">&quot;safe&quot;</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">DuplicateKeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">ee</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Could not find/open repeat shuffle file </span><span class="si">{</span><span class="n">fname</span><span class="si">!r}</span><span class="s2"> in working directory </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">ee</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">ee</span>

        <span class="c1"># 2. perform various validation tests on the YAML data</span>
        <span class="k">if</span> <span class="s2">&quot;sequence&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s2">&quot;Shuffle YAML missing required &#39;sequence&#39; mapping&quot;</span><span class="p">)</span>

        <span class="n">moves</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">swaps</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="c1"># cycles may be provided in any order; verify only that there are no gaps</span>
        <span class="n">cycleNums</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sequence&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="k">if</span> <span class="n">cycleNums</span><span class="p">:</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">cycleNums</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">cycleNums</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">expected</span> <span class="o">-</span> <span class="n">cycleNums</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing cycle </span><span class="si">{</span><span class="n">missing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> in shuffle sequence&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing cycles </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2"> in shuffle sequence&quot;</span><span class="p">)</span>

        <span class="c1"># 3. parse YAML file into shuffle data</span>
        <span class="k">for</span> <span class="n">cycleKey</span><span class="p">,</span> <span class="n">actions</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sequence&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">cycle</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cycleKey</span><span class="p">)</span>
            <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">seenLocs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">actions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cycle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cycle </span><span class="si">{</span><span class="n">cycleKey</span><span class="si">}</span><span class="s2"> has no shuffle actions defined, skipping.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">cycle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span>
                    <span class="s2">&quot;Cycle 0 is not allowed in shuffle YAML. &quot;</span>
                    <span class="s2">&quot;This cycle is reserved for the initial core loading.&quot;</span>
                    <span class="s2">&quot;Shuffling is available at the beginning of cycle 1&quot;</span>
                <span class="p">)</span>

            <span class="k">for</span> <span class="n">action</span> <span class="ow">in</span> <span class="n">actions</span><span class="p">:</span>
                <span class="n">allowed</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;cascade&quot;</span><span class="p">,</span> <span class="s2">&quot;fuelEnrichment&quot;</span><span class="p">,</span> <span class="s2">&quot;extraRotations&quot;</span><span class="p">,</span> <span class="s2">&quot;swap&quot;</span><span class="p">,</span> <span class="s2">&quot;assemblyName&quot;</span><span class="p">}</span>
                <span class="n">unknown</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="o">-</span> <span class="n">allowed</span>
                <span class="k">if</span> <span class="n">unknown</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown action keys </span><span class="si">{</span><span class="n">unknown</span><span class="si">}</span><span class="s2"> in shuffle YAML&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="s2">&quot;cascade&quot;</span> <span class="ow">in</span> <span class="n">action</span><span class="p">:</span>
                    <span class="n">chain</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="s2">&quot;cascade&quot;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s2">&quot;cascade must contain at least two entries&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s2">&quot;cascade entries must be strings&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">chain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SFP&quot;</span><span class="p">:</span>
                        <span class="c1"># move an assembly from the SFP into the Core</span>
                        <span class="n">assemType</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">locs</span> <span class="o">=</span> <span class="n">chain</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s2">&quot;cascade starting with SFP must include a destination location&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># move an assembly around the Core</span>
                        <span class="n">assemType</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">locs</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">locs</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s2">&quot;cascade must contain at least one location after the assembly type&quot;</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">locs</span><span class="p">:</span>
                        <span class="n">FuelHandler</span><span class="o">.</span><span class="n">validateLoc</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">cycle</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">loc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">DISCHARGE_LOCS</span> <span class="ow">and</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">seenLocs</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Location </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2"> appears in multiple cascades in cycle </span><span class="si">{</span><span class="n">cycle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">seenLocs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>

                    <span class="n">enrich</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">enrichList</span> <span class="o">=</span> <span class="n">action</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fuelEnrichment&quot;</span><span class="p">,</span> <span class="p">[])</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">enrich</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">enrichList</span><span class="p">]</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s2">&quot;fuelEnrichment values must be numeric. Got </span><span class="si">{enrichList}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">e</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">enrich</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s2">&quot;fuelEnrichment values must be between 0 and 1. Got </span><span class="si">{enrich}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">assemblyName</span> <span class="o">=</span> <span class="n">action</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;assemblyName&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">locs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SFP&quot;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">assemblyName</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s2">&quot;assemblyName required when loading from SFP&quot;</span><span class="p">)</span>
                        <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AssemblyMove</span><span class="p">(</span><span class="s2">&quot;SFP&quot;</span><span class="p">,</span> <span class="n">locs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[],</span> <span class="kc">None</span><span class="p">,</span> <span class="n">assemblyName</span><span class="p">))</span>
                        <span class="n">startIdx</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">assemblyName</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s2">&quot;assemblyName is only valid when loading from SFP&quot;</span><span class="p">)</span>
                        <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AssemblyMove</span><span class="p">(</span><span class="s2">&quot;LoadQueue&quot;</span><span class="p">,</span> <span class="n">locs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">enrich</span><span class="p">,</span> <span class="n">assemType</span><span class="p">))</span>
                        <span class="n">startIdx</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startIdx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AssemblyMove</span><span class="p">(</span><span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">locs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">locs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">DISCHARGE_LOCS</span><span class="p">:</span>
                        <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AssemblyMove</span><span class="p">(</span><span class="n">locs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Delete&quot;</span><span class="p">))</span>

                <span class="k">elif</span> <span class="s2">&quot;swap&quot;</span> <span class="ow">in</span> <span class="n">action</span><span class="p">:</span>
                    <span class="n">swap</span> <span class="o">=</span> <span class="n">action</span><span class="p">[</span><span class="s2">&quot;swap&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">swap</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">swap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s2">&quot;swap must be a list of two location labels, got </span><span class="si">{swap}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">swap</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="s2">&quot;swap entries must be strings, got </span><span class="si">{swap}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">swap</span><span class="p">:</span>
                        <span class="n">FuelHandler</span><span class="o">.</span><span class="n">validateLoc</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">cycle</span><span class="p">)</span>
                    <span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span> <span class="o">=</span> <span class="n">swap</span>
                    <span class="n">swaps</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">loc1</span><span class="p">,</span> <span class="n">loc2</span><span class="p">))</span>

                <span class="k">elif</span> <span class="s2">&quot;extraRotations&quot;</span> <span class="ow">in</span> <span class="n">action</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">loc</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">action</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;extraRotations&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">FuelHandler</span><span class="o">.</span><span class="n">validateLoc</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">cycle</span><span class="p">)</span>
                        <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AssemblyMove</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">angle</span><span class="p">)))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to process </span><span class="si">{</span><span class="n">action</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">cycle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">moves</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">swaps</span><span class="p">)</span></div>


<div class="viewcode-block" id="FuelHandler.trackChain">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.trackChain">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">trackChain</span><span class="p">(</span><span class="n">moveList</span><span class="p">,</span> <span class="n">startingAt</span><span class="p">,</span> <span class="n">alreadyDone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a chain of locations based on starting location.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Takes a moveList and extracts chains. Remembers all it touches.</span>
<span class="sd">        If A moved to B, C moved to D, and B moved to C, this returns</span>
<span class="sd">        A, B, C ,D.</span>

<span class="sd">        Used in some monte carlo physics writers and in performShuffle</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moveList : list</span>
<span class="sd">            a list of :class:`~armi.physics.fuelCycle.fuelHandlers.AssemblyMove`</span>
<span class="sd">            objects that occurred at a single outage.</span>

<span class="sd">        startingAt : str</span>
<span class="sd">            A location label where the chain would start. This is important because the discharge</span>
<span class="sd">            moves are built when the SFP is found in a move. This method must find all</span>
<span class="sd">            assemblies in the chain leading up to this particular discharge.</span>

<span class="sd">        alreadyDone : list</span>
<span class="sd">            A list of locations that have already been tracked.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        chain : list</span>
<span class="sd">            The chain as a location list in order</span>
<span class="sd">        enrich : list</span>
<span class="sd">            The axial enrichment distribution of the load assembly.</span>
<span class="sd">        loadName : str</span>
<span class="sd">            The assembly name of the load assembly</span>
<span class="sd">        destination : str</span>
<span class="sd">            Location where the first assembly in the chain is discharged</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        performShuffle</span>
<span class="sd">        processMoveList</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">alreadyDone</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alreadyDone</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">enrich</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># in case this is a load chain, prep for getting enrich.</span>
        <span class="n">loadName</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">assemType</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># in case this is a load chain, prep for getting an assembly type</span>
        <span class="n">destination</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">move</span> <span class="ow">in</span> <span class="n">moveList</span><span class="p">:</span>
            <span class="n">fromLoc</span> <span class="o">=</span> <span class="n">move</span><span class="o">.</span><span class="n">fromLoc</span>
            <span class="n">toLoc</span> <span class="o">=</span> <span class="n">move</span><span class="o">.</span><span class="n">toLoc</span>
            <span class="k">if</span> <span class="n">toLoc</span> <span class="ow">in</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">DISCHARGE_LOCS</span> <span class="ow">and</span> <span class="s2">&quot;LoadQueue&quot;</span> <span class="ow">in</span> <span class="n">fromLoc</span><span class="p">:</span>
                <span class="c1"># skip dummy moves</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">fromLoc</span><span class="p">,</span> <span class="n">toLoc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">alreadyDone</span><span class="p">:</span>
                <span class="c1"># skip this pair</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">startingAt</span> <span class="ow">in</span> <span class="n">fromLoc</span><span class="p">:</span>
                <span class="c1"># looking for chain involving toLoc</span>
                <span class="c1"># back-track the chain of moves</span>
                <span class="n">chain</span> <span class="o">=</span> <span class="p">[</span><span class="n">fromLoc</span><span class="p">]</span>
                <span class="n">destination</span> <span class="o">=</span> <span class="n">toLoc</span>
                <span class="n">safeCount</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># to break out of crazy loops.</span>
                <span class="n">complete</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">while</span> <span class="p">(</span>
                    <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">({</span><span class="s2">&quot;LoadQueue&quot;</span><span class="p">}</span> <span class="o">|</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">DISCHARGE_LOCS</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">complete</span> <span class="ow">and</span> <span class="n">safeCount</span> <span class="o">&lt;</span> <span class="mi">100</span>
                <span class="p">):</span>
                    <span class="c1"># look for something going to where the previous one is from</span>
                    <span class="n">lookingFor</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">innerMove</span> <span class="ow">in</span> <span class="n">moveList</span><span class="p">:</span>
                        <span class="n">cFromLoc</span> <span class="o">=</span> <span class="n">innerMove</span><span class="o">.</span><span class="n">fromLoc</span>
                        <span class="n">cToLoc</span> <span class="o">=</span> <span class="n">innerMove</span><span class="o">.</span><span class="n">toLoc</span>
                        <span class="n">cEnrichList</span> <span class="o">=</span> <span class="n">innerMove</span><span class="o">.</span><span class="n">enrichList</span>
                        <span class="n">cAssemblyType</span> <span class="o">=</span> <span class="n">innerMove</span><span class="o">.</span><span class="n">assemType</span>
                        <span class="n">cAssemName</span> <span class="o">=</span> <span class="n">innerMove</span><span class="o">.</span><span class="n">nameAtDischarge</span>
                        <span class="k">if</span> <span class="n">cToLoc</span> <span class="o">==</span> <span class="n">lookingFor</span><span class="p">:</span>
                            <span class="n">chain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cFromLoc</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">cFromLoc</span> <span class="ow">in</span> <span class="p">({</span><span class="s2">&quot;LoadQueue&quot;</span><span class="p">}</span> <span class="o">|</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">DISCHARGE_LOCS</span><span class="p">):</span>
                                <span class="c1"># charge-discharge loop complete.</span>
                                <span class="n">enrich</span> <span class="o">=</span> <span class="n">cEnrichList</span>
                                <span class="n">loadName</span> <span class="o">=</span> <span class="n">cAssemName</span>
                                <span class="n">assemType</span> <span class="o">=</span> <span class="n">cAssemblyType</span>
                            <span class="c1"># break after finding the first predecessor to avoid duplicates</span>
                            <span class="k">break</span>

                    <span class="k">if</span> <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">startingAt</span><span class="p">:</span>
                        <span class="c1"># non-charging loop complete</span>
                        <span class="n">complete</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="n">safeCount</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">safeCount</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Chain tracking got too long. Check moves.</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chain</span><span class="p">))</span>

                <span class="c1"># delete the last item, it&#39;s loadqueue location or the startingFrom</span>
                <span class="c1"># location.</span>
                <span class="n">chain</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

                <span class="c1"># chain tracked. Can jump out of loop early.</span>
                <span class="k">return</span> <span class="n">chain</span><span class="p">,</span> <span class="n">enrich</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">loadName</span><span class="p">,</span> <span class="n">destination</span>

        <span class="c1"># if we get here, the startingAt location was not found.</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No chain found starting at </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">startingAt</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="n">enrich</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">loadName</span><span class="p">,</span> <span class="n">destination</span></div>


<div class="viewcode-block" id="FuelHandler.processMoveList">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.processMoveList">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">processMoveList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moveList</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ProcessMoveListResult</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Processes a move list and extracts fuel management loops and charges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moveList : list</span>
<span class="sd">            A list of :class:`~armi.physics.fuelCycle.fuelHandlers.AssemblyMove` objects describing each</span>
<span class="sd">            move.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ProcessMoveListResult</span>
<span class="sd">            Structured information describing the move chains, enrichment</span>
<span class="sd">            distributions, and other shuffle data. Attributes include:</span>

<span class="sd">            loadChains : list[list[str]]</span>
<span class="sd">                Moves that include discharges.</span>
<span class="sd">            loopChains : list[list[str]]</span>
<span class="sd">                Moves without discharges.</span>
<span class="sd">            enriches : list[list[float]]</span>
<span class="sd">                Axial enrichment distribution for each load assembly.</span>
<span class="sd">            loadChargeTypes : list[Optional[str]]</span>
<span class="sd">                Assembly types for each load chain.</span>
<span class="sd">            loadNames : list[Optional[str]]</span>
<span class="sd">                Assembly names of loads (e.g., from SFP).</span>
<span class="sd">            dischargeDests : list[str]</span>
<span class="sd">                Final destinations for discharged assemblies (e.g., ``SFP`` or ``Delete``).</span>
<span class="sd">            rotations : list[tuple[str, float]]</span>
<span class="sd">                Manual rotations to apply (location, degrees).</span>
<span class="sd">            alreadyDone : list[str]</span>
<span class="sd">                Locations already processed while tracking chains.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Used in some Monte Carlo interfaces to convert ARMI moves to their format moves. Also used in</span>
<span class="sd">        repeat shuffling.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        makeShuffleReport : writes the file that is being processed</span>
<span class="sd">        performShuffle : uses this to repeat shuffles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alreadyDone</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">loadChains</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># moves that have discharges</span>
        <span class="n">loadChargeTypes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the assembly types (str) to be used in a load chain.</span>
        <span class="n">loopChains</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># moves that don&#39;t have discharges</span>
        <span class="n">enriches</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># enrichments of each loadChain</span>
        <span class="n">loadNames</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># assembly name of each load assembly (to read from SFP)</span>
        <span class="n">dischargeDests</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># final destinations for discharged assemblies</span>
        <span class="n">rotations</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># first handle all charge/discharge chains by looking for things going to SFP/Delete</span>
        <span class="k">for</span> <span class="n">move</span> <span class="ow">in</span> <span class="n">moveList</span><span class="p">:</span>
            <span class="n">fromLoc</span> <span class="o">=</span> <span class="n">move</span><span class="o">.</span><span class="n">fromLoc</span>
            <span class="n">toLoc</span> <span class="o">=</span> <span class="n">move</span><span class="o">.</span><span class="n">toLoc</span>
            <span class="n">rot</span> <span class="o">=</span> <span class="n">move</span><span class="o">.</span><span class="n">rotation</span>
            <span class="k">if</span> <span class="n">fromLoc</span> <span class="o">==</span> <span class="n">toLoc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">fromLoc</span><span class="p">,</span> <span class="n">rot</span><span class="p">))</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">toLoc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DISCHARGE_LOCS</span> <span class="ow">and</span> <span class="s2">&quot;LoadQueue&quot;</span> <span class="ow">in</span> <span class="n">fromLoc</span><span class="p">:</span>
                <span class="c1"># skip dummy moves</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">toLoc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DISCHARGE_LOCS</span><span class="p">:</span>
                <span class="c1"># discharge. Track chain.</span>
                <span class="n">chain</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">loadAssemName</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">trackChain</span><span class="p">(</span><span class="n">moveList</span><span class="p">,</span> <span class="n">startingAt</span><span class="o">=</span><span class="n">fromLoc</span><span class="p">)</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Load Chain with load assem </span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">assemType</span><span class="p">,</span> <span class="n">chain</span><span class="p">))</span>
                <span class="n">loadChains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
                <span class="n">enriches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">enrichList</span><span class="p">)</span>
                <span class="n">loadChargeTypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assemType</span><span class="p">)</span>
                <span class="n">loadNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loadAssemName</span><span class="p">)</span>
                <span class="n">dischargeDests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
                <span class="c1"># track all the locations we saw already so we</span>
                <span class="c1"># don&#39;t use them in the loop moves.</span>
                <span class="n">alreadyDone</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>

        <span class="c1"># go through again, looking for stuff that isn&#39;t in chains.</span>
        <span class="c1"># put them in loop type 3 moves (arbitrary order)</span>
        <span class="k">for</span> <span class="n">move</span> <span class="ow">in</span> <span class="n">moveList</span><span class="p">:</span>
            <span class="n">fromLoc</span> <span class="o">=</span> <span class="n">move</span><span class="o">.</span><span class="n">fromLoc</span>
            <span class="n">toLoc</span> <span class="o">=</span> <span class="n">move</span><span class="o">.</span><span class="n">toLoc</span>
            <span class="k">if</span> <span class="n">fromLoc</span> <span class="o">==</span> <span class="n">toLoc</span><span class="p">:</span>
                <span class="c1"># rotation or no-op</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">toLoc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DISCHARGE_LOCS</span> <span class="ow">or</span> <span class="n">fromLoc</span> <span class="ow">in</span> <span class="p">({</span><span class="s2">&quot;LoadQueue&quot;</span><span class="p">}</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">DISCHARGE_LOCS</span><span class="p">):</span>
                <span class="c1"># skip loads/discharges; they&#39;re already done.</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">fromLoc</span> <span class="ow">in</span> <span class="n">alreadyDone</span><span class="p">:</span>
                <span class="c1"># skip repeats</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># normal move</span>
                <span class="n">chain</span><span class="p">,</span> <span class="n">_enrichList</span><span class="p">,</span> <span class="n">_assemType</span><span class="p">,</span> <span class="n">_loadAssemName</span><span class="p">,</span> <span class="n">_dest</span> <span class="o">=</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">trackChain</span><span class="p">(</span>
                    <span class="n">moveList</span><span class="p">,</span> <span class="n">startingAt</span><span class="o">=</span><span class="n">fromLoc</span>
                <span class="p">)</span>
                <span class="n">loopChains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
                <span class="n">alreadyDone</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>

                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Loop Chain: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chain</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ProcessMoveListResult</span><span class="p">(</span>
            <span class="n">loadChains</span><span class="o">=</span><span class="n">loadChains</span><span class="p">,</span>
            <span class="n">loopChains</span><span class="o">=</span><span class="n">loopChains</span><span class="p">,</span>
            <span class="n">enriches</span><span class="o">=</span><span class="n">enriches</span><span class="p">,</span>
            <span class="n">loadChargeTypes</span><span class="o">=</span><span class="n">loadChargeTypes</span><span class="p">,</span>
            <span class="n">loadNames</span><span class="o">=</span><span class="n">loadNames</span><span class="p">,</span>
            <span class="n">dischargeDests</span><span class="o">=</span><span class="n">dischargeDests</span><span class="p">,</span>
            <span class="n">rotations</span><span class="o">=</span><span class="n">rotations</span><span class="p">,</span>
            <span class="n">alreadyDone</span><span class="o">=</span><span class="n">alreadyDone</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="FuelHandler.doRepeatShuffle">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.doRepeatShuffle">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">doRepeatShuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadChains</span><span class="p">,</span> <span class="n">loopChains</span><span class="p">,</span> <span class="n">enriches</span><span class="p">,</span> <span class="n">loadChargeTypes</span><span class="p">,</span> <span class="n">loadNames</span><span class="p">,</span> <span class="n">dischargeDests</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Actually does the fuel movements required to repeat a shuffle order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loadChains : list</span>
<span class="sd">            list of lists of location labels for each load chain (with charge/discharge)</span>
<span class="sd">        loopChains : list</span>
<span class="sd">            list of lists of location labels for each loop chain (no charge/discharge)</span>
<span class="sd">        enriches : list</span>
<span class="sd">            The block enrichment distribution of each load assembly</span>
<span class="sd">        loadChargeTypes :list</span>
<span class="sd">            The types of assemblies that get charged.</span>
<span class="sd">        loadNames : list</span>
<span class="sd">            The assembly names of assemblies that get brought into the core (useful for pulling out</span>
<span class="sd">            of SFP for round 2, etc.)</span>
<span class="sd">        dischargeDests : list</span>
<span class="sd">            Final destination for each load chain (e.g., ``SFP`` or ``Delete``)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        performShuffle  : coordinates the moves for this cycle</span>
<span class="sd">        processMoveList : builds the input lists</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a helper function for performShuffle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">moved</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># shuffle all of the load chain assemblies (These include discharges to SFP</span>
        <span class="c1"># and loads from Loadqueue)</span>

        <span class="c1"># build a lookup table of locations throughout the current core and cache it.</span>
        <span class="n">locContents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">makeLocationLookup</span><span class="p">(</span><span class="n">assemblyLevel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># perform load swaps (with charge/discharge)</span>
        <span class="k">for</span> <span class="n">assemblyChain</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="n">assemblyType</span><span class="p">,</span> <span class="n">assemblyName</span><span class="p">,</span> <span class="n">dest</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">loadChains</span><span class="p">,</span> <span class="n">enriches</span><span class="p">,</span> <span class="n">loadChargeTypes</span><span class="p">,</span> <span class="n">loadNames</span><span class="p">,</span> <span class="n">dischargeDests</span>
        <span class="p">):</span>
            <span class="c1"># convert the labels into actual assemblies to be swapped</span>
            <span class="n">assemblyList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getLocationContents</span><span class="p">(</span><span class="n">assemblyChain</span><span class="p">,</span> <span class="n">assemblyLevel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">locContents</span><span class="o">=</span><span class="n">locContents</span><span class="p">)</span>

            <span class="n">moved</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">)</span>

            <span class="c1"># go through and swap the assemblies knowing that there is a discharge (first one)</span>
            <span class="c1"># and a new assembly brought it (last one)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">swapAssemblies</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Now, everything has been set except the first assembly in the list, which must now be</span>
            <span class="c1"># replaced with a fresh assembly... but which one? The assemblyType string</span>
            <span class="c1"># tells us.</span>
            <span class="c1"># Sometimes enrichment is set on-the-fly by branch searches, so we must</span>
            <span class="c1"># not only use the proper assembly type but also adjust the enrichment.</span>
            <span class="k">if</span> <span class="n">assemblyName</span><span class="p">:</span>
                <span class="c1"># get this assembly from the SFP</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">excore</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sfp&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">loadAssembly</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">loadAssembly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">excore</span><span class="p">[</span><span class="s2">&quot;sfp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">getAssembly</span><span class="p">(</span><span class="n">assemblyName</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">loadAssembly</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The required assembly </span><span class="si">{</span><span class="n">assemblyName</span><span class="si">}</span><span class="s2"> is not found in the SFP.&quot;</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># create a new assembly from the BOL assem templates and adjust the enrichment</span>
                <span class="n">loadAssembly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">createAssemblyOfType</span><span class="p">(</span><span class="n">enrichList</span><span class="o">=</span><span class="n">enrichList</span><span class="p">,</span> <span class="n">assemType</span><span class="o">=</span><span class="n">assemblyType</span><span class="p">)</span>

            <span class="c1"># replace the goingOut guy (for continual feed cases)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Calling discharge swap with </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">loadAssembly</span><span class="p">,</span> <span class="n">assemblyList</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dischargeSwap</span><span class="p">(</span><span class="n">loadAssembly</span><span class="p">,</span> <span class="n">assemblyList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">toSfp</span><span class="o">=</span><span class="p">(</span><span class="n">dest</span> <span class="o">==</span> <span class="s2">&quot;SFP&quot;</span><span class="p">))</span>
            <span class="n">moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loadAssembly</span><span class="p">)</span>

        <span class="c1"># shuffle all of the loop chain assemblies (no charge/discharge)</span>

        <span class="k">for</span> <span class="n">assemblyChain</span> <span class="ow">in</span> <span class="n">loopChains</span><span class="p">:</span>
            <span class="c1"># convert the labels into actual assemblies to be swapped</span>
            <span class="n">assemblyList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getLocationContents</span><span class="p">(</span><span class="n">assemblyChain</span><span class="p">,</span> <span class="n">assemblyLevel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">locContents</span><span class="o">=</span><span class="n">locContents</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblyList</span><span class="p">:</span>
                <span class="n">moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="c1"># go through and swap the assemblies knowing that there is a discharge (first one)</span>
            <span class="c1"># and a new assembly brought it (last one)</span>
            <span class="c1"># for i in range(0,-(len(assemblyList)-1),-1):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">swapAssemblies</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">moved</span></div>


<div class="viewcode-block" id="FuelHandler.workerOperate">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.workerOperate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">workerOperate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmd</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handle a mpi command on the worker nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="FuelHandler.prepShuffleMap">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.prepShuffleMap">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepShuffleMap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare a table of current locations for plotting shuffle maneuvers.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oldLocations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">oldLocations</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">getName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span></div>


<div class="viewcode-block" id="FuelHandler.makeShuffleArrows">
<a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.makeShuffleArrows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">makeShuffleArrows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build data for plotting all the previous shuffles as arrows.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arrows : list</span>
<span class="sd">            Values are (currentCoords, oldCoords) tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arrows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Building list of shuffle arrows.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="p">:</span>
            <span class="n">currentCoords</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span>
            <span class="n">oldCoords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oldLocations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">oldCoords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">oldCoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">currentCoords</span> <span class="o">!=</span> <span class="n">oldCoords</span><span class="p">):</span>
                <span class="n">arrows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">oldCoords</span><span class="p">,</span> <span class="n">currentCoords</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">arrows</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2009-2026, TerraPower, LLC.
      <span class="lastupdated">Last updated on 2026-01-21.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>armi.physics.fuelCycle.fuelHandlers &mdash; ARMI 0.2.8 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme_fixes.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/assets/jsonview.bundle.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sphinx-needs/libs/html/datatables.min.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sphinx-needs/common.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sphinx-needs/layouts.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sphinx-needs/styles.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sphinx-needs/modern.css" type="text/css" />
    <link rel="shortcut icon" href="../../../../_static/armiicon_16x16.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="../../../../_static/assets/jsonview.bundle.js"></script>
        <script src="../../../../_static/assets/jsonview_loader.js"></script>
        <script src="../../../../_static/sphinx-needs/libs/html/datatables.min.js"></script>
        <script src="../../../../_static/sphinx-needs/libs/html/datatables_loader.js"></script>
        <script src="../../../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            ARMI
              <img src="../../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.2.8
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../.apidocs/modules.html">API Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #233C5B" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ARMI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../../armi.html">armi</a></li>
          <li class="breadcrumb-item"><a href="../fuelCycle.html">armi.physics.fuelCycle</a></li>
      <li class="breadcrumb-item active">armi.physics.fuelCycle.fuelHandlers</li>
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for armi.physics.fuelCycle.fuelHandlers</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module handles fuel management operations such as shuffling, rotation, and</span>
<span class="sd">fuel processing (in fluid systems).</span>

<span class="sd">The :py:class:`FuelHandlerInterface` instantiates a ``FuelHandler``, which is typically a user-defined</span>
<span class="sd">subclass the :py:class:`FuelHandler` object in custom shuffle-logic input files.</span>
<span class="sd">Users point to the code modules with their custom fuel handlers using the</span>
<span class="sd">``shuffleLogic`` and ``fuelHandlerName`` settings, as described in :doc:`/user/inputs/fuel_management`.</span>
<span class="sd">These subclasses override ``chooseSwaps`` that determine</span>
<span class="sd">the particular shuffling of a case.</span>

<span class="sd">This module also handles repeat shuffles when doing a restart.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># ruff: noqa: F401</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">runLog</span>
<span class="kn">from</span> <span class="nn">armi.physics.fuelCycle</span> <span class="kn">import</span> <span class="n">assemblyRotationAlgorithms</span> <span class="k">as</span> <span class="n">rotAlgos</span>
<span class="kn">from</span> <span class="nn">armi.physics.fuelCycle.fuelHandlerFactory</span> <span class="kn">import</span> <span class="n">fuelHandlerFactory</span>
<span class="kn">from</span> <span class="nn">armi.physics.fuelCycle.fuelHandlerInterface</span> <span class="kn">import</span> <span class="n">FuelHandlerInterface</span>
<span class="kn">from</span> <span class="nn">armi.physics.fuelCycle.settings</span> <span class="kn">import</span> <span class="n">CONF_ASSEMBLY_ROTATION_ALG</span>
<span class="kn">from</span> <span class="nn">armi.reactor.flags</span> <span class="kn">import</span> <span class="n">Flags</span>
<span class="kn">from</span> <span class="nn">armi.utils.customExceptions</span> <span class="kn">import</span> <span class="n">InputError</span>


<div class="viewcode-block" id="FuelHandler"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler">[docs]</a><span class="k">class</span> <span class="nc">FuelHandler</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A fuel handling machine can move fuel around the core and reactor.</span>

<span class="sd">    It makes decisions on how to shuffle fuel based on user specifications.</span>
<span class="sd">    It provides some supervisory data tracking, such as having the ability</span>
<span class="sd">    to print out information about all moves that happened in a cycle (without</span>
<span class="sd">    the user needing to explicitly track this information).</span>

<span class="sd">    To use this, simply create an input Python file and point to it by path</span>
<span class="sd">    with the ``fuelHandler`` setting. In that file, subclass this object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
        <span class="c1"># we need access to the operator to find the core, get settings, grab</span>
        <span class="c1"># other interfaces, etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">o</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moved</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handleBackwardsCompatibility</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_handleBackwardsCompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># prepSearch used to be part of the API but is deprecated. This will</span>
        <span class="c1"># trigger a warning if it&#39;s implemented.</span>
        <span class="c1"># We have to do this hack until we phase out old inputs.</span>
        <span class="c1"># This basically asks: &quot;Did the custom subclass override prepSearch?&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepSearch</span><span class="o">.</span><span class="vm">__func__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">prepSearch</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepSearch</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Link to the current cycle number.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This retains backwards compatibility with previous fuel handler inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cycle</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Link to the Case Settings object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">cs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Link to the Reactor object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">r</span>

<div class="viewcode-block" id="FuelHandler.outage"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.outage">[docs]</a>    <span class="k">def</span> <span class="nf">outage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulates a reactor reload outage. Moves and tracks fuel.</span>

<span class="sd">        This sets the moveList structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot perform two outages with same FuelHandler instance.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># determine if a repeat shuffle is occurring or a new shuffle pattern</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">]:</span>
            <span class="c1"># repeated shuffle</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Requested repeat shuffle file </span><span class="si">{0}</span><span class="s2"> does not exist. Cannot perform shuffling. &quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span>
                <span class="s2">&quot;Repeating a shuffling pattern from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">repeatShufflePattern</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Normal shuffle from user-provided shuffle logic input</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chooseSwaps</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="c1"># do rotations if pin-level details are available (requires fluxRecon plugin)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;fluxRecon&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_ASSEMBLY_ROTATION_ALG</span><span class="p">]:</span>
            <span class="c1"># Rotate assemblies ONLY IF at least some assemblies have pin detail</span>
            <span class="c1"># The user can choose the algorithm method name directly in the settings</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rotAlgos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_ASSEMBLY_ROTATION_ALG</span><span class="p">]):</span>
                <span class="n">rotationMethod</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rotAlgos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_ASSEMBLY_ROTATION_ALG</span><span class="p">])</span>
                <span class="n">rotationMethod</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;FuelHandler </span><span class="si">{0}</span><span class="s2"> does not have a rotation algorithm called </span><span class="si">{1}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;Change your </span><span class="si">{2}</span><span class="s2"> setting&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">rotAlgos</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">CONF_ASSEMBLY_ROTATION_ALG</span><span class="p">],</span>
                        <span class="n">CONF_ASSEMBLY_ROTATION_ALG</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># inform the reactor of how many moves occurred so it can put the number in the database.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
            <span class="n">numMoved</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span>

            <span class="c1"># tell the reactor which assemblies moved where</span>
            <span class="c1"># also tell enrichments of each block in case there&#39;s some autoboosting going on.</span>
            <span class="c1"># This is also essential for repeating shuffles in later restart runs.</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">setMoveList</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cycle</span><span class="p">,</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">lastLocationLabel</span><span class="p">,</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">(),</span>
                        <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">getUraniumMassEnrich</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">],</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">getType</span><span class="p">(),</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span>
                    <span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="s2">&quot;A fuel management error has occurred. &quot;</span><span class="p">)</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="s2">&quot;Trying operation on assembly </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="s2">&quot;The moved list is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">))</span>
                    <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numMoved</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">numMoves</span> <span class="o">=</span> <span class="n">numMoved</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">setBlockMassParams</span><span class="p">()</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span>
            <span class="s2">&quot;Fuel handler performed </span><span class="si">{0}</span><span class="s2"> assembly shuffles.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numMoved</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># now wipe out the self.moved version so it doesn&#39;t transmit the assemblies during distributeState</span>
        <span class="n">moved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moved</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">moved</span></div>

<div class="viewcode-block" id="FuelHandler.chooseSwaps"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.chooseSwaps">[docs]</a>    <span class="k">def</span> <span class="nf">chooseSwaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shuffleFactors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Moves the fuel around or otherwise processes it between cycles.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="FuelHandler.getFactorList"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.getFactorList">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getFactorList</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fallBack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return factors between 0 and 1 that control fuel management.</span>

<span class="sd">        This is the default shuffle control function. Usually you would override this</span>
<span class="sd">        with your own in a custom shuffleLogic.py file. For more details about how this</span>
<span class="sd">        works, refer to :doc:`/user/inputs/fuel_management`.</span>

<span class="sd">        This will get bound to the default FuelHandler as a static method below. This is</span>
<span class="sd">        done to allow a user to mix and match FuelHandler class implementations and</span>
<span class="sd">        getFactorList implementations at run time.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Ultimately, this approach will likely get replaced using the plugin framework, but</span>
<span class="sd">        we aren&#39;t there yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># prefer to keep these 0 through 1 since this is what the branch search can do.</span>
        <span class="n">defaultFactorList</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;eqShuffles&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="n">factorSearchFlags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">defaultFactorList</span><span class="p">,</span> <span class="n">factorSearchFlags</span></div>

<div class="viewcode-block" id="FuelHandler.prepCore"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.prepCore">[docs]</a>    <span class="k">def</span> <span class="nf">prepCore</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aux function to run before XS generation (do moderation, etc).&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="FuelHandler.prepSearch"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.prepSearch">[docs]</a>    <span class="k">def</span> <span class="nf">prepSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optional method that can be implemented in preparation of shuffling.</span>

<span class="sd">        Often used to prepare the scope of a shuffling branch search.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This was used historically to keep a long-lived fuel handler in sync</span>
<span class="sd">        with the reactor and can now technically be removed from the API, but</span>
<span class="sd">        many historical fuel management inputs still expect it to be called</span>
<span class="sd">        by the framework, so here it remains. New developments should</span>
<span class="sd">        avoid using it. Most code using it has been refactored to just use</span>
<span class="sd">        a ``_prepSearch`` private method.</span>

<span class="sd">        It now should not be used and will trigger a DeprecationWarning</span>
<span class="sd">        in the constructor. It&#39;s still here because old user-input code</span>
<span class="sd">        calls the parent&#39;s prepSearch, which is this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;`FuelHandler.prepSearch` is being deprecated from the framework. Please &quot;</span>
            <span class="s2">&quot;change your fuel management input to call this method directly.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="FuelHandler.findAssembly"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.findAssembly">[docs]</a>    <span class="k">def</span> <span class="nf">findAssembly</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">targetRing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">compareTo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">forceSide</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclusions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mandatoryLocations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">zoneList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">excludedLocations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">minParam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">minVal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxParam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxVal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">findMany</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exactType</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">acceptFirstCandidateRing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">blockLevelMax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">findFromSfp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">maxNumAssems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">circularRingFlag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search reactor for assemblies with various criterion. Primarily for shuffling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        targetRing : int, optional</span>
<span class="sd">            The ring in which to search</span>

<span class="sd">        width : tuple of integers</span>
<span class="sd">            A (size, side) tuple where size is the number of rings on either side to also check.</span>
<span class="sd">            side=1: only look in higher, -1: only look lower, 0: both sides</span>

<span class="sd">        param : string, optional</span>
<span class="sd">            A block (if blockLevelMax) or assem level param name such as &#39;power&#39; or &#39;percentBu&#39;</span>
<span class="sd">            (requires compareTo).</span>

<span class="sd">        compareTo : float or Assembly instance</span>
<span class="sd">            an assembly to be compared to. Alternatively, a floating point number to compare to.</span>
<span class="sd">            Even more alternatively,  an (assembly,mult) or (float,mult) tuple where mult is a</span>
<span class="sd">            multiplier. For example, if you wanted an assembly that had a bu close to half of</span>
<span class="sd">            assembly bob, you&#39;d give param=&#39;percentBu&#39;, compareTo=(bob,0.5) If you want one with a</span>
<span class="sd">            bu close to 0.3, you&#39;d do param=&#39;percentBu&#39;,compareTo=0.3. Yes, if you give a (float,</span>
<span class="sd">            multiplier) tuple, the code will make fun of you for not doing your own math, but will</span>
<span class="sd">            still operate as expected.</span>

<span class="sd">        forceSide : bool, optional</span>
<span class="sd">            requires the found assembly to have either 1: higher, -1: lower, None: any param than</span>
<span class="sd">             compareTo</span>

<span class="sd">        exclusions : list, optional</span>
<span class="sd">            List of assemblies that will be excluded from the search</span>

<span class="sd">        minParam : float or list, optional</span>
<span class="sd">            a parameter to compare to minVal for setting lower bounds. If list, must correspond to</span>
<span class="sd">            parameters in minVal in order.</span>

<span class="sd">        maxParam : float or list, optional</span>
<span class="sd">            a parameter to compare to maxVal for setting upper bounds of acceptable assemblies.</span>
<span class="sd">            If list,</span>
<span class="sd">            must correspond to parameters in maxVal in order.</span>

<span class="sd">        minVal : float or list, optional</span>
<span class="sd">            a value or a (parameter, multiplier) tuple for setting lower bounds</span>

<span class="sd">            For instance, if minParam = &#39;timeToLimit&#39; and minVal=10, only assemblies with</span>
<span class="sd">            timeToLimit higher than 10 will be returned.  (Of course, there is also maxParam and</span>
<span class="sd">            maxVal)</span>

<span class="sd">        maxVal : float or list, optional</span>
<span class="sd">            a value or a (parameter, multiplier) tuple for setting upper bounds</span>

<span class="sd">        mandatoryLocations : list, optional</span>
<span class="sd">            a list of string-representations of locations in the core for limiting the search to</span>
<span class="sd">            several places</span>

<span class="sd">            Any locations also included in `excludedLocations` will be excluded.</span>

<span class="sd">        excludedLocations : list, optional</span>
<span class="sd">            a list of string-representations of locations in the core that will be excluded from</span>
<span class="sd">            the search</span>

<span class="sd">        zoneList : list, optional</span>
<span class="sd">            name of a zone defined in settings.py that will be picked from. Under development</span>

<span class="sd">        findMany : bool, optional</span>
<span class="sd">            If True, will return a list of assembies that match. Don&#39;t give a param.</span>

<span class="sd">        typeSpec : Flags or list of Flags, optional</span>
<span class="sd">            only assemblies with this type list will be returned. If none, only fuel will be found.</span>

<span class="sd">        coords : tuple, optional</span>
<span class="sd">            x,y tuple in cm. the fuel handler will try to find an assembly with a center closest to</span>
<span class="sd">            that point</span>

<span class="sd">        exactType : bool, optional</span>
<span class="sd">            require type to be exactly equal to what&#39;s in the type list. So</span>
<span class="sd">            Flags.IGNITER | Flags.FUEL is not Flags.INNER | Flags.IGNITER | Flags.FUEL</span>

<span class="sd">        acceptFirstCandidateRing : bool, optional</span>
<span class="sd">            takes the first assembly found in the earliest ring (without searching all rings for a</span>
<span class="sd">            maxBu, for example) So if the candidate rings are 1-10 and we&#39;re looking for igniter</span>
<span class="sd">            fuel with a maxBurnup, we don&#39;t get the max burnup in all those rings, but rather the</span>
<span class="sd">            igniter with the max burnup in the ring closest to 1. If there are no igniters until</span>
<span class="sd">            ring 4, you will get an igniter in ring 4.</span>

<span class="sd">        blockLevelMax : bool, optional</span>
<span class="sd">            If true, the param to search for will be built as the maximum block-level param of this</span>
<span class="sd">            name instead of the assembly param. This avoids the need to assign assembly level params</span>
<span class="sd">            sometimes.</span>
<span class="sd">            default: false.</span>

<span class="sd">        findFromSfp : bool, optional</span>
<span class="sd">            if true, will look in the spent-fuel pool instead of in the core.</span>

<span class="sd">        maxNumAssems : int, optional</span>
<span class="sd">            The maximum number of assemblies to return. Only relevant if findMany==True</span>

<span class="sd">        circularRingFlag : bool, optional</span>
<span class="sd">            A flag to toggle on using rings that are based on distance from the center of the</span>
<span class="sd">            reactor</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The call signature on this method may have gotten slightly out of hand as</span>
<span class="sd">        valuable capabilities were added in fuel management studies. For additional expansion,</span>
<span class="sd">        it may be worth reconsidering the design of these query operations ;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Assembly instance or assemList of assembly instances that match criteria, or None if none</span>
<span class="sd">        match</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        feed = self.findAssembly(targetRing=4,</span>
<span class="sd">                                 width=(0,0),</span>
<span class="sd">                                 param=&#39;maxPercentBu&#39;,</span>
<span class="sd">                                 compareTo=100,</span>
<span class="sd">                                 typeSpec=Flags.FEED | Flags.FUEL)</span>

<span class="sd">        returns the feed fuel assembly in ring 4 that has a burnup closest to 100% (the highest</span>
<span class="sd">        burnup assembly)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">compareAssem</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Check whether the candidate assembly should replace the current ideal</span>
<span class="sd">            assembly.</span>

<span class="sd">            Given a candidate tuple (diff1, a1) and current tuple (diff2, a2), decide</span>
<span class="sd">            whether the candidate is better than the current ideal. This first compares</span>
<span class="sd">            the diff1 and diff2 values. If diff1 is sufficiently less than diff2, a1</span>
<span class="sd">            wins, returning True. Otherwise, False. If diff1 and diff2 are sufficiently</span>
<span class="sd">            close, the assembly with the lesser assemNum wins. This should result in a</span>
<span class="sd">            more stable comparison than on floating-point comparisons alone.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span> <span class="o">&lt;</span> <span class="n">current</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">paramName</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">blockLevelMax</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">getChildParamValues</span><span class="p">(</span><span class="n">paramName</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span>

        <span class="n">assemList</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list for storing multiple results if findMany is true.</span>

        <span class="c1"># process input arguments</span>
        <span class="k">if</span> <span class="n">targetRing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># look through the full core</span>
            <span class="n">targetRing</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">width</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclusions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclusions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">minVal</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># list given with multiple mins</span>
            <span class="n">minVals</span> <span class="o">=</span> <span class="n">minVal</span>
            <span class="n">minParams</span> <span class="o">=</span> <span class="n">minParam</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minVals</span> <span class="o">=</span> <span class="p">[</span><span class="n">minVal</span><span class="p">]</span>
            <span class="n">minParams</span> <span class="o">=</span> <span class="p">[</span><span class="n">minParam</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maxVal</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">maxVals</span> <span class="o">=</span> <span class="n">maxVal</span>
            <span class="n">maxParams</span> <span class="o">=</span> <span class="n">maxParam</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># just one given. put it in a list so the below machinery can handle it.</span>
            <span class="n">maxVals</span> <span class="o">=</span> <span class="p">[</span><span class="n">maxVal</span><span class="p">]</span>
            <span class="n">maxParams</span> <span class="o">=</span> <span class="p">[</span><span class="n">maxParam</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">typeSpec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># restrict motions to fuel only</span>
            <span class="c1"># not really necessary. take this default out if you want to move control rods, etc.</span>
            <span class="n">typeSpec</span> <span class="o">=</span> <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span>

        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e60</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># compareTo can either be a tuple, a value, or an assembly</span>
        <span class="c1"># if it&#39;s a tuple, it can either be an int/float and a multiplier, or an assembly and a multiplier</span>
        <span class="c1"># if it&#39;s not a tuple, the multiplier will be assumed to be 1.0</span>

        <span class="n">mult</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># if no mult brought in, just assume 1.0</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compareTo</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># tuple (assem or int/float, multiplier) brought in.</span>
            <span class="c1"># separate it</span>
            <span class="n">compareTo</span><span class="p">,</span> <span class="n">mult</span> <span class="o">=</span> <span class="n">compareTo</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compareTo</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="c1"># floating point or int.</span>
            <span class="n">compVal</span> <span class="o">=</span> <span class="n">compareTo</span> <span class="o">*</span> <span class="n">mult</span>
        <span class="k">elif</span> <span class="n">param</span><span class="p">:</span>
            <span class="c1"># assume compareTo is an assembly</span>
            <span class="n">compVal</span> <span class="o">=</span> <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">compareTo</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="o">*</span> <span class="n">mult</span>

        <span class="k">if</span> <span class="n">coords</span><span class="p">:</span>
            <span class="c1"># find the assembly closest to xt,yt if coords are given without considering params.</span>
            <span class="n">aTarg</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">minD</span> <span class="o">=</span> <span class="mf">1e10</span>
            <span class="n">xt</span><span class="p">,</span> <span class="n">yt</span> <span class="o">=</span> <span class="n">coords</span>  <span class="c1"># assume (x,y) tuple.</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">():</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">()</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">yt</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xt</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">minD</span><span class="p">:</span>
                    <span class="n">minD</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="n">aTarg</span> <span class="o">=</span> <span class="n">a</span>
            <span class="k">return</span> <span class="n">aTarg</span>

        <span class="k">if</span> <span class="n">findFromSfp</span><span class="p">:</span>
            <span class="c1"># hack to enable SFP searching.</span>
            <span class="n">candidateRings</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SFP&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># set up candidateRings based on targetRing and width. The target rings comes first b/c it is preferred.</span>
            <span class="n">candidateRings</span> <span class="o">=</span> <span class="p">[</span><span class="n">targetRing</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">width</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># 0 or -1 implies that the inner rings can be added.</span>
                <span class="k">for</span> <span class="n">inner</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">candidateRings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">targetRing</span> <span class="o">-</span> <span class="n">inner</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="p">)</span>  <span class="c1"># +1 to get 1,2,3 instead of 0,1,2</span>
            <span class="k">if</span> <span class="n">width</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if 1, add in the outer rings</span>
                <span class="k">for</span> <span class="n">outer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">candidateRings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">targetRing</span> <span class="o">+</span> <span class="n">outer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># get lists of assemblies in each candidate ring. Do it in this order in case we prefer ones in the first.</span>
        <span class="c1"># scan through all assemblies and find the one (or more) that best fits the criteria</span>
        <span class="k">for</span> <span class="n">ringI</span><span class="p">,</span> <span class="n">assemsInRings</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getAssembliesInRings</span><span class="p">(</span>
                <span class="n">candidateRings</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">exactType</span><span class="p">,</span> <span class="n">exclusions</span><span class="p">,</span> <span class="n">circularRingFlag</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemsInRings</span><span class="p">:</span>
                <span class="n">innocent</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Check that this assembly&#39;s minParam is &gt; the minimum for each minParam</span>
                <span class="k">for</span> <span class="n">minIndex</span><span class="p">,</span> <span class="n">minVal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">minVals</span><span class="p">):</span>
                    <span class="n">minParam</span> <span class="o">=</span> <span class="n">minParams</span><span class="p">[</span><span class="n">minIndex</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">minParam</span><span class="p">:</span>
                        <span class="c1"># a minimum was specified. Check to see if we&#39;re ok</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">minVal</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                            <span class="c1"># tuple turned in. it&#39;s a multiplier and a param</span>
                            <span class="n">realMinVal</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">minVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">minVal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">realMinVal</span> <span class="o">=</span> <span class="n">minVal</span>

                        <span class="k">if</span> <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">minParam</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">realMinVal</span><span class="p">:</span>
                            <span class="c1"># this assembly does not meet the minVal specifications. Skip it.</span>
                            <span class="n">innocent</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>  <span class="c1"># for speed (not a big deal here)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">innocent</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Check upper bounds, to make sure this assembly doesn&#39;t have maxParams&gt;maxVals</span>
                <span class="k">for</span> <span class="n">maxIndex</span><span class="p">,</span> <span class="n">maxVal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">maxVals</span><span class="p">):</span>
                    <span class="n">maxParam</span> <span class="o">=</span> <span class="n">maxParams</span><span class="p">[</span><span class="n">maxIndex</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">maxParam</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maxVal</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                            <span class="c1"># tuple turned in. it&#39;s a multiplier and a param</span>
                            <span class="n">realMaxVal</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">maxVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">maxVal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">realMaxVal</span> <span class="o">=</span> <span class="n">maxVal</span>

                        <span class="k">if</span> <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">maxParam</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">realMaxVal</span><span class="p">:</span>
                            <span class="c1"># this assembly has a maxParam that&#39;s higher than maxVal and therefore</span>
                            <span class="c1"># doesn&#39;t qualify. skip it.</span>
                            <span class="n">innocent</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">innocent</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Check to see if this assembly is in the list of candidate locations. if not, skip it.</span>
                <span class="k">if</span> <span class="n">mandatoryLocations</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mandatoryLocations</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="n">excludedLocations</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="ow">in</span> <span class="n">excludedLocations</span><span class="p">:</span>
                        <span class="c1"># this assembly is in the excluded location list. skip it.</span>
                        <span class="k">continue</span>

                <span class="c1"># only continue of the Assembly is in a Zone</span>
                <span class="k">if</span> <span class="n">zoneList</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># guilty until proven innocent</span>
                    <span class="k">for</span> <span class="n">zone</span> <span class="ow">in</span> <span class="n">zoneList</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="ow">in</span> <span class="n">zone</span><span class="p">:</span>
                            <span class="c1"># great! it&#39;s in there, so we&#39;ll accept this assembly</span>
                            <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># innocent</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                        <span class="c1"># this assembly is not in any of the zones in the zone list. skip it.</span>
                        <span class="k">continue</span>

                <span class="c1"># Now find the assembly with the param closest to the target val.</span>
                <span class="k">if</span> <span class="n">param</span><span class="p">:</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="o">-</span> <span class="n">compVal</span><span class="p">)</span>

                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">forceSide</span> <span class="o">==</span> <span class="mi">1</span>
                        <span class="ow">and</span> <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">compVal</span>
                        <span class="ow">and</span> <span class="n">compareAssem</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">minDiff</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="c1"># forceSide=1, so that means look in rings further out</span>
                        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">(</span>
                        <span class="n">forceSide</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="ow">and</span> <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">compVal</span>
                        <span class="ow">and</span> <span class="n">compareAssem</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">minDiff</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="c1"># forceSide=-1, so that means look in rings closer in from the targetRing</span>
                        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">compareAssem</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">minDiff</span><span class="p">):</span>
                        <span class="c1"># no preference of which side, just take the one with the closest param.</span>
                        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># no param specified. Just return one closest to the target ring</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">targetRing</span><span class="p">:</span>
                        <span class="c1"># short circuit the search</span>
                        <span class="k">if</span> <span class="n">findMany</span><span class="p">:</span>
                            <span class="n">assemList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">a</span>
                    <span class="k">elif</span> <span class="p">(</span>
                        <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">targetRing</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">):</span>
                        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">targetRing</span><span class="p">),</span>
                            <span class="n">a</span><span class="p">,</span>
                        <span class="p">)</span>

                <span class="k">if</span> <span class="n">findMany</span><span class="p">:</span>
                    <span class="c1"># returning many assemblies. If there&#39;s a param, we&#39;d like it to be honored by</span>
                    <span class="c1"># ordering this list from smallest diff to largest diff.</span>
                    <span class="n">assemList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">ringI</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">acceptFirstCandidateRing</span> <span class="ow">and</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># an acceptable assembly was found in the targetRing (ringI==0)</span>
                <span class="c1"># and the user requested this to be returned. Therefore, return it without</span>
                <span class="c1"># scanning through the additional rings.</span>
                <span class="k">return</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># can&#39;t find assembly in targetRing with close param to compareTo</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">findMany</span><span class="p">:</span>
            <span class="n">assemList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># prefer items that have params that are the closest to the value.</span>
            <span class="c1"># extract the assemblies.</span>
            <span class="n">assemsInRings</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">diff</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemList</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">maxNumAssems</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">assemsInRings</span><span class="p">[:</span><span class="n">maxNumAssems</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">assemsInRings</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_getAssembliesInRings</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ringList</span><span class="p">,</span>
        <span class="n">typeSpec</span><span class="o">=</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span>
        <span class="n">exactType</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">exclusions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">circularRingFlag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        find assemblies in particular rings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ringList : list</span>
<span class="sd">            List of integer ring numbers to find assemblies in. Optionally, a string specifiying a</span>
<span class="sd">            special location like the SFP (spent fuel pool)</span>

<span class="sd">        typeSpec : Flags or iterable of Flags, optional</span>
<span class="sd">            Flag types to restrict assemblies to</span>

<span class="sd">        exactType : bool, optional</span>
<span class="sd">            Match the type in typelist exactly</span>

<span class="sd">        exclusions : list of Assemblies, optional</span>
<span class="sd">            exclude these assemblies from the results</span>

<span class="sd">        circularRingFlag : bool</span>
<span class="sd">            A flag to toggle on using rings that are based on distance from the center of the reactor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        assemblyList : list</span>
<span class="sd">            List of assemblies in each ring of the ringList. [[a1,a2,a3],[a4,a5,a6,a7],...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">assemblyList</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ringList</span><span class="p">))]</span>  <span class="c1"># empty lists for each ring</span>
        <span class="k">if</span> <span class="n">exclusions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclusions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">exclusions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclusions</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">circularRingFlag</span><span class="p">:</span>
            <span class="n">assemListTmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">assemListTmp2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">ringList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SFP&quot;</span><span class="p">:</span>
                <span class="c1"># kind of a hack for now. Need the capability.</span>
                <span class="n">assemblyList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">getChildren</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ringNumber</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ringList</span><span class="p">):</span>
                    <span class="n">assemListTmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssembliesInCircularRing</span><span class="p">(</span>
                        <span class="n">ringNumber</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">exactType</span><span class="p">,</span> <span class="n">exclusions</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemListTmp</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">exclusions</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exactType</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="c1"># save only the assemblies not in the exclusions and with the proper type</span>
                        <span class="n">assemListTmp2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                    <span class="c1"># make the list of lists of assemblies</span>
                    <span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">assemListTmp2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ringList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SFP&quot;</span><span class="p">:</span>
                <span class="c1"># kind of a hack for now. Need the capability.</span>
                <span class="n">assemList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">getChildren</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">assemList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">exclusions</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exactType</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;SFP&quot;</span><span class="p">:</span>
                    <span class="n">ring</span> <span class="o">=</span> <span class="s2">&quot;SFP&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ring</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">ringList</span><span class="p">:</span>
                    <span class="c1"># keep it in the right order</span>
                    <span class="n">assemblyList</span><span class="p">[</span><span class="n">ringList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ring</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">assemblyList</span>

<div class="viewcode-block" id="FuelHandler.swapAssemblies"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.swapAssemblies">[docs]</a>    <span class="k">def</span> <span class="nf">swapAssemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves a whole assembly from one place to another.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a1 : Assembly</span>
<span class="sd">            The first assembly</span>
<span class="sd">        a2 : Assembly</span>
<span class="sd">            The second assembly</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dischargeSwap : swap assemblies where one is outside the core and the other is inside</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">a2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Cannot swap None assemblies. Check your findAssembly results. Skipping swap&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Swapping </span><span class="si">{}</span><span class="s2"> with </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">))</span>
        <span class="c1"># add assemblies into the moved location</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">oldA1Location</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">spatialLocator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transferStationaryBlocks</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
        <span class="n">a1</span><span class="o">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">a2</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
        <span class="n">a2</span><span class="o">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">oldA1Location</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_transferStationaryBlocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assembly1</span><span class="p">,</span> <span class="n">assembly2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exchange the stationary blocks (e.g. grid plate) between the moving assemblies.</span>

<span class="sd">        These blocks in effect are not moved at all.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># grab stationary block flags</span>
        <span class="n">sBFList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">stationaryBlockFlagsList</span>

        <span class="c1"># identify stationary blocks for assembly 1</span>
        <span class="n">a1StationaryBlocks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">block</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">k</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">assembly1</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">sbf</span><span class="p">)</span> <span class="k">for</span> <span class="n">sbf</span> <span class="ow">in</span> <span class="n">sBFList</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># identify stationary blocks for assembly 2</span>
        <span class="n">a2StationaryBlocks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">block</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">k</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">assembly2</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">sbf</span><span class="p">)</span> <span class="k">for</span> <span class="n">sbf</span> <span class="ow">in</span> <span class="n">sBFList</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># check for any inconsistencies in stationary blocks and ensure alignment</span>
        <span class="k">if</span> <span class="p">[</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">a1StationaryBlocks</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[</span>
            <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">a2StationaryBlocks</span>
        <span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Different number and/or locations of stationary blocks </span>
<span class="sd">                 between {} (Stationary Blocks: {}) and {} (Stationary Blocks: {}).&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">assembly1</span><span class="p">,</span> <span class="n">a1StationaryBlocks</span><span class="p">,</span> <span class="n">assembly2</span><span class="p">,</span> <span class="n">a2StationaryBlocks</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">a1StationaryBlocks</span> <span class="ow">and</span> <span class="n">a2StationaryBlocks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a1StationaryBlocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span> <span class="o">!=</span> <span class="n">a2StationaryBlocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;Difference in top elevation of stationary blocks </span>
<span class="sd">                     between {} (Stationary Blocks: {}, Elevation at top of stationary blocks {}) </span>
<span class="sd">                     and {} (Stationary Blocks: {}, Elevation at top of stationary blocks {}))&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">assembly1</span><span class="p">,</span>
                        <span class="n">a1StationaryBlocks</span><span class="p">,</span>
                        <span class="n">a1StationaryBlocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span><span class="p">,</span>
                        <span class="n">assembly2</span><span class="p">,</span>
                        <span class="n">a2StationaryBlocks</span><span class="p">,</span>
                        <span class="n">a2StationaryBlocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">ztop</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># swap stationary blocks</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">assem1Block</span><span class="p">,</span> <span class="n">assem1BlockIndex</span><span class="p">),</span> <span class="p">(</span><span class="n">assem2Block</span><span class="p">,</span> <span class="n">assem2BlockIndex</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">a1StationaryBlocks</span><span class="p">,</span> <span class="n">a2StationaryBlocks</span>
        <span class="p">):</span>
            <span class="c1"># remove stationary blocks</span>
            <span class="n">assembly1</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">assem1Block</span><span class="p">)</span>
            <span class="n">assembly2</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">assem2Block</span><span class="p">)</span>
            <span class="c1"># insert stationary blocks</span>
            <span class="n">assembly1</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">assem1BlockIndex</span><span class="p">,</span> <span class="n">assem2Block</span><span class="p">)</span>
            <span class="n">assembly2</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">assem2BlockIndex</span><span class="p">,</span> <span class="n">assem1Block</span><span class="p">)</span>

<div class="viewcode-block" id="FuelHandler.dischargeSwap"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.dischargeSwap">[docs]</a>    <span class="k">def</span> <span class="nf">dischargeSwap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes one assembly from the core and replace it with another assembly.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        swapAssemblies : swaps assemblies that are already in the core</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Discharge swapping </span><span class="si">{}</span><span class="s2"> for </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">incoming</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">outgoing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Cannot discharge swap None assemblies. Check your findAssembly calls. Skipping&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># add assemblies into the moved location</span>
        <span class="c1"># keep it unique so we don&#39;t get artificially inflated numMoves</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transferStationaryBlocks</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">)</span>

        <span class="c1"># replace the goingOut guy.</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">outgoing</span><span class="o">.</span><span class="n">spatialLocator</span>
        <span class="c1"># say it happened at the end of the previous cycle by sending cycle-1</span>
        <span class="c1"># to removeAssembly, which will look up EOC of last cycle,</span>
        <span class="c1"># which, coincidentally is the same time we&#39;re at right now at BOC.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">removeAssembly</span><span class="p">(</span><span class="n">outgoing</span><span class="p">)</span>

        <span class="c1"># adjust the assembly multiplicity so that it doesnt forget how many it really</span>
        <span class="c1"># represents. This allows us to discharge an assembly from any location in</span>
        <span class="c1"># fractional-core models where the central location may only be one assembly,</span>
        <span class="c1"># whereas other locations are more, and keep proper track of things. In the</span>
        <span class="c1"># future, this mechanism may be used to handle symmetry in general.</span>
        <span class="n">outgoing</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">multiplicity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">getSymmetricEquivalents</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">incoming</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
            <span class="c1"># pull it out of the sfp if it&#39;s in there.</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;removing </span><span class="si">{0}</span><span class="s2"> from the sfp&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">incoming</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">incoming</span><span class="p">)</span>

        <span class="n">incoming</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">multiplicity</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span></div>

<div class="viewcode-block" id="FuelHandler.swapCascade"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.swapCascade">[docs]</a>    <span class="k">def</span> <span class="nf">swapCascade</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemList</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform swaps on a list of assemblies.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        [goingOut,inter1,inter2,goingIn]  will go to</span>
<span class="sd">        [inter1, inter2, goingIn, goingOut] in terms of positions</span>
<span class="sd">        or, in ASCII art::</span>

<span class="sd">             &gt;---------------v</span>
<span class="sd">             |               |</span>
<span class="sd">            [A  &lt;- B &lt;- C &lt;- D]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first check for duplicates</span>
        <span class="k">for</span> <span class="n">assem</span> <span class="ow">in</span> <span class="n">assemList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">assemList</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">assem</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Warning: </span><span class="si">%s</span><span class="s2"> is in the cascade more than once!&quot;</span> <span class="o">%</span> <span class="n">assem</span><span class="p">)</span>

        <span class="c1"># now swap.</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">assemList</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">levels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">assemList</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># If None in the cascade, just skip it. this will lead to slightly unintended shuffling if</span>
                <span class="c1"># the user wasn&#39;t careful enough. Their problem.</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
                    <span class="s2">&quot;Skipping level </span><span class="si">%d</span><span class="s2"> in the cascade because it is none&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">swapAssemblies</span><span class="p">(</span><span class="n">assemList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">assemList</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="FuelHandler.repeatShufflePattern"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.repeatShufflePattern">[docs]</a>    <span class="k">def</span> <span class="nf">repeatShufflePattern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">explicitRepeatShuffles</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repeats the fuel management from a previous ARMI run.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        explicitRepeatShuffles : str</span>
<span class="sd">            The file name that contains the shuffling history from a previous run</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moved : list</span>
<span class="sd">            list of assemblies that moved this cycle</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        typically the explicitRepeatShuffles will be &quot;caseName&quot;+&quot;-SHUFFLES.txt&quot;</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        doRepeatShuffle : Performs moves as processed by this method</span>
<span class="sd">        processMoveList : Converts a stored list of moves into a functional list of assemblies to swap</span>
<span class="sd">        makeShuffleReport : Creates the file that is processed here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># read moves file</span>
        <span class="n">moves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readMoves</span><span class="p">(</span><span class="n">explicitRepeatShuffles</span><span class="p">)</span>
        <span class="c1"># get the correct cycle number</span>
        <span class="c1"># +1 since cycles starts on 0 and looking for the end of 1st cycle shuffle</span>
        <span class="n">cycle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cycle</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># setup the load and loop chains to be run per cycle</span>
        <span class="n">moveList</span> <span class="o">=</span> <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span>
        <span class="p">(</span>
            <span class="n">loadChains</span><span class="p">,</span>
            <span class="n">loopChains</span><span class="p">,</span>
            <span class="n">enriches</span><span class="p">,</span>
            <span class="n">loadChargeTypes</span><span class="p">,</span>
            <span class="n">loadNames</span><span class="p">,</span>
            <span class="n">_alreadyDone</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processMoveList</span><span class="p">(</span><span class="n">moveList</span><span class="p">)</span>

        <span class="c1"># Now have the move locations</span>
        <span class="n">moved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doRepeatShuffle</span><span class="p">(</span>
            <span class="n">loadChains</span><span class="p">,</span> <span class="n">loopChains</span><span class="p">,</span> <span class="n">enriches</span><span class="p">,</span> <span class="n">loadChargeTypes</span><span class="p">,</span> <span class="n">loadNames</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">moved</span></div>

<div class="viewcode-block" id="FuelHandler.readMoves"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.readMoves">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">readMoves</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads a shuffle output file and sets up the moves dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            The shuffles file to read</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moves : dict</span>
<span class="sd">            A dictionary of all the moves. Keys are the cycle number. Values are a list</span>
<span class="sd">            of tuples, one tuple for each individual move that happened in the cycle.</span>
<span class="sd">            The items in the tuple are (oldLoc, newLoc, enrichList, assemType).</span>
<span class="sd">            Where oldLoc and newLoc are str representations of the locations and</span>
<span class="sd">            enrichList is a list of mass enrichments from bottom to top.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        repeatShufflePattern : reads this file and repeats the shuffling</span>
<span class="sd">        outage : creates the moveList in the first place.</span>
<span class="sd">        makeShuffleReport : writes the file that is read here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Could not find/open repeat shuffle file </span><span class="si">{}</span><span class="s2"> in working directory </span><span class="si">{}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>
            <span class="p">)</span>

        <span class="n">moves</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">numMoves</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;ycle&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="c1"># Used to say &quot;Cycle 1 at 0.0 years&quot;. Now says: &quot;Before cycle 1 at 0.0 years&quot; to be more specific.</span>
                <span class="c1"># This RE allows backwards compatibility.</span>
                <span class="c1"># Later, we removed the at x years</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;ycle (\d+)&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">elif</span> <span class="s2">&quot;assembly&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="c1"># this is the new load style where an actual assembly type is written to the shuffle logic</span>
                <span class="c1"># due to legacy reasons, the assembly type will be put into group 4</span>
                <span class="n">pat</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;([A-Za-z0-9!\-]+) moved to ([A-Za-z0-9!\-]+) with assembly type ([A-Za-z0-9!\s]+)\s*(ANAME=\S+)?\s*with enrich list: (.+)&quot;</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span>
                        <span class="s1">&#39;Failed to parse line &quot;</span><span class="si">{0}</span><span class="s1">&quot; in shuffle file&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">oldLoc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">newLoc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">assemType</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span>
                    <span class="mi">3</span>
                <span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>  <span class="c1"># take off any possible trailing whitespace</span>
                <span class="n">movingAssemName</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span>
                    <span class="mi">4</span>
                <span class="p">)</span>  <span class="c1"># will be None for legacy shuffleLogic files. (pre 2013-08)</span>
                <span class="k">if</span> <span class="n">movingAssemName</span><span class="p">:</span>
                    <span class="n">movingAssemName</span> <span class="o">=</span> <span class="n">movingAssemName</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)[</span>
                        <span class="mi">1</span>
                    <span class="p">]</span>  <span class="c1"># extract the actual assembly name.</span>
                <span class="n">enrichList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">oldLoc</span><span class="p">,</span> <span class="n">newLoc</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">movingAssemName</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">numMoves</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="s2">&quot;moved&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="c1"># very old shuffleLogic file.</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Using old *.SHUFFLES.txt loading file&quot;</span><span class="p">,</span>
                    <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Using old shuffles file&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
                    <span class="s2">&quot;([A-Za-z0-9!]+) moved to ([A-Za-z0-9!]+) with enrich list: (.+)&quot;</span><span class="p">,</span>
                    <span class="n">line</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span>
                        <span class="s1">&#39;Failed to parse line &quot;</span><span class="si">{0}</span><span class="s1">&quot; in shuffle file&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">oldLoc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">newLoc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">enrichList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                <span class="c1"># old loading style, just assume that there is a booster as our surrogate</span>
                <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">oldLoc</span><span class="p">,</span> <span class="n">newLoc</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="n">numMoves</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Read </span><span class="si">{0}</span><span class="s2"> moves over </span><span class="si">{1}</span><span class="s2"> cycles&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numMoves</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">moves</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">moves</span></div>

<div class="viewcode-block" id="FuelHandler.trackChain"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.trackChain">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">trackChain</span><span class="p">(</span><span class="n">moveList</span><span class="p">,</span> <span class="n">startingAt</span><span class="p">,</span> <span class="n">alreadyDone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a chain of locations based on starting location.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Takes a moveList and extracts chains. Remembers all it touches.</span>
<span class="sd">        If A moved to B, C moved to D, and B moved to C, this returns</span>
<span class="sd">        A, B, C ,D.</span>

<span class="sd">        Used in some monte carlo physics writers and in repeatShufflePattern</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moveList : list</span>
<span class="sd">            a list of (fromLoc,toLoc,enrichList,assemType,assemName) tuples that occurred at a single outage.</span>

<span class="sd">        startingAt : str</span>
<span class="sd">            A location label where the chain would start. This is important because the discharge</span>
<span class="sd">            moves are built when the SFP is found in a move. This method must find all</span>
<span class="sd">            assemblies in the chain leading up to this particular discharge.</span>

<span class="sd">        alreadyDone : list</span>
<span class="sd">            A list of locations that have already been tracked.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        chain : list</span>
<span class="sd">            The chain as a location list in order</span>
<span class="sd">        enrich : list</span>
<span class="sd">            The axial enrichment distribution of the load assembly.</span>
<span class="sd">        loadName : str</span>
<span class="sd">            The assembly name of the load assembly</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        repeatShufflePattern</span>
<span class="sd">        processMoveList</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">alreadyDone</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alreadyDone</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">enrich</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># in case this is a load chain, prep for getting enrich.</span>
        <span class="n">loadName</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">assemType</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">None</span>  <span class="c1"># in case this is a load chain, prep for getting an assembly type</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">fromLoc</span><span class="p">,</span> <span class="n">toLoc</span><span class="p">,</span> <span class="n">_enrichList</span><span class="p">,</span> <span class="n">_assemblyType</span><span class="p">,</span> <span class="n">_assemName</span> <span class="ow">in</span> <span class="n">moveList</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;SFP&quot;</span> <span class="ow">in</span> <span class="n">toLoc</span> <span class="ow">and</span> <span class="s2">&quot;LoadQueue&quot;</span> <span class="ow">in</span> <span class="n">fromLoc</span><span class="p">:</span>
                <span class="c1"># skip dummy moves</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">fromLoc</span><span class="p">,</span> <span class="n">toLoc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">alreadyDone</span><span class="p">:</span>
                <span class="c1"># skip this pair</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">startingAt</span> <span class="ow">in</span> <span class="n">fromLoc</span><span class="p">:</span>
                <span class="c1"># looking for chain involving toLoc</span>
                <span class="c1"># back-track the chain of moves</span>
                <span class="n">chain</span> <span class="o">=</span> <span class="p">[</span><span class="n">fromLoc</span><span class="p">]</span>
                <span class="n">safeCount</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># to break out of crazy loops.</span>
                <span class="n">complete</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">while</span> <span class="p">(</span>
                    <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;LoadQueue&quot;</span><span class="p">,</span> <span class="s2">&quot;ExCore&quot;</span><span class="p">,</span> <span class="s2">&quot;SFP&quot;</span><span class="p">]</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">complete</span>
                    <span class="ow">and</span> <span class="n">safeCount</span> <span class="o">&lt;</span> <span class="mi">100</span>
                <span class="p">):</span>
                    <span class="c1"># look for something going to where the previous one is from</span>
                    <span class="n">lookingFor</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">for</span> <span class="p">(</span>
                        <span class="n">cFromLoc</span><span class="p">,</span>
                        <span class="n">cToLoc</span><span class="p">,</span>
                        <span class="n">cEnrichList</span><span class="p">,</span>
                        <span class="n">cAssemblyType</span><span class="p">,</span>
                        <span class="n">cAssemName</span><span class="p">,</span>
                    <span class="p">)</span> <span class="ow">in</span> <span class="n">moveList</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">cToLoc</span> <span class="o">==</span> <span class="n">lookingFor</span><span class="p">:</span>
                            <span class="n">chain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cFromLoc</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">cFromLoc</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;LoadQueue&quot;</span><span class="p">,</span> <span class="s2">&quot;ExCore&quot;</span><span class="p">,</span> <span class="s2">&quot;SFP&quot;</span><span class="p">]:</span>
                                <span class="c1"># charge-discharge loop complete.</span>
                                <span class="n">enrich</span> <span class="o">=</span> <span class="n">cEnrichList</span>
                                <span class="n">loadName</span> <span class="o">=</span> <span class="n">cAssemName</span>
                                <span class="n">assemType</span> <span class="o">=</span> <span class="n">cAssemblyType</span>
                                <span class="c1"># break from here or else we might get the next LoadQueue&#39;s enrich.</span>
                                <span class="k">break</span>

                    <span class="k">if</span> <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">startingAt</span><span class="p">:</span>
                        <span class="c1"># non-charging loop complete</span>
                        <span class="n">complete</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="n">safeCount</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">safeCount</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;Chain tracking got too long. Check moves.</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="c1"># delete the last item, it&#39;s loadqueue location or the startingFrom</span>
                <span class="c1"># location.</span>
                <span class="n">chain</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

                <span class="c1"># chain tracked. Can jump out of loop early.</span>
                <span class="k">return</span> <span class="n">chain</span><span class="p">,</span> <span class="n">enrich</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">loadName</span>

        <span class="c1"># if we get here, the startingAt location was not found.</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No chain found starting at </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">startingAt</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="n">enrich</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">loadName</span></div>

<div class="viewcode-block" id="FuelHandler.processMoveList"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.processMoveList">[docs]</a>    <span class="k">def</span> <span class="nf">processMoveList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moveList</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Processes a move list and extracts fuel management loops and charges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moveList : list</span>
<span class="sd">            A list of information about fuel management from a previous case. Each entry represents a</span>
<span class="sd">            move and includes the following items as a tuple:</span>

<span class="sd">            fromLoc</span>
<span class="sd">                the label of where the assembly was before the move</span>
<span class="sd">            toLoc</span>
<span class="sd">                the label of where the assembly was after the move</span>
<span class="sd">            enrichList</span>
<span class="sd">                a list of block enrichments for the assembly</span>
<span class="sd">            assemType</span>
<span class="sd">                the type of assembly that this is</span>
<span class="sd">            movingAssemName</span>
<span class="sd">                the name of the assembly that is moving from to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loadChains : list</span>
<span class="sd">            list of lists of location labels for each load chain (with charge/discharge). These DO NOT include</span>
<span class="sd">            special location labels like LoadQueue or SFP</span>
<span class="sd">        loopChains : list</span>
<span class="sd">            list of lists of location labels for each loop chain (no charge/discharge)</span>
<span class="sd">        enriches : list</span>
<span class="sd">            The block enrichment distribution of each load assembly</span>
<span class="sd">        loadChargeTypes :list</span>
<span class="sd">            The types of assemblies that get charged.</span>
<span class="sd">        loadNames : list</span>
<span class="sd">            The assembly names of assemblies that get brought into the core from the SFP (useful for pulling out</span>
<span class="sd">            of SFP for round 2, etc.). Will be None for anything else.</span>
<span class="sd">        alreadyDone : list</span>
<span class="sd">            All the locations that were read.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Used in the some Monte Carlo interfaces to convert ARMI moves to their format moves. Also used in</span>
<span class="sd">        repeat shuffling.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        makeShuffleReport : writes the file that is being processed</span>
<span class="sd">        repeatShufflePattern : uses this to repeat shuffles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alreadyDone</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">loadChains</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># moves that have discharges</span>
        <span class="n">loadChargeTypes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the assembly types (str) to be used in a load chain.</span>
        <span class="n">loopChains</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># moves that don&#39;t have discharges</span>
        <span class="n">enriches</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># enrichments of each loadChain</span>
        <span class="n">loadNames</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># assembly name of each load assembly (to read from SFP)</span>

        <span class="c1"># first handle all charge/discharge chains by looking for things going to SFP</span>
        <span class="k">for</span> <span class="n">fromLoc</span><span class="p">,</span> <span class="n">toLoc</span><span class="p">,</span> <span class="n">_enrichList</span><span class="p">,</span> <span class="n">_assemType</span><span class="p">,</span> <span class="n">_movingAssemName</span> <span class="ow">in</span> <span class="n">moveList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">toLoc</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SFP&quot;</span><span class="p">,</span> <span class="s2">&quot;ExCore&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="s2">&quot;LoadQueue&quot;</span> <span class="ow">in</span> <span class="n">fromLoc</span><span class="p">:</span>
                <span class="c1"># skip dummy moves</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="s2">&quot;SFP&quot;</span> <span class="ow">in</span> <span class="n">toLoc</span> <span class="ow">or</span> <span class="s2">&quot;ExCore&quot;</span> <span class="ow">in</span> <span class="n">toLoc</span><span class="p">:</span>
                <span class="c1"># discharge. Track chain.</span>
                <span class="n">chain</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">loadAssemName</span> <span class="o">=</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">trackChain</span><span class="p">(</span>
                    <span class="n">moveList</span><span class="p">,</span> <span class="n">startingAt</span><span class="o">=</span><span class="n">fromLoc</span>
                <span class="p">)</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
                    <span class="s2">&quot;Load Chain with load assem </span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">assemType</span><span class="p">,</span> <span class="n">chain</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">loadChains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
                <span class="n">enriches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">enrichList</span><span class="p">)</span>
                <span class="n">loadChargeTypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assemType</span><span class="p">)</span>
                <span class="n">loadNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loadAssemName</span><span class="p">)</span>
                <span class="c1"># track all the locations we saw already so we</span>
                <span class="c1"># don&#39;t use them in the loop moves.</span>
                <span class="n">alreadyDone</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>

        <span class="c1"># go through again, looking for stuff that isn&#39;t in chains.</span>
        <span class="c1"># put them in loop type 3 moves (arbitrary order)</span>
        <span class="k">for</span> <span class="n">fromLoc</span><span class="p">,</span> <span class="n">toLoc</span><span class="p">,</span> <span class="n">_enrichList</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">_movingAssemName</span> <span class="ow">in</span> <span class="n">moveList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">toLoc</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SFP&quot;</span><span class="p">,</span> <span class="s2">&quot;ExCore&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">fromLoc</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;LoadQueue&quot;</span><span class="p">,</span> <span class="s2">&quot;SFP&quot;</span><span class="p">,</span> <span class="s2">&quot;ExCore&quot;</span><span class="p">]:</span>
                <span class="c1"># skip loads/discharges; they&#39;re already done.</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">fromLoc</span> <span class="ow">in</span> <span class="n">alreadyDone</span><span class="p">:</span>
                <span class="c1"># skip repeats</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># normal move</span>
                <span class="n">chain</span><span class="p">,</span> <span class="n">_enrichList</span><span class="p">,</span> <span class="n">_assemType</span><span class="p">,</span> <span class="n">_loadAssemName</span> <span class="o">=</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">trackChain</span><span class="p">(</span>
                    <span class="n">moveList</span><span class="p">,</span> <span class="n">startingAt</span><span class="o">=</span><span class="n">fromLoc</span>
                <span class="p">)</span>
                <span class="n">loopChains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
                <span class="n">alreadyDone</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>

                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Loop Chain: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chain</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">loadChains</span><span class="p">,</span> <span class="n">loopChains</span><span class="p">,</span> <span class="n">enriches</span><span class="p">,</span> <span class="n">loadChargeTypes</span><span class="p">,</span> <span class="n">loadNames</span><span class="p">,</span> <span class="n">alreadyDone</span></div>

<div class="viewcode-block" id="FuelHandler.doRepeatShuffle"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.doRepeatShuffle">[docs]</a>    <span class="k">def</span> <span class="nf">doRepeatShuffle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">loadChains</span><span class="p">,</span> <span class="n">loopChains</span><span class="p">,</span> <span class="n">enriches</span><span class="p">,</span> <span class="n">loadChargeTypes</span><span class="p">,</span> <span class="n">loadNames</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Actually does the fuel movements required to repeat a shuffle order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loadChains : list</span>
<span class="sd">            list of lists of location labels for each load chain (with charge/discharge)</span>
<span class="sd">        loopChains : list</span>
<span class="sd">            list of lists of location labels for each loop chain (no charge/discharge)</span>
<span class="sd">        enriches : list</span>
<span class="sd">            The block enrichment distribution of each load assembly</span>
<span class="sd">        loadChargeTypes :list</span>
<span class="sd">            The types of assemblies that get charged.</span>
<span class="sd">        loadNames : list</span>
<span class="sd">            The assembly names of assemblies that get brought into the core (useful for pulling out</span>
<span class="sd">            of SFP for round 2, etc.)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        repeatShufflePattern : coordinates the moves for this cycle</span>
<span class="sd">        processMoveList : builds the input lists</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a helper function for repeatShufflePattern</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">moved</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># shuffle all of the load chain assemblies (These include discharges to SFP</span>
        <span class="c1"># and loads from Loadqueue)</span>

        <span class="c1"># build a lookup table of locations throughout the current core and cache it.</span>
        <span class="n">locContents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">makeLocationLookup</span><span class="p">(</span><span class="n">assemblyLevel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># perform load swaps (with charge/discharge)</span>
        <span class="k">for</span> <span class="n">assemblyChain</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="n">assemblyType</span><span class="p">,</span> <span class="n">assemblyName</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">loadChains</span><span class="p">,</span> <span class="n">enriches</span><span class="p">,</span> <span class="n">loadChargeTypes</span><span class="p">,</span> <span class="n">loadNames</span>
        <span class="p">):</span>
            <span class="c1"># convert the labels into actual assemblies to be swapped</span>
            <span class="n">assemblyList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getLocationContents</span><span class="p">(</span>
                <span class="n">assemblyChain</span><span class="p">,</span> <span class="n">assemblyLevel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">locContents</span><span class="o">=</span><span class="n">locContents</span>
            <span class="p">)</span>

            <span class="n">moved</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">)</span>

            <span class="c1"># go through and swap the assemblies knowing that there is a discharge (first one)</span>
            <span class="c1"># and a new assembly brought it (last one)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">swapAssemblies</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Now, everything has been set except the first assembly in the list, which must now be</span>
            <span class="c1"># replaced with a fresh assembly... but which one? The assemblyType string</span>
            <span class="c1"># tells us.</span>
            <span class="c1"># Sometimes enrichment is set on-the-fly by branch searches, so we must</span>
            <span class="c1"># not only use the proper assembly type but also adjust the enrichment.</span>
            <span class="k">if</span> <span class="n">assemblyName</span><span class="p">:</span>
                <span class="c1"># get this assembly from the SFP</span>
                <span class="n">loadAssembly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">getAssembly</span><span class="p">(</span><span class="n">assemblyName</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">loadAssembly</span><span class="p">:</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;the required assembly </span><span class="si">{0}</span><span class="s2"> is not found in the SFP. It contains: </span><span class="si">{1}</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">assemblyName</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">getChildren</span><span class="p">())</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;the required assembly </span><span class="si">{0}</span><span class="s2"> is not found in the SFP.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">loadAssembly</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># create a new assembly from the BOL assem templates and adjust the enrichment</span>
                <span class="n">loadAssembly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">createAssemblyOfType</span><span class="p">(</span>
                    <span class="n">enrichList</span><span class="o">=</span><span class="n">enrichList</span><span class="p">,</span> <span class="n">assemType</span><span class="o">=</span><span class="n">assemblyType</span>
                <span class="p">)</span>

            <span class="c1"># replace the goingOut guy (for continual feed cases)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Calling discharge swap with </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">loadAssembly</span><span class="p">,</span> <span class="n">assemblyList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dischargeSwap</span><span class="p">(</span><span class="n">loadAssembly</span><span class="p">,</span> <span class="n">assemblyList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loadAssembly</span><span class="p">)</span>

        <span class="c1"># shuffle all of the loop chain assemblies (no charge/discharge)</span>

        <span class="k">for</span> <span class="n">assemblyChain</span> <span class="ow">in</span> <span class="n">loopChains</span><span class="p">:</span>
            <span class="c1"># convert the labels into actual assemblies to be swapped</span>
            <span class="n">assemblyList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getLocationContents</span><span class="p">(</span>
                <span class="n">assemblyChain</span><span class="p">,</span> <span class="n">assemblyLevel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">locContents</span><span class="o">=</span><span class="n">locContents</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblyList</span><span class="p">:</span>
                <span class="n">moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="c1"># go through and swap the assemblies knowing that there is a discharge (first one)</span>
            <span class="c1"># and a new assembly brought it (last one)</span>
            <span class="c1"># for i in range(0,-(len(assemblyList)-1),-1):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">swapAssemblies</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">moved</span></div>

<div class="viewcode-block" id="FuelHandler.workerOperate"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.workerOperate">[docs]</a>    <span class="k">def</span> <span class="nf">workerOperate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmd</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handle a mpi command on the worker nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="FuelHandler.prepShuffleMap"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.prepShuffleMap">[docs]</a>    <span class="k">def</span> <span class="nf">prepShuffleMap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare a table of current locations for plotting shuffle maneuvers.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oldLocations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">oldLocations</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">getName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span></div>

<div class="viewcode-block" id="FuelHandler.makeShuffleArrows"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.makeShuffleArrows">[docs]</a>    <span class="k">def</span> <span class="nf">makeShuffleArrows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build data for plotting all the previous shuffles as arrows.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arrows : list</span>
<span class="sd">            Values are (currentCoords, oldCoords) tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arrows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Building list of shuffle arrows.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">():</span>
            <span class="n">currentCoords</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span>
            <span class="n">oldCoords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oldLocations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">oldCoords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">oldCoords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">currentCoords</span> <span class="o">!=</span> <span class="n">oldCoords</span><span class="p">):</span>
                <span class="n">arrows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">oldCoords</span><span class="p">,</span> <span class="n">currentCoords</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">arrows</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2009-2023, TerraPower, LLC.
      <span class="lastupdated">Last updated on 2023-08-17.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
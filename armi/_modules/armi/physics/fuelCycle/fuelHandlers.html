

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>armi.physics.fuelCycle.fuelHandlers &mdash; ARMI 0.2.3 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/theme_fixes.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/armiicon_16x16.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="../../../../_static/assets/jsonview.bundle.js"></script>
        <script src="../../../../_static/assets/jsonview_loader.js"></script>
        <script src="../../../../_static/sphinx-needs/libs/html/datatables.min.js"></script>
        <script src="../../../../_static/sphinx-needs/libs/html/datatables_loader.js"></script>
        <script src="../../../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> ARMI
          

          
            
            <img src="../../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../requirements/index.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../.apidocs/modules.html">API Docs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ARMI</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../armi.html">armi</a> &raquo;</li>
        
          <li><a href="../fuelCycle.html">armi.physics.fuelCycle</a> &raquo;</li>
        
      <li>armi.physics.fuelCycle.fuelHandlers</li>
    
    
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for armi.physics.fuelCycle.fuelHandlers</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module handles fuel management operations such as shuffling, rotation, and</span>
<span class="sd">fuel processing (in fluid systems).</span>

<span class="sd">The :py:class:`FuelHandlerInterface` instantiates a ``FuelHandler``, which is typically a user-defined</span>
<span class="sd">subclass the :py:class:`FuelHandler` object in custom shuffle-logic input files.</span>
<span class="sd">Users point to the code modules with their custom fuel handlers using the</span>
<span class="sd">``shuffleLogic`` and ``fuelHandlerName`` settings, as described in :doc:`/user/inputs/fuel_management`.</span>
<span class="sd">These subclasses override ``chooseSwaps`` that determine</span>
<span class="sd">the particular shuffling of a case.</span>

<span class="sd">This module also handles repeat shuffles when doing a restart.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">armi.utils.customExceptions</span> <span class="kn">import</span> <span class="n">InputError</span>
<span class="kn">from</span> <span class="nn">armi.reactor.flags</span> <span class="kn">import</span> <span class="n">Flags</span>
<span class="kn">from</span> <span class="nn">armi.utils.mathematics</span> <span class="kn">import</span> <span class="n">findClosest</span><span class="p">,</span> <span class="n">resampleStepwise</span>
<span class="kn">from</span> <span class="nn">armi.physics.fuelCycle.fuelHandlerFactory</span> <span class="kn">import</span> <span class="n">fuelHandlerFactory</span>
<span class="kn">from</span> <span class="nn">armi.physics.fuelCycle.fuelHandlerInterface</span> <span class="kn">import</span> <span class="n">FuelHandlerInterface</span>

<span class="n">runLog</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="FuelHandler"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler">[docs]</a><span class="k">class</span> <span class="nc">FuelHandler</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A fuel handling machine can move fuel around the core and reactor.</span>

<span class="sd">    It makes decisions on how to shuffle fuel based on user specifications.</span>
<span class="sd">    It provides some supervisory data tracking, such as having the ability</span>
<span class="sd">    to print out information about all moves that happened in a cycle (without</span>
<span class="sd">    the user needing to explicitly track this information).</span>

<span class="sd">    To use this, simply create an input Python file and point to it by path</span>
<span class="sd">    with the ``fuelHandler`` setting. In that file, subclass this object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
        <span class="c1"># we need access to the operator to find the core, get settings, grab</span>
        <span class="c1"># other interfaces, etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">o</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moved</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handleBackwardsCompatibility</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_handleBackwardsCompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># prepSearch used to be part of the API but is deprecated. This will</span>
        <span class="c1"># trigger a warning if it&#39;s implemented.</span>
        <span class="c1"># We have to do this hack until we phase out old inputs.</span>
        <span class="c1"># This basically asks: &quot;Did the custom subclass override prepSearch?&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepSearch</span><span class="o">.</span><span class="vm">__func__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">FuelHandler</span><span class="o">.</span><span class="n">prepSearch</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepSearch</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Link to the current cycle number.</span>

<span class="sd">        Notes</span>
<span class="sd">        ------</span>
<span class="sd">        This retains backwards compatibility with previous fuel handler inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cycle</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Link to the Case Settings object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">cs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Link to the Reactor object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">r</span>

<div class="viewcode-block" id="FuelHandler.outage"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.outage">[docs]</a>    <span class="k">def</span> <span class="nf">outage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulates a reactor reload outage. Moves and tracks fuel.</span>

<span class="sd">        This sets the moveList structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot perform two outages with same FuelHandler instance.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># determine if a repeat shuffle is occurring or a new shuffle pattern</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">]:</span>
            <span class="c1"># repeated shuffle</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Requested repeat shuffle file </span><span class="si">{0}</span><span class="s2"> does not exist. Cannot perform shuffling. &quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span>
                <span class="s2">&quot;Repeating a shuffling pattern from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">repeatShufflePattern</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;explicitRepeatShuffles&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Normal shuffle from user-provided shuffle logic input</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chooseSwaps</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="c1"># do rotations if pin-level details are available (requires fluxRecon plugin)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;fluxRecon&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;assemblyRotationAlgorithm&quot;</span><span class="p">]:</span>
            <span class="c1"># Rotate assemblies ONLY IF at least some assemblies have pin detail (enabled by fluxRecon)</span>
            <span class="c1"># The user can choose the algorithm method name directly in the settings</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;assemblyRotationAlgorithm&quot;</span><span class="p">]):</span>
                <span class="n">rotationMethod</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;assemblyRotationAlgorithm&quot;</span><span class="p">])</span>
                <span class="n">rotationMethod</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;FuelHandler </span><span class="si">{0}</span><span class="s2"> does not have a rotation algorithm called </span><span class="si">{1}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s1">&#39;Change your &quot;assemblyRotationAlgorithm&quot; setting&#39;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;assemblyRotationAlgorithm&quot;</span><span class="p">])</span>
                <span class="p">)</span>

        <span class="c1"># inform the reactor of how many moves occurred so it can put the number in the database.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
            <span class="n">numMoved</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">powerMultiplier</span>

            <span class="c1"># tell the reactor which assemblies moved where</span>
            <span class="c1"># also tell enrichments of each block in case there&#39;s some autoboosting going on.</span>
            <span class="c1"># This is also essential for repeating shuffles in later restart runs.</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">setMoveList</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cycle</span><span class="p">,</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">lastLocationLabel</span><span class="p">,</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">(),</span>
                        <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">getUraniumMassEnrich</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">],</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">getType</span><span class="p">(),</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span>
                    <span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="s2">&quot;A fuel management error has occurred. &quot;</span><span class="p">)</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="s2">&quot;Trying operation on assembly </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span><span class="s2">&quot;The moved list is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">))</span>
                    <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numMoved</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">numMoves</span> <span class="o">=</span> <span class="n">numMoved</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span>
            <span class="s2">&quot;Fuel handler performed </span><span class="si">{0}</span><span class="s2"> assembly shuffles.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numMoved</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># now wipe out the self.moved version so it doesn&#39;t transmit the assemblies during distributeState</span>
        <span class="n">moved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moved</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">moved</span></div>

<div class="viewcode-block" id="FuelHandler.chooseSwaps"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.chooseSwaps">[docs]</a>    <span class="k">def</span> <span class="nf">chooseSwaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shuffleFactors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves the fuel around or otherwise processes it between cycles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="FuelHandler.getFactorList"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.getFactorList">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getFactorList</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fallBack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return factors between 0 and 1 that control fuel management.</span>

<span class="sd">        This is the default shuffle control function. Usually you would override this</span>
<span class="sd">        with your own in a custom shuffleLogic.py file. For more details about how this</span>
<span class="sd">        works, refer to :doc:`/user/inputs/fuel_management`.</span>

<span class="sd">        This will get bound to the default FuelHandler as a static method below. This is</span>
<span class="sd">        done to allow a user to mix and match FuelHandler class implementations and</span>
<span class="sd">        getFactorList implementations at run time.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Ultimately, this approach will likely get replaced using the plugin framework, but</span>
<span class="sd">        we aren&#39;t there yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># prefer to keep these 0 through 1 since this is what the branch search can do.</span>
        <span class="n">defaultFactorList</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;eqShuffles&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="n">factorSearchFlags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">defaultFactorList</span><span class="p">,</span> <span class="n">factorSearchFlags</span></div>

<div class="viewcode-block" id="FuelHandler.simpleAssemblyRotation"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.simpleAssemblyRotation">[docs]</a>    <span class="k">def</span> <span class="nf">simpleAssemblyRotation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate all pin-detail assemblies that were just shuffled by 60 degrees</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Also, optionally rotate stationary (non-shuffled) assemblies if the setting is set.</span>
<span class="sd">        Obviously, only pin-detail assemblies can be rotated, because homogenized assemblies are isotropic.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; fh.simpleAssemblyRotation()</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        buReducingAssemblyRotation : an alternative rotation algorithm</span>
<span class="sd">        outage : calls this method based on a user setting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rotating assemblies by 60 degrees&quot;</span><span class="p">)</span>
        <span class="n">numRotated</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">getInterface</span><span class="p">(</span><span class="s2">&quot;history&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">hist</span><span class="o">.</span><span class="n">getDetailAssemblies</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;assemblyRotationStationary&quot;</span><span class="p">]:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">rotatePins</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">numRotated</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()</span>  <span class="c1"># hex indices (i,j) = (ring,pos)</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
                    <span class="s2">&quot;Rotating Assembly (</span><span class="si">{0}</span><span class="s2">,</span><span class="si">{1}</span><span class="s2">) to Orientation </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Rotated </span><span class="si">{0}</span><span class="s2"> assemblies&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numRotated</span><span class="p">))</span></div>

<div class="viewcode-block" id="FuelHandler.buReducingAssemblyRotation"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.buReducingAssemblyRotation">[docs]</a>    <span class="k">def</span> <span class="nf">buReducingAssemblyRotation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates all detail assemblies to put the highest bu pin in the lowest power orientation</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        simpleAssemblyRotation : an alternative rotation algorithm</span>
<span class="sd">        outage : calls this method based on a user setting</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Algorithmically rotating assemblies to minimize burnup&quot;</span><span class="p">)</span>
        <span class="n">numRotated</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">getInterface</span><span class="p">(</span><span class="s2">&quot;history&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">aPrev</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>  <span class="c1"># much more convenient to loop through aPrev first</span>
            <span class="n">aNow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblyWithStringLocation</span><span class="p">(</span><span class="n">aPrev</span><span class="o">.</span><span class="n">lastLocationLabel</span><span class="p">)</span>
            <span class="c1"># no point in rotation if there&#39;s no pin detail</span>
            <span class="k">if</span> <span class="n">aNow</span> <span class="ow">in</span> <span class="n">hist</span><span class="o">.</span><span class="n">getDetailAssemblies</span><span class="p">():</span>

                <span class="n">rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOptimalAssemblyOrientation</span><span class="p">(</span><span class="n">aNow</span><span class="p">,</span> <span class="n">aPrev</span><span class="p">)</span>
                <span class="n">aNow</span><span class="o">.</span><span class="n">rotatePins</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>  <span class="c1"># rot = integer between 0 and 5</span>
                <span class="n">numRotated</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># Print out rotation operation (mainly for testing)</span>
                <span class="c1"># hex indices (i,j) = (ring,pos)</span>
                <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">aNow</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span>
                    <span class="s2">&quot;Rotating Assembly (</span><span class="si">{0}</span><span class="s2">,</span><span class="si">{1}</span><span class="s2">) to Orientation </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">rot</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># rotate NON-MOVING assemblies (stationary)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;assemblyRotationStationary&quot;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">hist</span><span class="o">.</span><span class="n">getDetailAssemblies</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
                    <span class="n">rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOptimalAssemblyOrientation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">rotatePins</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>  <span class="c1"># rot = integer between 0 and 6</span>
                    <span class="n">numRotated</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">important</span><span class="p">(</span>
                        <span class="s2">&quot;Rotating Assembly (</span><span class="si">{0}</span><span class="s2">,</span><span class="si">{1}</span><span class="s2">) to Orientation </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">rot</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Rotated </span><span class="si">{0}</span><span class="s2"> assemblies&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numRotated</span><span class="p">))</span></div>

<div class="viewcode-block" id="FuelHandler.getOptimalAssemblyOrientation"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.getOptimalAssemblyOrientation">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">getOptimalAssemblyOrientation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">aPrev</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get optimal assembly orientation/rotation to minimize peak burnup.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Works by placing the highest-BU pin in the location (of 6 possible locations) with lowest</span>
<span class="sd">        expected pin power. We evaluated &quot;expected pin power&quot; based on the power distribution in</span>
<span class="sd">        aPrev, which is the previous assembly located here. If aPrev has no pin detail, then we must use its</span>
<span class="sd">        corner fast fluxes to make an estimate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : Assembly object</span>
<span class="sd">            The assembly that is being rotated.</span>

<span class="sd">        aPrev : Assembly object</span>
<span class="sd">            The assembly that previously occupied this location (before the last shuffle).</span>

<span class="sd">            If the assembly &quot;a&quot; was not shuffled, then &quot;aPrev&quot; = &quot;a&quot;.</span>

<span class="sd">            If &quot;aPrev&quot; has pin detail, then we will determine the orientation of &quot;a&quot; based on</span>
<span class="sd">            the pin powers of &quot;aPrev&quot; when it was located here.</span>

<span class="sd">            If &quot;aPrev&quot; does NOT have pin detail, then we will determine the orientation of &quot;a&quot; based on</span>
<span class="sd">            the corner fast fluxes in &quot;aPrev&quot; when it was located here.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rot : int</span>
<span class="sd">            An integer from 0 to 5 representing the &quot;orientation&quot; of the assembly.</span>
<span class="sd">            This orientation is relative to the current assembly orientation.</span>
<span class="sd">            rot = 0 corresponds to no rotation.</span>
<span class="sd">            rot represents the number of pi/3 counterclockwise rotations for the default orientation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; fh.getOptimalAssemblyOrientation(a,aPrev)</span>
<span class="sd">        4</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        rotateAssemblies : calls this to figure out how to rotate</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># determine whether or not aPrev had pin details</span>
        <span class="n">fuelPrev</span> <span class="o">=</span> <span class="n">aPrev</span><span class="o">.</span><span class="n">getFirstBlock</span><span class="p">(</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fuelPrev</span><span class="p">:</span>
            <span class="n">aPrevDetailFlag</span> <span class="o">=</span> <span class="n">fuelPrev</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pinLocation</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aPrevDetailFlag</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">rot</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># default: no rotation</span>
        <span class="c1"># First get pin index of maximum BU in this assembly.</span>
        <span class="n">_maxBuAssem</span><span class="p">,</span> <span class="n">maxBuBlock</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">getMaxParam</span><span class="p">(</span><span class="s2">&quot;percentBuMax&quot;</span><span class="p">,</span> <span class="n">returnObj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxBuBlock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no max block. They&#39;re all probably zero</span>
            <span class="k">return</span> <span class="n">rot</span>
        <span class="c1"># start at 0 instead of 1</span>
        <span class="n">maxBuPinIndexAssem</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxBuBlock</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">percentBuMaxPinLocation</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">bIndexMaxBu</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">maxBuBlock</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">maxBuPinIndexAssem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Don&#39;t bother rotating if the highest-BU pin is the central pin. End this method.</span>
            <span class="k">return</span> <span class="n">rot</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># transfer percentBuMax rotated pin index to non-rotated pin index</span>
            <span class="c1"># maxBuPinIndexAssem = self.pinIndexLookup[maxBuPinIndexAssem]</span>
            <span class="c1"># dummyList = numpy.where(self.pinIndexLookup == maxBuPinIndexAssem)</span>
            <span class="c1"># maxBuPinIndexAssem = dummyList[0][0]</span>

            <span class="k">if</span> <span class="n">aPrevDetailFlag</span><span class="p">:</span>

                <span class="c1"># aPrev has pin detail. Excellent!</span>
                <span class="c1"># Determine which of 6 possible rotated pin indices had the lowest power when aPrev was here.</span>

                <span class="n">prevAssemPowHereMIN</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">possibleRotation</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>  <span class="c1"># k = 1,2,3,4,5</span>
                    <span class="c1"># get rotated pin index</span>
                    <span class="n">indexLookup</span> <span class="o">=</span> <span class="n">maxBuBlock</span><span class="o">.</span><span class="n">rotatePins</span><span class="p">(</span>
                        <span class="n">possibleRotation</span><span class="p">,</span> <span class="n">justCompute</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                    <span class="c1"># rotated index of highest-BU pin</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">indexLookup</span><span class="p">[</span><span class="n">maxBuPinIndexAssem</span><span class="p">])</span>
                    <span class="c1"># get pin power at this index in the previously assembly located here</span>
                    <span class="c1"># power previously at rotated index</span>
                    <span class="n">prevAssemPowHere</span> <span class="o">=</span> <span class="n">aPrev</span><span class="p">[</span><span class="n">bIndexMaxBu</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">linPowByPin</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">prevAssemPowHere</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                            <span class="s2">&quot;Previous power in rotation </span><span class="si">{0}</span><span class="s2"> where pinLoc=</span><span class="si">{1}</span><span class="s2"> is </span><span class="si">{2:.4E}</span><span class="s2"> W/cm&quot;</span>
                            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">possibleRotation</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">prevAssemPowHere</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">prevAssemPowHere</span> <span class="o">&lt;</span> <span class="n">prevAssemPowHereMIN</span><span class="p">:</span>
                            <span class="n">prevAssemPowHereMIN</span> <span class="o">=</span> <span class="n">prevAssemPowHere</span>
                            <span class="n">rot</span> <span class="o">=</span> <span class="n">possibleRotation</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot perform detailed rotation analysis without pin-level &quot;</span>
                    <span class="s2">&quot;flux information.&quot;</span>
                <span class="p">)</span>

            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Best relative rotation is </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rot</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">rot</span></div>

<div class="viewcode-block" id="FuelHandler.prepCore"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.prepCore">[docs]</a>    <span class="k">def</span> <span class="nf">prepCore</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Aux. function to run before XS generation (do moderation, etc. here)&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="FuelHandler.prepSearch"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.prepSearch">[docs]</a>    <span class="k">def</span> <span class="nf">prepSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optional method that can be implemented in preparation of shuffling.</span>

<span class="sd">        Often used to prepare the scope of a shuffling branch search.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This was used historically to keep a long-lived fuel handler in sync</span>
<span class="sd">        with the reactor and can now technically be removed from the API, but</span>
<span class="sd">        many historical fuel management inputs still expect it to be called</span>
<span class="sd">        by the framework, so here it remains. New developments should</span>
<span class="sd">        avoid using it. Most code using it has been refactored to just use</span>
<span class="sd">        a ``_prepSearch`` private method.</span>

<span class="sd">        It now should not be used and will trigger a DeprecationWarning</span>
<span class="sd">        in the constructor. It&#39;s still here because old user-input code</span>
<span class="sd">        calls the parent&#39;s prepSearch, which is this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;`FuelHandler.prepSearch` is being deprecated from the framework. Please &quot;</span>
            <span class="s2">&quot;change your fuel management input to call this method directly.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="FuelHandler.findAssembly"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.findAssembly">[docs]</a>    <span class="k">def</span> <span class="nf">findAssembly</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">targetRing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">compareTo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">forceSide</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclusions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">typeSpec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mandatoryLocations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">zoneList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">excludedLocations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">minParam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">minVal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxParam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxVal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">findMany</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exactType</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">acceptFirstCandidateRing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">blockLevelMax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">findFromSfp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">maxNumAssems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">circularRingFlag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search reactor for assemblies with various criterion. Primarily for shuffling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        targetRing : int, optional</span>
<span class="sd">            The ring in which to search</span>

<span class="sd">        width : tuple of integers</span>
<span class="sd">            A (size, side) tuple where size is the number of rings on either side to also check.</span>
<span class="sd">            side=1: only look in higher, -1: only look lower, 0: both sides</span>

<span class="sd">        param : string, optional</span>
<span class="sd">            A block (if blockLevelMax) or assem level param name such as &#39;power&#39; or &#39;percentBu&#39;</span>
<span class="sd">            (requires compareTo).</span>

<span class="sd">        compareTo : float or Assembly instance</span>
<span class="sd">            an assembly to be compared to. Alternatively, a floating point number to compare to.</span>
<span class="sd">            Even more alternatively,  an (assembly,mult) or (float,mult) tuple where mult is a</span>
<span class="sd">            multiplier. For example, if you wanted an assembly that had a bu close to half of</span>
<span class="sd">            assembly bob, you&#39;d give param=&#39;percentBu&#39;, compareTo=(bob,0.5) If you want one with a</span>
<span class="sd">            bu close to 0.3, you&#39;d do param=&#39;percentBu&#39;,compareTo=0.3. Yes, if you give a (float,</span>
<span class="sd">            multiplier) tuple, the code will make fun of you for not doing your own math, but will</span>
<span class="sd">            still operate as expected.</span>

<span class="sd">        forceSide : bool, optional</span>
<span class="sd">            requires the found assembly to have either 1: higher, -1: lower, None: any param than</span>
<span class="sd">             compareTo</span>

<span class="sd">        exclusions : list, optional</span>
<span class="sd">            List of assemblies that will be excluded from the search</span>

<span class="sd">        minParam : float or list, optional</span>
<span class="sd">            a parameter to compare to minVal for setting lower bounds. If list, must correspond to</span>
<span class="sd">            parameters in minVal in order.</span>

<span class="sd">        maxParam : float or list, optional</span>
<span class="sd">            a parameter to compare to maxVal for setting upper bounds of acceptable assemblies.</span>
<span class="sd">            If list,</span>
<span class="sd">            must correspond to parameters in maxVal in order.</span>

<span class="sd">        minVal : float or list, optional</span>
<span class="sd">            a value or a (parameter, multiplier) tuple for setting lower bounds</span>

<span class="sd">            For instance, if minParam = &#39;timeToLimit&#39; and minVal=10, only assemblies with</span>
<span class="sd">            timeToLimit higher than 10 will be returned.  (Of course, there is also maxParam and</span>
<span class="sd">            maxVal)</span>

<span class="sd">        maxVal : float or list, optional</span>
<span class="sd">            a value or a (parameter, multiplier) tuple for setting upper bounds</span>

<span class="sd">        mandatoryLocations : list, optional</span>
<span class="sd">            a list of string-representations of locations in the core for limiting the search to</span>
<span class="sd">            several places</span>

<span class="sd">            Any locations also included in `excludedLocations` will be excluded.</span>

<span class="sd">        excludedLocations : list, optional</span>
<span class="sd">            a list of string-representations of locations in the core that will be excluded from</span>
<span class="sd">            the search</span>

<span class="sd">        zoneList : list, optional</span>
<span class="sd">            name of a zone defined in settings.py that will be picked from. Under development</span>

<span class="sd">        findMany : bool, optional</span>
<span class="sd">            If True, will return a list of assembies that match. Don&#39;t give a param.</span>

<span class="sd">        typeSpec : Flags or list of Flags, optional</span>
<span class="sd">            only assemblies with this type list will be returned. If none, only fuel will be found.</span>

<span class="sd">        coords : tuple, optional</span>
<span class="sd">            x,y tuple in cm. the fuel handler will try to find an assembly with a center closest to</span>
<span class="sd">            that point</span>

<span class="sd">        exactType : bool, optional</span>
<span class="sd">            require type to be exactly equal to what&#39;s in the type list. So</span>
<span class="sd">            Flags.IGNITER | Flags.FUEL is not Flags.INNER | Flags.IGNITER | Flags.FUEL</span>

<span class="sd">        acceptFirstCandidateRing : bool, optional</span>
<span class="sd">            takes the first assembly found in the earliest ring (without searching all rings for a</span>
<span class="sd">            maxBu, for example) So if the candidate rings are 1-10 and we&#39;re looking for igniter</span>
<span class="sd">            fuel with a maxBurnup, we don&#39;t get the max burnup in all those rings, but rather the</span>
<span class="sd">            igniter with the max burnup in the ring closest to 1. If there are no igniters until</span>
<span class="sd">            ring 4, you will get an igniter in ring 4.</span>

<span class="sd">        blockLevelMax : bool, optional</span>
<span class="sd">            If true, the param to search for will be built as the maximum block-level param of this</span>
<span class="sd">            name instead of the assembly param. This avoids the need to assign assembly level params</span>
<span class="sd">            sometimes.</span>
<span class="sd">            default: false.</span>

<span class="sd">        findFromSfp : bool, optional</span>
<span class="sd">            if true, will look in the spent-fuel pool instead of in the core.</span>

<span class="sd">        maxNumAssems : int, optional</span>
<span class="sd">            The maximum number of assemblies to return. Only relevant if findMany==True</span>

<span class="sd">        circularRingFlag : bool, optional</span>
<span class="sd">            A flag to toggle on using rings that are based on distance from the center of the</span>
<span class="sd">            reactor</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The call signature on this method may have gotten slightly out of hand as</span>
<span class="sd">        valuable capabilities were added in fuel management studies. For additional expansion,</span>
<span class="sd">        it may be worth reconsidering the design of these query operations ;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Assembly instance or assemList of assembly instances that match criteria, or None if none</span>
<span class="sd">        match</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        feed = self.findAssembly(targetRing=4,</span>
<span class="sd">                                 width=(0,0),</span>
<span class="sd">                                 param=&#39;maxPercentBu&#39;,</span>
<span class="sd">                                 compareTo=100,</span>
<span class="sd">                                 typeSpec=Flags.FEED | Flags.FUEL)</span>

<span class="sd">        returns the feed fuel assembly in ring 4 that has a burnup closest to 100% (the highest</span>
<span class="sd">        burnup assembly)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">compareAssem</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Check whether the candidate assembly should replace the current ideal</span>
<span class="sd">            assembly.</span>

<span class="sd">            Given a candidate tuple (diff1, a1) and current tuple (diff2, a2), decide</span>
<span class="sd">            whether the candidate is better than the current ideal. This first compares</span>
<span class="sd">            the diff1 and diff2 values. If diff1 is sufficiently less than diff2, a1</span>
<span class="sd">            wins, returning True. Otherwise, False. If diff1 and diff2 are sufficiently</span>
<span class="sd">            close, the assembly with the lesser assemNum wins. This should result in a</span>
<span class="sd">            more stable comparison than on floating-point comparisons alone.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span> <span class="o">&lt;</span> <span class="n">current</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">assemNum</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">paramName</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">blockLevelMax</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">getChildParamValues</span><span class="p">(</span><span class="n">paramName</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">paramName</span><span class="p">]</span>

        <span class="n">assemList</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list for storing multiple results if findMany is true.</span>

        <span class="c1"># process input arguments</span>
        <span class="k">if</span> <span class="n">targetRing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># look through the full core</span>
            <span class="n">targetRing</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">width</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclusions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclusions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">minVal</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># list given with multiple mins</span>
            <span class="n">minVals</span> <span class="o">=</span> <span class="n">minVal</span>
            <span class="n">minParams</span> <span class="o">=</span> <span class="n">minParam</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minVals</span> <span class="o">=</span> <span class="p">[</span><span class="n">minVal</span><span class="p">]</span>
            <span class="n">minParams</span> <span class="o">=</span> <span class="p">[</span><span class="n">minParam</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maxVal</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">maxVals</span> <span class="o">=</span> <span class="n">maxVal</span>
            <span class="n">maxParams</span> <span class="o">=</span> <span class="n">maxParam</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># just one given. put it in a list so the below machinery can handle it.</span>
            <span class="n">maxVals</span> <span class="o">=</span> <span class="p">[</span><span class="n">maxVal</span><span class="p">]</span>
            <span class="n">maxParams</span> <span class="o">=</span> <span class="p">[</span><span class="n">maxParam</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">typeSpec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># restrict motions to fuel only</span>
            <span class="c1"># not really necessary. take this default out if you want to move control rods, etc.</span>
            <span class="n">typeSpec</span> <span class="o">=</span> <span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span>

        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e60</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># compareTo can either be a tuple, a value, or an assembly</span>
        <span class="c1"># if it&#39;s a tuple, it can either be an int/float and a multiplier, or an assembly and a multiplier</span>
        <span class="c1"># if it&#39;s not a tuple, the multiplier will be assumed to be 1.0</span>

        <span class="n">mult</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># if no mult brought in, just assume 1.0</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compareTo</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># tuple (assem or int/float, multiplier) brought in.</span>
            <span class="c1"># separate it</span>
            <span class="n">compareTo</span><span class="p">,</span> <span class="n">mult</span> <span class="o">=</span> <span class="n">compareTo</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compareTo</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compareTo</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="c1"># floating point or int.</span>
            <span class="n">compVal</span> <span class="o">=</span> <span class="n">compareTo</span> <span class="o">*</span> <span class="n">mult</span>
        <span class="k">elif</span> <span class="n">param</span><span class="p">:</span>
            <span class="c1"># assume compareTo is an assembly</span>
            <span class="n">compVal</span> <span class="o">=</span> <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">compareTo</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="o">*</span> <span class="n">mult</span>

        <span class="k">if</span> <span class="n">coords</span><span class="p">:</span>
            <span class="c1"># find the assembly closest to xt,yt if coords are given without considering params.</span>
            <span class="n">aTarg</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">minD</span> <span class="o">=</span> <span class="mf">1e10</span>
            <span class="n">xt</span><span class="p">,</span> <span class="n">yt</span> <span class="o">=</span> <span class="n">coords</span>  <span class="c1"># assume (x,y) tuple.</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">():</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">()</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">yt</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xt</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">minD</span><span class="p">:</span>
                    <span class="n">minD</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="n">aTarg</span> <span class="o">=</span> <span class="n">a</span>
            <span class="k">return</span> <span class="n">aTarg</span>

        <span class="k">if</span> <span class="n">findFromSfp</span><span class="p">:</span>
            <span class="c1"># hack to enable SFP searching.</span>
            <span class="n">candidateRings</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SFP&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># set up candidateRings based on targetRing and width. The target rings comes first b/c it is preferred.</span>
            <span class="n">candidateRings</span> <span class="o">=</span> <span class="p">[</span><span class="n">targetRing</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">width</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># 0 or -1 implies that the inner rings can be added.</span>
                <span class="k">for</span> <span class="n">inner</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">candidateRings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">targetRing</span> <span class="o">-</span> <span class="n">inner</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="p">)</span>  <span class="c1"># +1 to get 1,2,3 instead of 0,1,2</span>
            <span class="k">if</span> <span class="n">width</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if 1, add in the outer rings</span>
                <span class="k">for</span> <span class="n">outer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">candidateRings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">targetRing</span> <span class="o">+</span> <span class="n">outer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># get lists of assemblies in each candidate ring. Do it in this order in case we prefer ones in the first.</span>
        <span class="c1"># scan through all assemblies and find the one (or more) that best fits the criteria</span>
        <span class="k">for</span> <span class="n">ringI</span><span class="p">,</span> <span class="n">assemsInRings</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_getAssembliesInRings</span><span class="p">(</span>
                <span class="n">candidateRings</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">exactType</span><span class="p">,</span> <span class="n">exclusions</span><span class="p">,</span> <span class="n">circularRingFlag</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemsInRings</span><span class="p">:</span>
                <span class="n">innocent</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Check that this assembly&#39;s minParam is &gt; the minimum for each minParam</span>
                <span class="k">for</span> <span class="n">minIndex</span><span class="p">,</span> <span class="n">minVal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">minVals</span><span class="p">):</span>
                    <span class="n">minParam</span> <span class="o">=</span> <span class="n">minParams</span><span class="p">[</span><span class="n">minIndex</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">minParam</span><span class="p">:</span>
                        <span class="c1"># a minimum was specified. Check to see if we&#39;re ok</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">minVal</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                            <span class="c1"># tuple turned in. it&#39;s a multiplier and a param</span>
                            <span class="n">realMinVal</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">minVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">minVal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">realMinVal</span> <span class="o">=</span> <span class="n">minVal</span>

                        <span class="k">if</span> <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">minParam</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">realMinVal</span><span class="p">:</span>
                            <span class="c1"># this assembly does not meet the minVal specifications. Skip it.</span>
                            <span class="n">innocent</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>  <span class="c1"># for speed (not a big deal here)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">innocent</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Check upper bounds, to make sure this assembly doesn&#39;t have maxParams&gt;maxVals</span>
                <span class="k">for</span> <span class="n">maxIndex</span><span class="p">,</span> <span class="n">maxVal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">maxVals</span><span class="p">):</span>
                    <span class="n">maxParam</span> <span class="o">=</span> <span class="n">maxParams</span><span class="p">[</span><span class="n">maxIndex</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">maxParam</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maxVal</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                            <span class="c1"># tuple turned in. it&#39;s a multiplier and a param</span>
                            <span class="n">realMaxVal</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">maxVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">maxVal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">realMaxVal</span> <span class="o">=</span> <span class="n">maxVal</span>

                        <span class="k">if</span> <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">maxParam</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">realMaxVal</span><span class="p">:</span>
                            <span class="c1"># this assembly has a maxParam that&#39;s higher than maxVal and therefore</span>
                            <span class="c1"># doesn&#39;t qualify. skip it.</span>
                            <span class="n">innocent</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">innocent</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Check to see if this assembly is in the list of candidate locations. if not, skip it.</span>
                <span class="k">if</span> <span class="n">mandatoryLocations</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mandatoryLocations</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="n">excludedLocations</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="ow">in</span> <span class="n">excludedLocations</span><span class="p">:</span>
                        <span class="c1"># this assembly is in the excluded location list. skip it.</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="n">zoneList</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># guilty until proven innocent</span>
                    <span class="k">for</span> <span class="n">zone</span> <span class="ow">in</span> <span class="n">zoneList</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="ow">in</span> <span class="n">zone</span><span class="p">:</span>
                            <span class="c1"># great! it&#39;s in there, so we&#39;ll accept this assembly</span>
                            <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># innocent</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                        <span class="c1"># this assembly is not in any of the zones in the zone list. skip it.</span>
                        <span class="k">continue</span>

                <span class="c1"># Now find the assembly with the param closest to the target val.</span>
                <span class="k">if</span> <span class="n">param</span><span class="p">:</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="o">-</span> <span class="n">compVal</span><span class="p">)</span>

                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">forceSide</span> <span class="o">==</span> <span class="mi">1</span>
                        <span class="ow">and</span> <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">compVal</span>
                        <span class="ow">and</span> <span class="n">compareAssem</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">minDiff</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="c1"># forceSide=1, so that means look in rings further out</span>
                        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">(</span>
                        <span class="n">forceSide</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="ow">and</span> <span class="n">getParamWithBlockLevelMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">compVal</span>
                        <span class="ow">and</span> <span class="n">compareAssem</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">minDiff</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="c1"># forceSide=-1, so that means look in rings closer in from the targetRing</span>
                        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">compareAssem</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">minDiff</span><span class="p">):</span>
                        <span class="c1"># no preference of which side, just take the one with the closest param.</span>
                        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># no param specified. Just return one closest to the target ring</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">targetRing</span><span class="p">:</span>
                        <span class="c1"># short circuit the search</span>
                        <span class="k">if</span> <span class="n">findMany</span><span class="p">:</span>
                            <span class="n">assemList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">a</span>
                    <span class="k">elif</span> <span class="p">(</span>
                        <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">targetRing</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">):</span>
                        <span class="n">minDiff</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">targetRing</span><span class="p">),</span>
                            <span class="n">a</span><span class="p">,</span>
                        <span class="p">)</span>

                <span class="k">if</span> <span class="n">findMany</span><span class="p">:</span>
                    <span class="c1"># returning many assemblies. If there&#39;s a param, we&#39;d like it to be honored by</span>
                    <span class="c1"># ordering this list from smallest diff to largest diff.</span>
                    <span class="n">assemList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">diff</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">ringI</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">acceptFirstCandidateRing</span> <span class="ow">and</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># an acceptable assembly was found in the targetRing (ringI==0)</span>
                <span class="c1"># and the user requested this to be returned. Therefore, return it without</span>
                <span class="c1"># scanning through the additional rings.</span>
                <span class="k">return</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># warning(&quot;can&#39;t find assembly in targetRing %d with close %s to %s&quot; % (targetRing,param,compareTo),&#39;findAssembly&#39;)</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">findMany</span><span class="p">:</span>
            <span class="n">assemList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># prefer items that have params that are the closest to the value.</span>
            <span class="c1"># extract the assemblies.</span>
            <span class="n">assemsInRings</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">diff</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemList</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">maxNumAssems</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">assemsInRings</span><span class="p">[:</span><span class="n">maxNumAssems</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">assemsInRings</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">minDiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_getAssembliesInRings</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ringList</span><span class="p">,</span>
        <span class="n">typeSpec</span><span class="o">=</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">,</span>
        <span class="n">exactType</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">exclusions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">circularRingFlag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        find assemblies in particular rings</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ringList : list</span>
<span class="sd">            List of integer ring numbers to find assemblies in. Optionally, a string specifiying a</span>
<span class="sd">            special location like the SFP (spent fuel pool)</span>

<span class="sd">        typeSpec : Flags or iterable of Flags, optional</span>
<span class="sd">            Flag types to restrict assemblies to</span>

<span class="sd">        exactType : bool, optional</span>
<span class="sd">            Match the type in typelist exactly</span>

<span class="sd">        exclusions : list of Assemblies, optional</span>
<span class="sd">            exclude these assemblies from the results</span>

<span class="sd">        circularRingFlag : bool</span>
<span class="sd">            A flag to toggle on using rings that are based on distance from the center of the reactor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        assemblyList : list</span>
<span class="sd">            List of assemblies in each ring of the ringList. [[a1,a2,a3],[a4,a5,a6,a7],...]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">assemblyList</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ringList</span><span class="p">))]</span>  <span class="c1"># empty lists for each ring</span>
        <span class="k">if</span> <span class="n">exclusions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclusions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">exclusions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclusions</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">circularRingFlag</span><span class="p">:</span>
            <span class="n">assemListTmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">assemListTmp2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">ringList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SFP&quot;</span><span class="p">:</span>
                <span class="c1"># kind of a hack for now. Need the capability.</span>
                <span class="n">assemblyList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">getChildren</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ringNumber</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ringList</span><span class="p">):</span>
                    <span class="n">assemListTmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssembliesInCircularRing</span><span class="p">(</span>
                        <span class="n">ringNumber</span><span class="p">,</span> <span class="n">typeSpec</span><span class="p">,</span> <span class="n">exactType</span><span class="p">,</span> <span class="n">exclusions</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemListTmp</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">exclusions</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exactType</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="c1"># save only the assemblies not in the exclusions and with the proper type</span>
                        <span class="n">assemListTmp2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                    <span class="c1"># make the list of lists of assemblies</span>
                    <span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">assemListTmp2</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">ringList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;SFP&quot;</span><span class="p">:</span>
                <span class="c1"># kind of a hack for now. Need the capability.</span>
                <span class="n">assemList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">getChildren</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">assemList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">exclusions</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">typeSpec</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="n">exactType</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;SFP&quot;</span><span class="p">:</span>
                    <span class="n">ring</span> <span class="o">=</span> <span class="s2">&quot;SFP&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ring</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">ringList</span><span class="p">:</span>
                    <span class="c1"># keep it in the right order</span>
                    <span class="n">assemblyList</span><span class="p">[</span><span class="n">ringList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ring</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">assemblyList</span>

<div class="viewcode-block" id="FuelHandler.buildRingSchedule"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.buildRingSchedule">[docs]</a>    <span class="k">def</span> <span class="nf">buildRingSchedule</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chargeRing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dischargeRing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">jumpRingFrom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">jumpRingTo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">coarseFactor</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a ring schedule for shuffling.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        General enough to do convergent, divergent, or any combo, plus jumprings.</span>

<span class="sd">        The center of the core is ring 1, based on the DIF3D numbering scheme.</span>

<span class="sd">        Jump ring behavior can be generalized by first building a base ring list</span>
<span class="sd">        where assemblies get charged to H and discharge from A::</span>

<span class="sd">            [A,B,C,D,E,F,G,H]</span>


<span class="sd">        If a jump should be placed where it jumps from ring G to C, reversed back to F, and then discharges from A,</span>
<span class="sd">        we simply reverse the sublist [C,D,E,F], leaving us with::</span>

<span class="sd">            [A,B,F,E,D,C,G,H]</span>


<span class="sd">        A less-complex, more standard convergent-divergent scheme is a subcase of this, where the</span>
<span class="sd">        sublist [A,B,C,D,E] or so is reversed, leaving::</span>

<span class="sd">            [E,D,C,B,A,F,G,H]</span>


<span class="sd">        So the task of this function is simply to determine what subsection, if any, to reverse of</span>
<span class="sd">        the baselist.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chargeRing : int, optional</span>
<span class="sd">            The peripheral ring into which an assembly enters the core. Default is outermost ring.</span>

<span class="sd">        dischargeRing : int, optional</span>
<span class="sd">            The last ring an assembly sits in before discharging. Default is jumpRing-1</span>

<span class="sd">        jumpRingFrom : int</span>
<span class="sd">            The last ring an assembly sits in before jumping to the center</span>

<span class="sd">        jumpRingTo : int, optional</span>
<span class="sd">            The inner ring into which a jumping assembly jumps. Default is 1.</span>

<span class="sd">        coarseFactor : float, optional</span>
<span class="sd">            A number between 0 and 1 where 0 hits all rings and 1 only hits the outer, rJ, center, and rD rings.</span>
<span class="sd">            This allows coarse shuffling, with large jumps. Default: 0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ringSchedule : list</span>
<span class="sd">            A list of rings in order from discharge to charge.</span>

<span class="sd">        ringWidths : list</span>
<span class="sd">            A list of integers corresponding to the ringSchedule determining the widths of each ring area</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; f.buildRingSchedule(17,1,jumpRingFrom=14)</span>
<span class="sd">        ([13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 14, 15, 16, 17],</span>
<span class="sd">        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        findAssembly</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">maxRingInCore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getNumRings</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dischargeRing</span> <span class="o">&gt;</span> <span class="n">maxRingInCore</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Discharge ring </span><span class="si">{</span><span class="n">dischargeRing</span><span class="si">}</span><span class="s2"> is outside the core (max </span><span class="si">{</span><span class="n">maxRingInCore</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="s2">&quot;Changing it to be the max ring&quot;</span>
            <span class="p">)</span>
            <span class="n">dischargeRing</span> <span class="o">=</span> <span class="n">maxRingInCore</span>
        <span class="k">if</span> <span class="n">chargeRing</span> <span class="o">&gt;</span> <span class="n">maxRingInCore</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Charge ring </span><span class="si">{</span><span class="n">chargeRing</span><span class="si">}</span><span class="s2"> is outside the core (max </span><span class="si">{</span><span class="n">maxRingInCore</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="s2">&quot;Changing it to be the max ring.&quot;</span>
            <span class="p">)</span>
            <span class="n">chargeRing</span> <span class="o">=</span> <span class="n">maxRingInCore</span>

        <span class="c1"># process arguments</span>
        <span class="k">if</span> <span class="n">dischargeRing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No discharge ring given, so we default to converging from outside to inside</span>
            <span class="c1"># and therefore discharging from the center</span>
            <span class="n">dischargeRing</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">chargeRing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Charge ring not specified. Since we default to convergent shuffling, we</span>
            <span class="c1"># must insert the fuel at the periphery.</span>
            <span class="n">chargeRing</span> <span class="o">=</span> <span class="n">maxRingInCore</span>
        <span class="k">if</span> <span class="n">jumpRingFrom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">jumpRingFrom</span> <span class="o">&lt;</span> <span class="n">maxRingInCore</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;JumpRingFrom </span><span class="si">{</span><span class="n">jumpRingFrom</span><span class="si">}</span><span class="s2"> is not in the core.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">jumpRingTo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">jumpRingTo</span> <span class="o">&lt;</span> <span class="n">maxRingInCore</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;JumpRingTo </span><span class="si">{</span><span class="n">jumpRingTo</span><span class="si">}</span><span class="s2"> is not in the core.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">chargeRing</span> <span class="o">&gt;</span> <span class="n">dischargeRing</span> <span class="ow">and</span> <span class="n">jumpRingTo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># a convergent shuffle with no jumping. By setting</span>
            <span class="c1"># jumpRingTo to be 1, no jumping will be activated</span>
            <span class="c1"># in the later logic.</span>
            <span class="n">jumpRingTo</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">jumpRingTo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># divergent case. Disable jumping by putting jumpring</span>
            <span class="c1"># at periphery.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">:</span>
                <span class="n">jumpRingTo</span> <span class="o">=</span> <span class="n">maxRingInCore</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">jumpRingTo</span> <span class="o">=</span> <span class="mi">18</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">chargeRing</span> <span class="o">&gt;</span> <span class="n">dischargeRing</span>
            <span class="ow">and</span> <span class="n">jumpRingFrom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">jumpRingFrom</span> <span class="o">&lt;</span> <span class="n">jumpRingTo</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot have outward jumps in convergent cases.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">chargeRing</span> <span class="o">&lt;</span> <span class="n">dischargeRing</span>
            <span class="ow">and</span> <span class="n">jumpRingFrom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">jumpRingFrom</span> <span class="o">&gt;</span> <span class="n">jumpRingTo</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot have inward jumps in divergent cases.&quot;</span><span class="p">)</span>

        <span class="c1"># step 1: build the base rings</span>
        <span class="n">numSteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">dischargeRing</span> <span class="o">-</span> <span class="n">chargeRing</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">coarseFactor</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">numSteps</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># don&#39;t let it be smaller than 2 because linspace(1,5,1)= [1], linspace(1,5,2)= [1,5]</span>
            <span class="n">numSteps</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">baseRings</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">dischargeRing</span><span class="p">,</span> <span class="n">chargeRing</span><span class="p">,</span> <span class="n">numSteps</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># eliminate duplicates.</span>
        <span class="n">newBaseRings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">br</span> <span class="ow">in</span> <span class="n">baseRings</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">br</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">newBaseRings</span><span class="p">:</span>
                <span class="n">newBaseRings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">br</span><span class="p">)</span>
        <span class="n">baseRings</span> <span class="o">=</span> <span class="n">newBaseRings</span>
        <span class="c1"># baseRings = list(set(baseRings)) # eliminate duplicates. but ruins order.</span>
        <span class="c1"># build widths</span>
        <span class="n">widths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ring</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">baseRings</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># 0 is the most restrictive, meaning don&#39;t even look in other rings.</span>
            <span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">baseRings</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ring</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># add the last ring with width 0.</span>

        <span class="c1"># step 2: locate which rings should be reversed to give the jump-ring effect.</span>
        <span class="k">if</span> <span class="n">jumpRingFrom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_closestRingFrom</span><span class="p">,</span> <span class="n">jumpRingFromIndex</span> <span class="o">=</span> <span class="n">findClosest</span><span class="p">(</span>
                <span class="n">baseRings</span><span class="p">,</span> <span class="n">jumpRingFrom</span><span class="p">,</span> <span class="n">indx</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">_closestRingTo</span><span class="p">,</span> <span class="n">jumpRingToIndex</span> <span class="o">=</span> <span class="n">findClosest</span><span class="p">(</span>
                <span class="n">baseRings</span><span class="p">,</span> <span class="n">jumpRingTo</span><span class="p">,</span> <span class="n">indx</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jumpRingToIndex</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># step 3: build the final ring list, potentially with a reversed section</span>
        <span class="n">newBaseRings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">newWidths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># add in the non-reversed section before the reversed section</span>

        <span class="k">if</span> <span class="n">jumpRingFrom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">newBaseRings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">baseRings</span><span class="p">[:</span><span class="n">jumpRingToIndex</span><span class="p">])</span>
            <span class="n">newWidths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">widths</span><span class="p">[:</span><span class="n">jumpRingToIndex</span><span class="p">])</span>
            <span class="c1"># add in reversed section that is jumped</span>
            <span class="n">newBaseRings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">baseRings</span><span class="p">[</span><span class="n">jumpRingToIndex</span><span class="p">:</span><span class="n">jumpRingFromIndex</span><span class="p">]))</span>
            <span class="n">newWidths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">jumpRingToIndex</span><span class="p">:</span><span class="n">jumpRingFromIndex</span><span class="p">]))</span>
            <span class="c1"># add the rest.</span>
            <span class="n">newBaseRings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">baseRings</span><span class="p">[</span><span class="n">jumpRingFromIndex</span><span class="p">:])</span>
            <span class="n">newWidths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">jumpRingFromIndex</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no jump section. Just fill in the rest.</span>
            <span class="n">newBaseRings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">baseRings</span><span class="p">[</span><span class="n">jumpRingToIndex</span><span class="p">:])</span>
            <span class="n">newWidths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">jumpRingToIndex</span><span class="p">:])</span>

        <span class="k">return</span> <span class="n">newBaseRings</span><span class="p">,</span> <span class="n">newWidths</span></div>

<div class="viewcode-block" id="FuelHandler.buildConvergentRingSchedule"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.buildConvergentRingSchedule">[docs]</a>    <span class="k">def</span> <span class="nf">buildConvergentRingSchedule</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dischargeRing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">chargeRing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coarseFactor</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a ring schedule for convergent shuffling from chargeRing to dischargeRing</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dischargeRing : int, optional</span>
<span class="sd">            The last ring an assembly sits in before discharging. If no discharge, this is the one that</span>
<span class="sd">            gets placed where the charge happens. Default: Innermost ring</span>

<span class="sd">        chargeRing : int, optional</span>
<span class="sd">            The peripheral ring into which an assembly enters the core. Default is outermost ring.</span>

<span class="sd">        coarseFactor : float, optional</span>
<span class="sd">            A number between 0 and 1 where 0 hits all rings and 1 only hits the outer, rJ, center, and rD rings.</span>
<span class="sd">            This allows coarse shuffling, with large jumps. Default: 0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        convergent : list</span>
<span class="sd">            A list of rings in order from discharge to charge.</span>

<span class="sd">        conWidths : list</span>
<span class="sd">            A list of integers corresponding to the ringSchedule determining the widths of each ring area</span>

<span class="sd">        Examples</span>
<span class="sd">        -------</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        findAssembly</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># process arguments</span>
        <span class="k">if</span> <span class="n">chargeRing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chargeRing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getNumRings</span><span class="p">()</span>

        <span class="c1"># step 1: build the convergent rings</span>
        <span class="n">numSteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">chargeRing</span> <span class="o">-</span> <span class="n">dischargeRing</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">coarseFactor</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">numSteps</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># don&#39;t let it be smaller than 2 because linspace(1,5,1)= [1], linspace(1,5,2)= [1,5]</span>
            <span class="n">numSteps</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">convergent</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">dischargeRing</span><span class="p">,</span> <span class="n">chargeRing</span><span class="p">,</span> <span class="n">numSteps</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># step 2. eliminate duplicates</span>
        <span class="n">convergent</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">convergent</span><span class="p">)))</span>

        <span class="c1"># step 3. compute widths</span>
        <span class="n">conWidths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ring</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">convergent</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">conWidths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convergent</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ring</span><span class="p">)</span>
        <span class="n">conWidths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># step 4. assemble and return</span>
        <span class="k">return</span> <span class="n">convergent</span><span class="p">,</span> <span class="n">conWidths</span></div>

<div class="viewcode-block" id="FuelHandler.swapAssemblies"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.swapAssemblies">[docs]</a>    <span class="k">def</span> <span class="nf">swapAssemblies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves a whole assembly from one place to another</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a1 : Assembly</span>
<span class="sd">            The first assembly</span>
<span class="sd">        a2 : Assembly</span>
<span class="sd">            The second assembly</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dischargeSwap : swap assemblies where one is outside the core and the other is inside</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">a2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Cannot swap None assemblies. Check your findAssembly results. Skipping swap&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Swapping </span><span class="si">{}</span><span class="s2"> with </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">))</span>
        <span class="c1"># add assemblies into the moved location</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">oldA1Location</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">spatialLocator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transferStationaryBlocks</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
        <span class="n">a1</span><span class="o">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">a2</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>
        <span class="n">a2</span><span class="o">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">oldA1Location</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_swapFluxParam</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_transferStationaryBlocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assembly1</span><span class="p">,</span> <span class="n">assembly2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exchange the stationary blocks (e.g. grid plate) between the moving assemblies</span>

<span class="sd">        These blocks in effect are not moved at all.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;stationaryBlocks&quot;</span><span class="p">]:</span>
            <span class="c1"># this block swap is designed to ensure that all blocks have the</span>
            <span class="c1"># correct parents and children structure at the end of the swaps.</span>
            <span class="n">tempBlock1</span> <span class="o">=</span> <span class="n">assembly1</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">assembly1</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tempBlock1</span><span class="p">)</span>

            <span class="n">tempBlock2</span> <span class="o">=</span> <span class="n">assembly2</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">assembly2</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tempBlock2</span><span class="p">)</span>

            <span class="n">assembly1</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">tempBlock2</span><span class="p">)</span>
            <span class="n">assembly2</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">tempBlock1</span><span class="p">)</span>

<div class="viewcode-block" id="FuelHandler.dischargeSwap"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.dischargeSwap">[docs]</a>    <span class="k">def</span> <span class="nf">dischargeSwap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes one assembly from the core and replace it with another assembly.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        swapAssemblies : swaps assemblies that are already in the core</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Discharge swapping </span><span class="si">{}</span><span class="s2"> for </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">incoming</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">outgoing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Cannot discharge swap None assemblies. Check your findAssembly calls. Skipping&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># add assemblies into the moved location</span>
        <span class="c1"># keep it unique so we don&#39;t get artificially inflated numMoves</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transferStationaryBlocks</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">)</span>

        <span class="c1"># replace the goingOut guy.</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">outgoing</span><span class="o">.</span><span class="n">spatialLocator</span>
        <span class="c1"># say it happened at the end of the previous cycle by sending cycle-1</span>
        <span class="c1"># to removeAssembly, which will look up EOC of last cycle,</span>
        <span class="c1"># which, coincidentally is the same time we&#39;re at right now at BOC.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">removeAssembly</span><span class="p">(</span><span class="n">outgoing</span><span class="p">)</span>

        <span class="c1"># adjust the assembly multiplicity so that it doesnt forget how many it really</span>
        <span class="c1"># represents. This allows us to discharge an assembly from any location in</span>
        <span class="c1"># fractional-core models where the central location may only be one assembly,</span>
        <span class="c1"># whereas other locations are more, and keep proper track of things. In the</span>
        <span class="c1"># future, this mechanism may be used to handle symmetry in general.</span>
        <span class="n">outgoing</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">multiplicity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">getSymmetricEquivalents</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">incoming</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
            <span class="c1"># pull it out of the sfp if it&#39;s in there.</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;removing </span><span class="si">{0}</span><span class="s2"> from the sfp&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">incoming</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">incoming</span><span class="p">)</span>

        <span class="n">incoming</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">multiplicity</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_swapFluxParam</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_swapFluxParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the flux and power params of the new blocks to that of the old and vice versa.</span>

<span class="sd">        This is essential for getting loosely-coupled flux-averaged cross sections from things like</span>
<span class="sd">        :py:class:`armi.physics.neutronics.crossSectionGroupManager.BlockCollectionAverageFluxWeighted`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        incoming, outgoing : Assembly</span>
<span class="sd">            Assembly objects to be swapped</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find the block-based mesh points for each assembly</span>
        <span class="n">meshIn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">findAllAxialMeshPoints</span><span class="p">([</span><span class="n">incoming</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">meshOut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">findAllAxialMeshPoints</span><span class="p">([</span><span class="n">outgoing</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># If the assembly mesh points don&#39;t match, the swap won&#39;t be easy</span>
        <span class="k">if</span> <span class="n">meshIn</span> <span class="o">!=</span> <span class="n">meshOut</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> and </span><span class="si">{1}</span><span class="s2"> have different meshes, resampling.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># grab the current values for incoming and outgoing</span>
            <span class="n">fluxIn</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flux</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">incoming</span><span class="p">]</span>
            <span class="n">mgFluxIn</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">incoming</span><span class="p">]</span>
            <span class="n">powerIn</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">incoming</span><span class="p">]</span>
            <span class="n">fluxOut</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flux</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">outgoing</span><span class="p">]</span>
            <span class="n">mgFluxOut</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">outgoing</span><span class="p">]</span>
            <span class="n">powerOut</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">outgoing</span><span class="p">]</span>

            <span class="c1"># resample incoming to outgoing, and vice versa</span>
            <span class="n">fluxOutNew</span> <span class="o">=</span> <span class="n">resampleStepwise</span><span class="p">(</span><span class="n">meshIn</span><span class="p">,</span> <span class="n">fluxIn</span><span class="p">,</span> <span class="n">meshOut</span><span class="p">)</span>
            <span class="n">mgFluxOutNew</span> <span class="o">=</span> <span class="n">resampleStepwise</span><span class="p">(</span><span class="n">meshIn</span><span class="p">,</span> <span class="n">mgFluxIn</span><span class="p">,</span> <span class="n">meshOut</span><span class="p">)</span>
            <span class="n">powerOutNew</span> <span class="o">=</span> <span class="n">resampleStepwise</span><span class="p">(</span><span class="n">meshIn</span><span class="p">,</span> <span class="n">powerIn</span><span class="p">,</span> <span class="n">meshOut</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">fluxInNew</span> <span class="o">=</span> <span class="n">resampleStepwise</span><span class="p">(</span><span class="n">meshOut</span><span class="p">,</span> <span class="n">fluxOut</span><span class="p">,</span> <span class="n">meshIn</span><span class="p">)</span>
            <span class="n">mgFluxInNew</span> <span class="o">=</span> <span class="n">resampleStepwise</span><span class="p">(</span><span class="n">meshOut</span><span class="p">,</span> <span class="n">mgFluxOut</span><span class="p">,</span> <span class="n">meshIn</span><span class="p">)</span>
            <span class="n">powerInNew</span> <span class="o">=</span> <span class="n">resampleStepwise</span><span class="p">(</span><span class="n">meshOut</span><span class="p">,</span> <span class="n">powerOut</span><span class="p">,</span> <span class="n">meshIn</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># load the new outgoing values into place</span>
            <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">mgFlux</span><span class="p">,</span> <span class="n">power</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">outgoing</span><span class="p">,</span> <span class="n">fluxOutNew</span><span class="p">,</span> <span class="n">mgFluxOutNew</span><span class="p">,</span> <span class="n">powerOutNew</span>
            <span class="p">):</span>
                <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">flux</span>
                <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span> <span class="o">=</span> <span class="n">mgFlux</span>
                <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">power</span>
                <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pdens</span> <span class="o">=</span> <span class="n">power</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>

            <span class="c1"># load the new incoming values into place</span>
            <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">mgFlux</span><span class="p">,</span> <span class="n">power</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">incoming</span><span class="p">,</span> <span class="n">fluxInNew</span><span class="p">,</span> <span class="n">mgFluxInNew</span><span class="p">,</span> <span class="n">powerInNew</span>
            <span class="p">):</span>
                <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">flux</span>
                <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span> <span class="o">=</span> <span class="n">mgFlux</span>
                <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">power</span>
                <span class="n">b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pdens</span> <span class="o">=</span> <span class="n">power</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>

            <span class="k">return</span>

        <span class="c1"># Since the axial mesh points match, do the simple swap</span>
        <span class="k">for</span> <span class="n">bi</span><span class="p">,</span> <span class="p">(</span><span class="n">bIncoming</span><span class="p">,</span> <span class="n">bOutgoing</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">incoming</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">bi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;stationaryBlocks&quot;</span><span class="p">]:</span>
                <span class="c1"># stationary blocks are already swapped</span>
                <span class="k">continue</span>

            <span class="n">incomingFlux</span> <span class="o">=</span> <span class="n">bIncoming</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flux</span>
            <span class="n">incomingMgFlux</span> <span class="o">=</span> <span class="n">bIncoming</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span>
            <span class="n">incomingPower</span> <span class="o">=</span> <span class="n">bIncoming</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span>
            <span class="n">outgoingFlux</span> <span class="o">=</span> <span class="n">bOutgoing</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flux</span>
            <span class="n">outgoingMgFlux</span> <span class="o">=</span> <span class="n">bOutgoing</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span>
            <span class="n">outgoingPower</span> <span class="o">=</span> <span class="n">bOutgoing</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span>

            <span class="k">if</span> <span class="n">outgoingFlux</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">bIncoming</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">outgoingFlux</span>
                <span class="n">bIncoming</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span> <span class="o">=</span> <span class="n">outgoingMgFlux</span>
                <span class="n">bIncoming</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">outgoingPower</span>
                <span class="n">bIncoming</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pdens</span> <span class="o">=</span> <span class="n">outgoingPower</span> <span class="o">/</span> <span class="n">bIncoming</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">incomingFlux</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">bOutgoing</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">incomingFlux</span>
                <span class="n">bOutgoing</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">mgFlux</span> <span class="o">=</span> <span class="n">incomingMgFlux</span>
                <span class="n">bOutgoing</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">incomingPower</span>
                <span class="n">bOutgoing</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">pdens</span> <span class="o">=</span> <span class="n">incomingPower</span> <span class="o">/</span> <span class="n">bOutgoing</span><span class="o">.</span><span class="n">getVolume</span><span class="p">()</span>

<div class="viewcode-block" id="FuelHandler.swapCascade"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.swapCascade">[docs]</a>    <span class="k">def</span> <span class="nf">swapCascade</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assemList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform swaps on a list of assemblies.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        [goingOut,inter1,inter2,goingIn]  will go to</span>
<span class="sd">        [inter1, inter2, goingIn, goingOut] in terms of positions</span>
<span class="sd">        or, in ASCII art::</span>

<span class="sd">             &gt;---------------v</span>
<span class="sd">             |               |</span>
<span class="sd">            [A  &lt;- B &lt;- C &lt;- D]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first check for duplicates</span>
        <span class="k">for</span> <span class="n">assem</span> <span class="ow">in</span> <span class="n">assemList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">assemList</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">assem</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Warning: </span><span class="si">%s</span><span class="s2"> is in the cascade more than once!&quot;</span> <span class="o">%</span> <span class="n">assem</span><span class="p">)</span>

        <span class="c1"># now swap.</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">assemList</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">levels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">assemList</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># If None in the cascade, just skip it. this will lead to slightly unintended shuffling if</span>
                <span class="c1"># the user wasn&#39;t careful enough. Their problem.</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
                    <span class="s2">&quot;Skipping level </span><span class="si">%d</span><span class="s2"> in the cascade because it is none&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">swapAssemblies</span><span class="p">(</span><span class="n">assemList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">assemList</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="FuelHandler.repeatShufflePattern"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.repeatShufflePattern">[docs]</a>    <span class="k">def</span> <span class="nf">repeatShufflePattern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">explicitRepeatShuffles</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repeats the fuel management from a previous ARMI run</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        explicitRepeatShuffles : str</span>
<span class="sd">            The file name that contains the shuffling history from a previous run</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moved : list</span>
<span class="sd">            list of assemblies that moved this cycle</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        typically the explicitRepeatShuffles will be &quot;caseName&quot;+&quot;-SHUFFLES.txt&quot;</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        doRepeatShuffle : Performs moves as processed by this method</span>
<span class="sd">        processMoveList : Converts a stored list of moves into a functional list of assemblies to swap</span>
<span class="sd">        makeShuffleReport : Creates the file that is processed here</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># read moves file</span>
        <span class="n">moves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readMoves</span><span class="p">(</span><span class="n">explicitRepeatShuffles</span><span class="p">)</span>
        <span class="c1"># get the correct cycle number</span>
        <span class="c1"># +1 since cycles starts on 0 and looking for the end of 1st cycle shuffle</span>
        <span class="n">cycle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cycle</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># setup the load and loop chains to be run per cycle</span>
        <span class="n">moveList</span> <span class="o">=</span> <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span>
        <span class="p">(</span>
            <span class="n">loadChains</span><span class="p">,</span>
            <span class="n">loopChains</span><span class="p">,</span>
            <span class="n">enriches</span><span class="p">,</span>
            <span class="n">loadChargeTypes</span><span class="p">,</span>
            <span class="n">loadNames</span><span class="p">,</span>
            <span class="n">_alreadyDone</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processMoveList</span><span class="p">(</span><span class="n">moveList</span><span class="p">)</span>

        <span class="c1"># Now have the move locations</span>
        <span class="n">moved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doRepeatShuffle</span><span class="p">(</span>
            <span class="n">loadChains</span><span class="p">,</span> <span class="n">loopChains</span><span class="p">,</span> <span class="n">enriches</span><span class="p">,</span> <span class="n">loadChargeTypes</span><span class="p">,</span> <span class="n">loadNames</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">moved</span></div>

<div class="viewcode-block" id="FuelHandler.readMoves"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.readMoves">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">readMoves</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        reads a shuffle output file and sets up the moves dictionary</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            The shuffles file to read</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        moves : dict</span>
<span class="sd">            A dictionary of all the moves. Keys are the cycle number. Values are a list</span>
<span class="sd">            of tuples, one tuple for each individual move that happened in the cycle.</span>
<span class="sd">            The items in the tuple are (oldLoc, newLoc, enrichList, assemType).</span>
<span class="sd">            Where oldLoc and newLoc are str representations of the locations and</span>
<span class="sd">            enrichList is a list of mass enrichments from bottom to top.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        repeatShufflePattern : reads this file and repeats the shuffling</span>
<span class="sd">        outage : creates the moveList in the first place.</span>
<span class="sd">        makeShuffleReport : writes the file that is read here.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Could not find/open repeat shuffle file </span><span class="si">{}</span><span class="s2"> in working directory </span><span class="si">{}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>
            <span class="p">)</span>

        <span class="n">moves</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">numMoves</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;ycle&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="c1"># Used to say &quot;Cycle 1 at 0.0 years&quot;. Now says: &quot;Before cycle 1 at 0.0 years&quot; to be more specific.</span>
                <span class="c1"># This RE allows backwards compatibility.</span>
                <span class="c1"># Later, we removed the at x years</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;ycle (\d+)&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">elif</span> <span class="s2">&quot;assembly&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="c1"># this is the new load style where an actual assembly type is written to the shuffle logic</span>
                <span class="c1"># due to legacy reasons, the assembly type will be put into group 4</span>
                <span class="n">pat</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;([A-Za-z0-9!\-]+) moved to ([A-Za-z0-9!\-]+) with assembly type ([A-Za-z0-9!\s]+)\s*(ANAME=\S+)?\s*with enrich list: (.+)&quot;</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span>
                        <span class="s1">&#39;Failed to parse line &quot;</span><span class="si">{0}</span><span class="s1">&quot; in shuffle file&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">oldLoc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">newLoc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">assemType</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span>
                    <span class="mi">3</span>
                <span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>  <span class="c1"># take off any possible trailing whitespace</span>
                <span class="n">movingAssemName</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span>
                    <span class="mi">4</span>
                <span class="p">)</span>  <span class="c1"># will be None for legacy shuffleLogic files. (pre 2013-08)</span>
                <span class="k">if</span> <span class="n">movingAssemName</span><span class="p">:</span>
                    <span class="n">movingAssemName</span> <span class="o">=</span> <span class="n">movingAssemName</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)[</span>
                        <span class="mi">1</span>
                    <span class="p">]</span>  <span class="c1"># extract the actual assembly name.</span>
                <span class="n">enrichList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">oldLoc</span><span class="p">,</span> <span class="n">newLoc</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">movingAssemName</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">numMoves</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="s2">&quot;moved&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="c1"># very old shuffleLogic file.</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Using old *.SHUFFLES.txt loading file&quot;</span><span class="p">,</span>
                    <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Using old shuffles file&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
                    <span class="s2">&quot;([A-Za-z0-9!]+) moved to ([A-Za-z0-9!]+) with enrich list: (.+)&quot;</span><span class="p">,</span>
                    <span class="n">line</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputError</span><span class="p">(</span>
                        <span class="s1">&#39;Failed to parse line &quot;</span><span class="si">{0}</span><span class="s1">&quot; in shuffle file&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">oldLoc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">newLoc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">enrichList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                <span class="c1"># old loading style, just assume that there is a booster as our surrogate</span>
                <span class="n">moves</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">oldLoc</span><span class="p">,</span> <span class="n">newLoc</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="n">numMoves</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Read </span><span class="si">{0}</span><span class="s2"> moves over </span><span class="si">{1}</span><span class="s2"> cycles&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numMoves</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">moves</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">moves</span></div>

<div class="viewcode-block" id="FuelHandler.trackChain"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.trackChain">[docs]</a>    <span class="k">def</span> <span class="nf">trackChain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moveList</span><span class="p">,</span> <span class="n">startingAt</span><span class="p">,</span> <span class="n">alreadyDone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        builds a chain of locations based on starting location</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Takes a moveList and extracts chains. Remembers all it touches.</span>
<span class="sd">        If A moved to B, C moved to D, and B moved to C, this returns</span>
<span class="sd">        A, B, C ,D.</span>

<span class="sd">        Used in some monte carlo physics writers and in repeatShufflePattern</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moveList : list</span>
<span class="sd">            a list of (fromLoc,toLoc,enrichList,assemType,assemName) tuples that occurred at a single outage.</span>

<span class="sd">        startingAt : str</span>
<span class="sd">            A location label where the chain would start. This is important because the discharge</span>
<span class="sd">            moves are built when the SFP is found in a move. This method must find all</span>
<span class="sd">            assemblies in the chain leading up to this particular discharge.</span>

<span class="sd">        alreadyDone : list</span>
<span class="sd">            A list of locations that have already been tracked.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        chain : list</span>
<span class="sd">            The chain as a location list in order</span>
<span class="sd">        enrich : list</span>
<span class="sd">            The axial enrichment distribution of the load assembly.</span>
<span class="sd">        loadName : str</span>
<span class="sd">            The assembly name of the load assembly</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        repeatShufflePattern</span>
<span class="sd">        mcnpInterface.getMoveCards</span>
<span class="sd">        processMoveList</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">alreadyDone</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alreadyDone</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">enrich</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># in case this is a load chain, prep for getting enrich.</span>
        <span class="n">loadName</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">assemType</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">None</span>  <span class="c1"># in case this is a load chain, prep for getting an assembly type</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">fromLoc</span><span class="p">,</span> <span class="n">toLoc</span><span class="p">,</span> <span class="n">_enrichList</span><span class="p">,</span> <span class="n">_assemblyType</span><span class="p">,</span> <span class="n">_assemName</span> <span class="ow">in</span> <span class="n">moveList</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;SFP&quot;</span> <span class="ow">in</span> <span class="n">toLoc</span> <span class="ow">and</span> <span class="s2">&quot;LoadQueue&quot;</span> <span class="ow">in</span> <span class="n">fromLoc</span><span class="p">:</span>
                <span class="c1"># skip dummy moves</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">fromLoc</span><span class="p">,</span> <span class="n">toLoc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">alreadyDone</span><span class="p">:</span>
                <span class="c1"># skip this pair</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">startingAt</span> <span class="ow">in</span> <span class="n">fromLoc</span><span class="p">:</span>
                <span class="c1"># looking for chain involving toLoc</span>
                <span class="c1"># back-track the chain of moves</span>
                <span class="n">chain</span> <span class="o">=</span> <span class="p">[</span><span class="n">fromLoc</span><span class="p">]</span>
                <span class="n">safeCount</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># to break out of crazy loops.</span>
                <span class="n">complete</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">while</span> <span class="p">(</span>
                    <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;LoadQueue&quot;</span><span class="p">,</span> <span class="s2">&quot;ExCore&quot;</span><span class="p">,</span> <span class="s2">&quot;SFP&quot;</span><span class="p">]</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">complete</span>
                    <span class="ow">and</span> <span class="n">safeCount</span> <span class="o">&lt;</span> <span class="mi">100</span>
                <span class="p">):</span>
                    <span class="c1"># look for something going to where the previous one is from</span>
                    <span class="n">lookingFor</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">for</span> <span class="p">(</span>
                        <span class="n">cFromLoc</span><span class="p">,</span>
                        <span class="n">cToLoc</span><span class="p">,</span>
                        <span class="n">cEnrichList</span><span class="p">,</span>
                        <span class="n">cAssemblyType</span><span class="p">,</span>
                        <span class="n">cAssemName</span><span class="p">,</span>
                    <span class="p">)</span> <span class="ow">in</span> <span class="n">moveList</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">cToLoc</span> <span class="o">==</span> <span class="n">lookingFor</span><span class="p">:</span>
                            <span class="n">chain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cFromLoc</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">cFromLoc</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;LoadQueue&quot;</span><span class="p">,</span> <span class="s2">&quot;ExCore&quot;</span><span class="p">,</span> <span class="s2">&quot;SFP&quot;</span><span class="p">]:</span>
                                <span class="c1"># charge-discharge loop complete.</span>
                                <span class="n">enrich</span> <span class="o">=</span> <span class="n">cEnrichList</span>
                                <span class="n">loadName</span> <span class="o">=</span> <span class="n">cAssemName</span>
                                <span class="n">assemType</span> <span class="o">=</span> <span class="n">cAssemblyType</span>
                                <span class="c1"># break from here or else we might get the next LoadQueue&#39;s enrich.</span>
                                <span class="k">break</span>

                    <span class="k">if</span> <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">startingAt</span><span class="p">:</span>
                        <span class="c1"># non-charging loop complete</span>
                        <span class="n">complete</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="n">safeCount</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">safeCount</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;Chain tracking got too long. Check moves.</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="c1"># delete the last item, it&#39;s loadqueue location or the startingFrom</span>
                <span class="c1"># location.</span>
                <span class="n">chain</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

                <span class="c1"># chain tracked. Can jump out of loop early.</span>
                <span class="k">return</span> <span class="n">chain</span><span class="p">,</span> <span class="n">enrich</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">loadName</span>

        <span class="c1"># if we get here, the startingAt location was not found.</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No chain found starting at </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">startingAt</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="n">enrich</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">loadName</span></div>

<div class="viewcode-block" id="FuelHandler.processMoveList"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.processMoveList">[docs]</a>    <span class="k">def</span> <span class="nf">processMoveList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moveList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Processes a move list and extracts fuel management loops and charges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moveList : list</span>
<span class="sd">            A list of information about fuel management from a previous case. Each entry represents a</span>
<span class="sd">            move and includes the following items as a tuple:</span>

<span class="sd">            fromLoc</span>
<span class="sd">                the label of where the assembly was before the move</span>
<span class="sd">            toLoc</span>
<span class="sd">                the label of where the assembly was after the move</span>
<span class="sd">            enrichList</span>
<span class="sd">                a list of block enrichments for the assembly</span>
<span class="sd">            assemType</span>
<span class="sd">                the type of assembly that this is</span>
<span class="sd">            movingAssemName</span>
<span class="sd">                the name of the assembly that is moving from to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loadChains : list</span>
<span class="sd">            list of lists of location labels for each load chain (with charge/discharge). These DO NOT include</span>
<span class="sd">            special location labels like LoadQueue or SFP</span>
<span class="sd">        loopChains : list</span>
<span class="sd">            list of lists of location labels for each loop chain (no charge/discharge)</span>
<span class="sd">        enriches : list</span>
<span class="sd">            The block enrichment distribution of each load assembly</span>
<span class="sd">        loadChargeTypes :list</span>
<span class="sd">            The types of assemblies that get charged.</span>
<span class="sd">        loadNames : list</span>
<span class="sd">            The assembly names of assemblies that get brought into the core from the SFP (useful for pulling out</span>
<span class="sd">            of SFP for round 2, etc.). Will be None for anything else.</span>
<span class="sd">        alreadyDone : list</span>
<span class="sd">            All the locations that were read.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Used in the some Monte Carlo interfaces to convert ARMI moves to their format moves. Also used in</span>
<span class="sd">        repeat shuffling.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        makeShuffleReport : writes the file that is being processed</span>
<span class="sd">        repeatShufflePattern : uses this to repeat shuffles</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alreadyDone</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">loadChains</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># moves that have discharges</span>
        <span class="n">loadChargeTypes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[]</span>
        <span class="p">)</span>  <span class="c1"># the assembly types (strings) that should be used in a load chain.</span>
        <span class="n">loopChains</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># moves that don&#39;t have discharges</span>
        <span class="n">enriches</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># enrichments of each loadChain</span>
        <span class="n">loadNames</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># assembly name of each load assembly (to read from SFP)</span>

        <span class="c1"># first handle all charge/discharge chains by looking for things going to SFP</span>
        <span class="k">for</span> <span class="n">fromLoc</span><span class="p">,</span> <span class="n">toLoc</span><span class="p">,</span> <span class="n">_enrichList</span><span class="p">,</span> <span class="n">_assemType</span><span class="p">,</span> <span class="n">_movingAssemName</span> <span class="ow">in</span> <span class="n">moveList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">toLoc</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SFP&quot;</span><span class="p">,</span> <span class="s2">&quot;ExCore&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="s2">&quot;LoadQueue&quot;</span> <span class="ow">in</span> <span class="n">fromLoc</span><span class="p">:</span>
                <span class="c1"># skip dummy moves</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="s2">&quot;SFP&quot;</span> <span class="ow">in</span> <span class="n">toLoc</span> <span class="ow">or</span> <span class="s2">&quot;ExCore&quot;</span> <span class="ow">in</span> <span class="n">toLoc</span><span class="p">:</span>
                <span class="c1"># discharge. Track chain.</span>
                <span class="n">chain</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">loadAssemName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trackChain</span><span class="p">(</span>
                    <span class="n">moveList</span><span class="p">,</span> <span class="n">startingAt</span><span class="o">=</span><span class="n">fromLoc</span>
                <span class="p">)</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
                    <span class="s2">&quot;Load Chain with load assem </span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">assemType</span><span class="p">,</span> <span class="n">chain</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">loadChains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
                <span class="n">enriches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">enrichList</span><span class="p">)</span>
                <span class="n">loadChargeTypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assemType</span><span class="p">)</span>
                <span class="n">loadNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loadAssemName</span><span class="p">)</span>
                <span class="c1"># track all the locations we saw already so we</span>
                <span class="c1"># don&#39;t use them in the loop moves.</span>
                <span class="n">alreadyDone</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>

        <span class="c1"># go through again, looking for stuff that isn&#39;t in chains.</span>
        <span class="c1"># put them in loop type 3 moves (arbitrary order)</span>
        <span class="k">for</span> <span class="n">fromLoc</span><span class="p">,</span> <span class="n">toLoc</span><span class="p">,</span> <span class="n">_enrichList</span><span class="p">,</span> <span class="n">assemType</span><span class="p">,</span> <span class="n">_movingAssemName</span> <span class="ow">in</span> <span class="n">moveList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">toLoc</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SFP&quot;</span><span class="p">,</span> <span class="s2">&quot;ExCore&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">fromLoc</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;LoadQueue&quot;</span><span class="p">,</span> <span class="s2">&quot;SFP&quot;</span><span class="p">,</span> <span class="s2">&quot;ExCore&quot;</span><span class="p">]:</span>
                <span class="c1"># skip loads/discharges; they&#39;re already done.</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">fromLoc</span> <span class="ow">in</span> <span class="n">alreadyDone</span><span class="p">:</span>
                <span class="c1"># skip repeats</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># normal move</span>
                <span class="n">chain</span><span class="p">,</span> <span class="n">_enrichList</span><span class="p">,</span> <span class="n">_assemType</span><span class="p">,</span> <span class="n">_loadAssemName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trackChain</span><span class="p">(</span>
                    <span class="n">moveList</span><span class="p">,</span> <span class="n">startingAt</span><span class="o">=</span><span class="n">fromLoc</span>
                <span class="p">)</span>
                <span class="n">loopChains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
                <span class="n">alreadyDone</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>

                <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Loop Chain: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chain</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">loadChains</span><span class="p">,</span> <span class="n">loopChains</span><span class="p">,</span> <span class="n">enriches</span><span class="p">,</span> <span class="n">loadChargeTypes</span><span class="p">,</span> <span class="n">loadNames</span><span class="p">,</span> <span class="n">alreadyDone</span></div>

<div class="viewcode-block" id="FuelHandler.doRepeatShuffle"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.doRepeatShuffle">[docs]</a>    <span class="k">def</span> <span class="nf">doRepeatShuffle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">loadChains</span><span class="p">,</span> <span class="n">loopChains</span><span class="p">,</span> <span class="n">enriches</span><span class="p">,</span> <span class="n">loadChargeTypes</span><span class="p">,</span> <span class="n">loadNames</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Actually does the fuel movements required to repeat a shuffle order</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loadChains : list</span>
<span class="sd">            list of lists of location labels for each load chain (with charge/discharge)</span>
<span class="sd">        loopChains : list</span>
<span class="sd">            list of lists of location labels for each loop chain (no charge/discharge)</span>
<span class="sd">        enriches : list</span>
<span class="sd">            The block enrichment distribution of each load assembly</span>
<span class="sd">        loadChargeTypes :list</span>
<span class="sd">            The types of assemblies that get charged.</span>
<span class="sd">        loadNames : list</span>
<span class="sd">            The assembly names of assemblies that get brought into the core (useful for pulling out</span>
<span class="sd">            of SFP for round 2, etc.)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        repeatShufflePattern : coordinates the moves for this cycle</span>
<span class="sd">        processMoveList : builds the input lists</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a helper function for repeatShufflePattern</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">moved</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># shuffle all of the load chain assemblies (These include discharges to SFP</span>
        <span class="c1"># and loads from Loadqueue)</span>

        <span class="c1"># build a lookup table of locations throughout the current core and cache it.</span>
        <span class="n">locContents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">makeLocationLookup</span><span class="p">(</span><span class="n">assemblyLevel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># perform load swaps (with charge/discharge)</span>
        <span class="k">for</span> <span class="n">assemblyChain</span><span class="p">,</span> <span class="n">enrichList</span><span class="p">,</span> <span class="n">assemblyType</span><span class="p">,</span> <span class="n">assemblyName</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">loadChains</span><span class="p">,</span> <span class="n">enriches</span><span class="p">,</span> <span class="n">loadChargeTypes</span><span class="p">,</span> <span class="n">loadNames</span>
        <span class="p">):</span>
            <span class="c1"># convert the labels into actual assemblies to be swapped</span>
            <span class="n">assemblyList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getLocationContents</span><span class="p">(</span>
                <span class="n">assemblyChain</span><span class="p">,</span> <span class="n">assemblyLevel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">locContents</span><span class="o">=</span><span class="n">locContents</span>
            <span class="p">)</span>

            <span class="n">moved</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">)</span>

            <span class="c1"># go through and swap the assemblies knowing that there is a discharge (first one)</span>
            <span class="c1"># and a new assembly brought it (last one)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">swapAssemblies</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Now, everything has been set except the first assembly in the list, which must now be</span>
            <span class="c1"># replaced with a fresh assembly... but which one? The assemblyType string</span>
            <span class="c1"># tells us.</span>
            <span class="c1"># Sometimes enrichment is set on-the-fly by branch searches, so we must</span>
            <span class="c1"># not only use the proper assembly type but also adjust the enrichment.</span>
            <span class="k">if</span> <span class="n">assemblyName</span><span class="p">:</span>
                <span class="c1"># get this assembly from the SFP</span>
                <span class="n">loadAssembly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">getAssembly</span><span class="p">(</span><span class="n">assemblyName</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">loadAssembly</span><span class="p">:</span>
                    <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;the required assembly </span><span class="si">{0}</span><span class="s2"> is not found in the SFP. It contains: </span><span class="si">{1}</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">assemblyName</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">sfp</span><span class="o">.</span><span class="n">getChildren</span><span class="p">())</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;the required assembly </span><span class="si">{0}</span><span class="s2"> is not found in the SFP.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">loadAssembly</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># create a new assembly from the BOL assem templates and adjust the enrichment</span>
                <span class="n">loadAssembly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">createAssemblyOfType</span><span class="p">(</span>
                    <span class="n">enrichList</span><span class="o">=</span><span class="n">enrichList</span><span class="p">,</span> <span class="n">assemType</span><span class="o">=</span><span class="n">assemblyType</span>
                <span class="p">)</span>

            <span class="c1"># replace the goingOut guy (for continual feed cases)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Calling discharge swap with </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">loadAssembly</span><span class="p">,</span> <span class="n">assemblyList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dischargeSwap</span><span class="p">(</span><span class="n">loadAssembly</span><span class="p">,</span> <span class="n">assemblyList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loadAssembly</span><span class="p">)</span>

        <span class="c1"># shuffle all of the loop chain assemblies (no charge/discharge)</span>

        <span class="k">for</span> <span class="n">assemblyChain</span> <span class="ow">in</span> <span class="n">loopChains</span><span class="p">:</span>
            <span class="c1"># convert the labels into actual assemblies to be swapped</span>
            <span class="n">assemblyList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getLocationContents</span><span class="p">(</span>
                <span class="n">assemblyChain</span><span class="p">,</span> <span class="n">assemblyLevel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">locContents</span><span class="o">=</span><span class="n">locContents</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemblyList</span><span class="p">:</span>
                <span class="n">moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="c1"># go through and swap the assemblies knowing that there is a discharge (first one)</span>
            <span class="c1"># and a new assembly brought it (last one)</span>
            <span class="c1"># for i in range(0,-(len(assemblyList)-1),-1):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">swapAssemblies</span><span class="p">(</span><span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">assemblyList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">moved</span></div>

<div class="viewcode-block" id="FuelHandler.buildEqRingSchedule"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.buildEqRingSchedule">[docs]</a>    <span class="k">def</span> <span class="nf">buildEqRingSchedule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ringSchedule</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expands simple ringSchedule input into full-on location schedule</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ringSchedule, r, cs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        locationSchedule : list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">squaredDistanceFromOrigin</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">())</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">origin</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">assemAngle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getLocalCoordinates</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="n">locationSchedule</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># start by expanding the user-input eqRingSchedule list into a list containing</span>
        <span class="c1"># all the rings as it goes.</span>
        <span class="n">ringList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buildEqRingScheduleHelper</span><span class="p">(</span><span class="n">ringSchedule</span><span class="p">)</span>

        <span class="c1"># now build the locationSchedule ring by ring using this ringSchedule.</span>
        <span class="n">lastRing</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">ringList</span><span class="p">:</span>
            <span class="n">assemsInRing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssembliesInRing</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">typeSpec</span><span class="o">=</span><span class="n">Flags</span><span class="o">.</span><span class="n">FUEL</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;circularRingOrder&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;angle&quot;</span><span class="p">:</span>
                <span class="n">sorter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">assemAngle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="s2">&quot;circularRingOrder&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;distanceSmart&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lastRing</span> <span class="o">==</span> <span class="n">ring</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># converging. Put things on the outside first.</span>
                    <span class="n">sorter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="o">-</span><span class="n">squaredDistanceFromOrigin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># diverging. Put things on the inside first.</span>
                    <span class="n">sorter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">squaredDistanceFromOrigin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># purely based on distance. Can mix things up in convergent-divergent cases. Prefer distanceSmart</span>
                <span class="n">sorter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">squaredDistanceFromOrigin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">assemsInRing</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">assemsInRing</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sorter</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assemsInRing</span><span class="p">:</span>
                <span class="n">locationSchedule</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">getLocation</span><span class="p">())</span>
            <span class="n">lastRing</span> <span class="o">=</span> <span class="n">ring</span>
        <span class="k">return</span> <span class="n">locationSchedule</span></div>

<div class="viewcode-block" id="FuelHandler.buildEqRingScheduleHelper"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.buildEqRingScheduleHelper">[docs]</a>    <span class="k">def</span> <span class="nf">buildEqRingScheduleHelper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ringSchedule</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        turns ringScheduler into explicit list of rings</span>

<span class="sd">        Pulled out of buildEqRingSchedule for testing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ringSchedule : list</span>
<span class="sd">            List of ring bounds that is required to be an even number of entries.  These</span>
<span class="sd">            entries then are used in a from - to approach to add the rings.  The from ring will</span>
<span class="sd">            always be included.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ringList : list</span>
<span class="sd">            List of all rings in the order they should be shuffled.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; buildEqRingScheduleHelper([1,5])</span>
<span class="sd">        [1,2,3,4,5]</span>

<span class="sd">        &gt;&gt;&gt; buildEqRingScheduleHelper([1,5,9,6])</span>
<span class="sd">        [1,2,3,4,5,9,8,7,6]</span>

<span class="sd">        &gt;&gt;&gt; buildEqRingScheduleHelper([9,5,3,4,1,2])</span>
<span class="sd">        [9,8,7,6,5,3,4,1,2]</span>

<span class="sd">        &gt;&gt;&gt; buildEqRingScheduleHelper([2,5,1,1])</span>
<span class="sd">        [2,3,4,5,1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ringSchedule</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Ring schedule: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ringSchedule</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Ring schedule does not have an even number of entries.&quot;</span><span class="p">)</span>

        <span class="n">ringList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ringSchedule</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">fromRing</span> <span class="o">=</span> <span class="n">ringSchedule</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">toRing</span> <span class="o">=</span> <span class="n">ringSchedule</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">numRings</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">toRing</span> <span class="o">-</span> <span class="n">fromRing</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">ringList</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">fromRing</span><span class="p">,</span> <span class="n">toRing</span><span class="p">,</span> <span class="n">numRings</span><span class="p">)]</span>
            <span class="p">)</span>

        <span class="c1"># eliminate doubles (but allow a ring to show up multiple times)</span>
        <span class="n">newList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lastRing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">ringList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ring</span> <span class="o">!=</span> <span class="n">lastRing</span><span class="p">:</span>
                <span class="n">newList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span> <span class="ow">and</span> <span class="n">ring</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getNumRings</span><span class="p">():</span>
                <span class="c1"># error checking.</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Ring </span><span class="si">{0}</span><span class="s2"> in eqRingSchedule larger than largest ring in reactor </span><span class="si">{1}</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;Adjust shuffling.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getNumRings</span><span class="p">()),</span>
                    <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;too many rings&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">lastRing</span> <span class="o">=</span> <span class="n">ring</span>
        <span class="n">ringList</span> <span class="o">=</span> <span class="n">newList</span>

        <span class="k">return</span> <span class="n">ringList</span></div>

<div class="viewcode-block" id="FuelHandler.workerOperate"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.workerOperate">[docs]</a>    <span class="k">def</span> <span class="nf">workerOperate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handle a mpi command on the worker nodes.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="FuelHandler.prepShuffleMap"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.prepShuffleMap">[docs]</a>    <span class="k">def</span> <span class="nf">prepShuffleMap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepare a table of current locations for plotting shuffle maneuvers.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oldLocations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">oldLocations</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">getName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span></div>

<div class="viewcode-block" id="FuelHandler.makeShuffleArrows"><a class="viewcode-back" href="../../../../.apidocs/armi.physics.fuelCycle.fuelHandlers.html#armi.physics.fuelCycle.fuelHandlers.FuelHandler.makeShuffleArrows">[docs]</a>    <span class="k">def</span> <span class="nf">makeShuffleArrows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build data for plotting all the previous shuffles as arrows.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arrows : list</span>
<span class="sd">            Values are (currentCoords, oldCoords) tuples</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arrows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="s2">&quot;Building list of shuffle arrows.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">getAssemblies</span><span class="p">():</span>
            <span class="n">currentCoords</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">spatialLocator</span><span class="o">.</span><span class="n">getGlobalCoordinates</span><span class="p">()</span>
            <span class="n">oldCoords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oldLocations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">oldCoords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">oldCoords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">currentCoords</span> <span class="o">!=</span> <span class="n">oldCoords</span><span class="p">):</span>
                <span class="n">arrows</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">oldCoords</span><span class="p">,</span> <span class="n">currentCoords</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">arrows</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2009-2022, TerraPower, LLC.
      <span class="lastupdated">
        Last updated on 2022-08-08.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
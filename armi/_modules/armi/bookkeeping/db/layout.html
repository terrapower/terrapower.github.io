

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>armi.bookkeeping.db.layout &mdash; ARMI 0.6.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme_fixes.css?v=2b77b304" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-dataframe.css?v=e5fbc548" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-data-viewer/jsonview.bundle.css?v=f6ef2277" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/libs/html/datatables.min.css?v=4b4fd840" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/needstable.css?v=5e1b6797" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/need_links.css?v=2150a916" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/need_toggle.css?v=5c6620df" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/need_style.css?v=678fb11e" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/need_core.css?v=f5b60a78" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/modern.css?v=803738c0" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-test-results/common.css?v=9ec2c1d5" />

  
    <link rel="shortcut icon" href="../../../../_static/armiicon_16x16.ico"/>
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=8fa8b3e9"></script>
      <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="../../../../_static/sphinx-data-viewer/jsonview.bundle.js?v=18cd53c5"></script>
      <script src="../../../../_static/sphinx-data-viewer/jsonview_loader.js?v=f7ff7e7d"></script>
      <script src="../../../../_static/sphinx-needs/libs/html/datatables.min.js?v=8a4aee21"></script>
      <script src="../../../../_static/sphinx-needs/libs/html/datatables_loader.js?v=a2cae175"></script>
      <script src="../../../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js?v=dca66431"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            ARMI
              <img src="../../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../qa_docs/index.html">QA Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../.apidocs/modules.html">API Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #233C5B" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ARMI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../../armi.html">armi</a></li>
          <li class="breadcrumb-item"><a href="../../bookkeeping.html">armi.bookkeeping</a></li>
          <li class="breadcrumb-item"><a href="../db.html">armi.bookkeeping.db</a></li>
      <li class="breadcrumb-item active">armi.bookkeeping.db.layout</li>
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for armi.bookkeeping.db.layout</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2022 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Groundwork for ARMI Database, version 3.4.</span>

<span class="sd">When interacting with the database file, the :py:class:`Layout` class is used to help</span>
<span class="sd">map the hierarchical Composite Reactor Model to the flat representation in</span>
<span class="sd">:py:class:`Database &lt;armi.bookkeeping.db.database.Database&gt;`.</span>

<span class="sd">This module also stores packing/packing tools to support</span>
<span class="sd">:py:class:`Database &lt;armi.bookkeeping.db.database.Database&gt;`, as well as database</span>
<span class="sd">versioning information.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">armi</span><span class="w"> </span><span class="kn">import</span> <span class="n">runLog</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor</span><span class="w"> </span><span class="kn">import</span> <span class="n">grids</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.components</span><span class="w"> </span><span class="kn">import</span> <span class="n">Component</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.composites</span><span class="w"> </span><span class="kn">import</span> <span class="n">ArmiObject</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.excoreStructure</span><span class="w"> </span><span class="kn">import</span> <span class="n">ExcoreStructure</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">armi.reactor.reactors</span><span class="w"> </span><span class="kn">import</span> <span class="n">Core</span><span class="p">,</span> <span class="n">Reactor</span>

<span class="c1"># Here we store the Database version information.</span>
<span class="n">DB_MAJOR</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">DB_MINOR</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">DB_VERSION</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">DB_MAJOR</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">DB_MINOR</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># CONSTANTS USED TO PACK AND UNPACK DATA</span>
<span class="n">LOC_NONE</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span>
<span class="n">LOC_COORD</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span>
<span class="n">LOC_INDEX</span> <span class="o">=</span> <span class="s2">&quot;I&quot;</span>
<span class="n">LOC_MULTI</span> <span class="o">=</span> <span class="s2">&quot;M:&quot;</span>

<span class="n">LOCATION_TYPE_LABELS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span> <span class="n">LOC_NONE</span><span class="p">,</span>
    <span class="n">grids</span><span class="o">.</span><span class="n">CoordinateLocation</span><span class="p">:</span> <span class="n">LOC_COORD</span><span class="p">,</span>
    <span class="n">grids</span><span class="o">.</span><span class="n">IndexLocation</span><span class="p">:</span> <span class="n">LOC_INDEX</span><span class="p">,</span>
    <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span><span class="p">:</span> <span class="n">LOC_MULTI</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># NOTE: Here we assume no one assigns min(int)+2 as a meaningful value</span>
<span class="n">NONE_MAP</span> <span class="o">=</span> <span class="p">{</span><span class="nb">float</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">),</span> <span class="nb">str</span><span class="p">:</span> <span class="s2">&quot;&lt;!None!&gt;&quot;</span><span class="p">}</span>
<span class="n">NONE_MAP</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="n">intType</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">intType</span><span class="p">)</span><span class="o">.</span><span class="n">min</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">intType</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="nb">int</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>
<span class="n">NONE_MAP</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="n">intType</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">intType</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">intType</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>
<span class="n">NONE_MAP</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">floatType</span><span class="p">:</span> <span class="n">floatType</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">floatType</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)})</span>


<div class="viewcode-block" id="Layout">
<a class="viewcode-back" href="../../../../.apidocs/armi.bookkeeping.db.layout.html#armi.bookkeeping.db.layout.Layout">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Layout</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Layout class describes the hierarchical layout of the Composite Reactor model</span>
<span class="sd">    in a flat representation for</span>
<span class="sd">    :py:class:`Database &lt;armi.bookkeeping.db.database.Database&gt;`.</span>

<span class="sd">    A Layout is built by starting at the root of a composite tree and recursively</span>
<span class="sd">    appending each node in the tree to a list of data. So the data will be ordered by</span>
<span class="sd">    depth-first search: [r, c, a1, a1b1, a1b1c1, a1b1c2, a1b2, a1b2c1, ..., a2, ...].</span>

<span class="sd">    The layout is also responsible for storing Component attributes, like location,</span>
<span class="sd">    material, and temperatures, which aren&#39;t stored as Parameters. Temperatures,</span>
<span class="sd">    specifically, are rather complicated in ARMI.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">     * Elements in Layout are stored in depth-first order. This permits use of</span>
<span class="sd">       algorithms such as Pre-Order Tree Traversal for efficient traversal of regions</span>
<span class="sd">       of the model.</span>

<span class="sd">     * ``indexInData`` increases monotonically within each object ``type``. For</span>
<span class="sd">       example, the data for all ``HexBlock`` children of a given parent are stored</span>
<span class="sd">       contiguously within the ``HexBlock`` group, and will not be interleaved with</span>
<span class="sd">       data from the ``HexBlock`` children of any of the parent&#39;s siblings.</span>

<span class="sd">     * Aside from the hierarchy, there is no guarantee what order objects are stored</span>
<span class="sd">       in the layout.  The ``Core`` is not necessarily the first child of the</span>
<span class="sd">       ``Reactor``, and is not guaranteed to use the zeroth grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">version</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">h5group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serialNum</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># The index into the parameter datasets corresponding to each object&#39;s class.</span>
        <span class="c1"># E.g., the 5th HexBlock object in the tree would get 5; to look up its</span>
        <span class="c1"># &quot;someParameter&quot; value, you would extract cXXnYY/HexBlock/someParameter[5].</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexInData</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># The number of direct children this object has.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numChildren</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># The type of location that specifies the object&#39;s physical location; see the</span>
        <span class="c1"># associated pack/unpackLocation functions for more information about how</span>
        <span class="c1"># locations are handled.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locationType</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># There is a minor asymmetry here in that before writing to the DB, this is</span>
        <span class="c1"># truly a flat list of tuples. However when reading, this may contain lists of</span>
        <span class="c1"># tuples, which represent MI locations. This comes from the fact that we map the</span>
        <span class="c1"># tuples to Location objects in Database._compose, but map from Locations to</span>
        <span class="c1"># tuples in Layout._createLayout. Ideally we would handle both directions in the</span>
        <span class="c1"># same place so this can be less surprising. Resolving this would require</span>
        <span class="c1"># changing the interface of the various pack/unpack functions, which have</span>
        <span class="c1"># multiple versions, so the update would need to be done with care.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Which grid, as stored in the database, this object uses to arrange its</span>
        <span class="c1"># children</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridIndex</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temperatures</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Used to cache all of the spatial locators so that we can pack them all at</span>
        <span class="c1"># once. The benefit here is that the version checking can happen up front and</span>
        <span class="c1"># less branching down below</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spatialLocators</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">grids</span><span class="o">.</span><span class="n">LocationBase</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># set of grid parameters that have been seen in _createLayout. For efficient</span>
        <span class="c1"># checks for uniqueness</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seenGridParams</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># actual list of grid parameters, with stable order for safe indexing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridParams</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">version</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">groupedComps</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">ArmiObject</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">ArmiObject</span><span class="p">]]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># it should be noted, one of the two inputs must be non-None: comp/h5group</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_createLayout</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locationType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">_packLocations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spatialLocators</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_readLayout</span><span class="p">(</span><span class="n">h5group</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_snToLayoutIndex</span> <span class="o">=</span> <span class="p">{</span><span class="n">sn</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">serialNum</span><span class="p">)}</span>

        <span class="c1"># find all subclasses of Grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridClasses</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">Layout</span><span class="o">.</span><span class="n">allSubclasses</span><span class="p">(</span><span class="n">grids</span><span class="o">.</span><span class="n">Grid</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridClasses</span><span class="p">[</span><span class="s2">&quot;Grid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">Grid</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sn</span><span class="p">):</span>
        <span class="n">layoutIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snToLayoutIndex</span><span class="p">[</span><span class="n">sn</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">[</span><span class="n">layoutIndex</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">layoutIndex</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">serialNum</span><span class="p">[</span><span class="n">layoutIndex</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indexInData</span><span class="p">[</span><span class="n">layoutIndex</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numChildren</span><span class="p">[</span><span class="n">layoutIndex</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locationType</span><span class="p">[</span><span class="n">layoutIndex</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">[</span><span class="n">layoutIndex</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">temperatures</span><span class="p">[</span><span class="n">layoutIndex</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="p">[</span><span class="n">layoutIndex</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_createLayout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populate a hierarchical representation and group the reactor model items by type.</span>

<span class="sd">        This is used when writing a reactor model to the database.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is recursive.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        _readLayout : does the opposite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">compList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupedComps</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">comp</span><span class="p">)]</span>
        <span class="n">compList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serialNum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">serialNum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexInData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numChildren</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="p">))</span>

        <span class="c1"># determine how many components have been read in, to set the grid index</span>
        <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gridType</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">spatialGrid</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">gridParams</span> <span class="o">=</span> <span class="p">(</span><span class="n">gridType</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">spatialGrid</span><span class="o">.</span><span class="n">reduce</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">gridParams</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seenGridParams</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_seenGridParams</span><span class="p">[</span><span class="n">gridParams</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridParams</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gridParams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gridParams</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gridIndex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_seenGridParams</span><span class="p">[</span><span class="n">gridParams</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gridIndex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_spatialLocators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">spatialLocator</span><span class="p">)</span>

        <span class="c1"># set the materials and temperatures</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">temperatures</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">comp</span><span class="o">.</span><span class="n">inputTemperatureInC</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">temperatureInC</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">temperatures</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="o">-</span><span class="mi">900</span><span class="p">,</span> <span class="o">-</span><span class="mi">900</span><span class="p">))</span>  <span class="c1"># an impossible temperature</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">comps</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">comp</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Failed to sort some collection of ArmiObjects for database output: </span><span class="si">{}</span><span class="s2"> value </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">comp</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span>

        <span class="c1"># depth-first search recursion of all components</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_createLayout</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_readLayout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5group</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populate a hierarchical representation and group the reactor model items by type.</span>

<span class="sd">        This is used when reading a reactor model from a database.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        _createLayout : does the opposite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># location is either an index, or a point</span>
            <span class="c1"># iter over list is faster</span>
            <span class="n">locations</span> <span class="o">=</span> <span class="n">h5group</span><span class="p">[</span><span class="s2">&quot;layout/location&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locationType</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">h5group</span><span class="p">[</span><span class="s2">&quot;layout/locationType&quot;</span><span class="p">][:])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">_unpackLocations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locationType</span><span class="p">,</span> <span class="n">locations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">h5group</span><span class="p">[</span><span class="s2">&quot;layout/type&quot;</span><span class="p">][:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">h5group</span><span class="p">[</span><span class="s2">&quot;layout/name&quot;</span><span class="p">][:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">serialNum</span> <span class="o">=</span> <span class="n">h5group</span><span class="p">[</span><span class="s2">&quot;layout/serialNum&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indexInData</span> <span class="o">=</span> <span class="n">h5group</span><span class="p">[</span><span class="s2">&quot;layout/indexInData&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numChildren</span> <span class="o">=</span> <span class="n">h5group</span><span class="p">[</span><span class="s2">&quot;layout/numChildren&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">material</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">h5group</span><span class="p">[</span><span class="s2">&quot;layout/material&quot;</span><span class="p">][:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">temperatures</span> <span class="o">=</span> <span class="n">h5group</span><span class="p">[</span><span class="s2">&quot;layout/temperatures&quot;</span><span class="p">][:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gridIndex</span> <span class="o">=</span> <span class="n">replaceNonsenseWithNones</span><span class="p">(</span><span class="n">h5group</span><span class="p">[</span><span class="s2">&quot;layout/gridIndex&quot;</span><span class="p">][:],</span> <span class="s2">&quot;layout/gridIndex&quot;</span><span class="p">)</span>

            <span class="n">gridGroup</span> <span class="o">=</span> <span class="n">h5group</span><span class="p">[</span><span class="s2">&quot;layout/grids&quot;</span><span class="p">]</span>
            <span class="n">gridTypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">gridGroup</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">][:]]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">gridParams</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">iGrid</span><span class="p">,</span> <span class="n">gridType</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gridTypes</span><span class="p">):</span>
                <span class="n">thisGroup</span> <span class="o">=</span> <span class="n">gridGroup</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">iGrid</span><span class="p">)]</span>

                <span class="n">unitSteps</span> <span class="o">=</span> <span class="n">thisGroup</span><span class="p">[</span><span class="s2">&quot;unitSteps&quot;</span><span class="p">][:]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ibound</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">boundName</span> <span class="o">=</span> <span class="s2">&quot;bounds_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ibound</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">boundName</span> <span class="ow">in</span> <span class="n">thisGroup</span><span class="p">:</span>
                        <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisGroup</span><span class="p">[</span><span class="n">boundName</span><span class="p">][:])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">unitStepLimits</span> <span class="o">=</span> <span class="n">thisGroup</span><span class="p">[</span><span class="s2">&quot;unitStepLimits&quot;</span><span class="p">][:]</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">thisGroup</span><span class="p">[</span><span class="s2">&quot;offset&quot;</span><span class="p">][:]</span> <span class="k">if</span> <span class="n">thisGroup</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;offset&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">geomType</span> <span class="o">=</span> <span class="n">thisGroup</span><span class="p">[</span><span class="s2">&quot;geomType&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">asstr</span><span class="p">()[()]</span> <span class="k">if</span> <span class="s2">&quot;geomType&quot;</span> <span class="ow">in</span> <span class="n">thisGroup</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">symmetry</span> <span class="o">=</span> <span class="n">thisGroup</span><span class="p">[</span><span class="s2">&quot;symmetry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">asstr</span><span class="p">()[()]</span> <span class="k">if</span> <span class="s2">&quot;symmetry&quot;</span> <span class="ow">in</span> <span class="n">thisGroup</span> <span class="k">else</span> <span class="kc">None</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">gridParams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">gridType</span><span class="p">,</span>
                        <span class="n">grids</span><span class="o">.</span><span class="n">GridParameters</span><span class="p">(</span>
                            <span class="n">unitSteps</span><span class="p">,</span>
                            <span class="n">bounds</span><span class="p">,</span>
                            <span class="n">unitStepLimits</span><span class="p">,</span>
                            <span class="n">offset</span><span class="p">,</span>
                            <span class="n">geomType</span><span class="p">,</span>
                            <span class="n">symmetry</span><span class="p">,</span>
                        <span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failed to get layout information from group: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h5group</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">e</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_initComps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">caseTitle</span><span class="p">,</span> <span class="n">bp</span><span class="p">):</span>
        <span class="n">comps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">groupedComps</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span>
            <span class="n">compType</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">serialNum</span><span class="p">,</span>
            <span class="n">numChildren</span><span class="p">,</span>
            <span class="n">location</span><span class="p">,</span>
            <span class="n">locationType</span><span class="p">,</span>
            <span class="n">material</span><span class="p">,</span>
            <span class="n">temperatures</span><span class="p">,</span>
            <span class="n">gridIndex</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">serialNum</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numChildren</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locationType</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">temperatures</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gridIndex</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">Klass</span> <span class="o">=</span> <span class="n">ArmiObject</span><span class="o">.</span><span class="n">TYPES</span><span class="p">[</span><span class="n">compType</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">Klass</span><span class="p">,</span> <span class="n">Reactor</span><span class="p">):</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="n">Klass</span><span class="p">(</span><span class="n">caseTitle</span><span class="p">,</span> <span class="n">bp</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">Klass</span><span class="p">,</span> <span class="n">Core</span><span class="p">):</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="n">Klass</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">Klass</span><span class="p">,</span> <span class="n">ExcoreStructure</span><span class="p">):</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="n">Klass</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">Klass</span><span class="p">,</span> <span class="n">Component</span><span class="p">):</span>
                <span class="c1"># init all dimensions to 0, they will be loaded and assigned after load</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">Klass</span><span class="o">.</span><span class="n">DIMENSION_NAMES</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;modArea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;material&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">material</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;Tinput&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temperatures</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;Thot&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temperatures</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="n">Klass</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="n">Klass</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">gridIndex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gridParams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridParams</span><span class="p">[</span><span class="n">gridIndex</span><span class="p">]</span>
                <span class="n">comp</span><span class="o">.</span><span class="n">spatialGrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridClasses</span><span class="p">[</span><span class="n">gridParams</span><span class="p">[</span><span class="mi">0</span><span class="p">]](</span><span class="o">*</span><span class="n">gridParams</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">armiObject</span><span class="o">=</span><span class="n">comp</span><span class="p">)</span>

            <span class="n">comps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">comp</span><span class="p">,</span> <span class="n">serialNum</span><span class="p">,</span> <span class="n">numChildren</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">locationType</span><span class="p">))</span>
            <span class="n">groupedComps</span><span class="p">[</span><span class="n">compType</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">comps</span><span class="p">,</span> <span class="n">groupedComps</span>

<div class="viewcode-block" id="Layout.writeToDB">
<a class="viewcode-back" href="../../../../.apidocs/armi.bookkeeping.db.layout.html#armi.bookkeeping.db.layout.Layout.writeToDB">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">writeToDB</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5group</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write a chunk of data to the database.</span>

<span class="sd">        .. impl:: Write data to the DB for a given time step.</span>
<span class="sd">            :id: I_ARMI_DB_TIME0</span>
<span class="sd">            :implements: R_ARMI_DB_TIME</span>

<span class="sd">            This method writes a snapshot of the current state of the reactor to the</span>
<span class="sd">            database. It takes a pointer to an existing HDF5 file as input, and it</span>
<span class="sd">            writes the reactor data model to the file in depth-first search order.</span>
<span class="sd">            Other than this search order, there are no guarantees as to what order the</span>
<span class="sd">            objects are written to the file. Though, this turns out to still be very</span>
<span class="sd">            powerful. For instance, the data for all ``HexBlock`` children of a given</span>
<span class="sd">            parent are stored contiguously within the ``HexBlock`` group, and will not</span>
<span class="sd">            be interleaved with data from the ``HexBlock`` children of any of the parent&#39;s siblings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;layout/type&quot;</span> <span class="ow">in</span> <span class="n">h5group</span><span class="p">:</span>
            <span class="c1"># It looks like we have already written the layout to DB, skip for now</span>
            <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">h5group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;layout/type&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">),</span>
                <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;gzip&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">h5group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;layout/name&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">),</span>
                <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;gzip&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">h5group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;layout/serialNum&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">serialNum</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;gzip&quot;</span><span class="p">)</span>
            <span class="n">h5group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;layout/indexInData&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indexInData</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;gzip&quot;</span><span class="p">)</span>
            <span class="n">h5group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;layout/numChildren&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">numChildren</span><span class="p">,</span>
                <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;gzip&quot;</span><span class="p">,</span>
                <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">h5group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;layout/location&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;gzip&quot;</span><span class="p">,</span>
                <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">h5group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;layout/locationType&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locationType</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">),</span>
                <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;gzip&quot;</span><span class="p">,</span>
                <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">h5group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;layout/material&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">),</span>
                <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;gzip&quot;</span><span class="p">,</span>
                <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">h5group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;layout/temperatures&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">temperatures</span><span class="p">,</span>
                <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;gzip&quot;</span><span class="p">,</span>
                <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">h5group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;layout/gridIndex&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">replaceNonesWithNonsense</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridIndex</span><span class="p">),</span> <span class="s2">&quot;layout/gridIndex&quot;</span><span class="p">),</span>
                <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;gzip&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">gridsGroup</span> <span class="o">=</span> <span class="n">h5group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;layout/grids&quot;</span><span class="p">,</span> <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">gridsGroup</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;nGrids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridParams</span><span class="p">)</span>
            <span class="n">gridsGroup</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;type&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">gp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">gp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridParams</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">),</span>
                <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">igrid</span><span class="p">,</span> <span class="n">gridParams</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">gp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridParams</span><span class="p">):</span>
                <span class="n">thisGroup</span> <span class="o">=</span> <span class="n">gridsGroup</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">igrid</span><span class="p">),</span> <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">thisGroup</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;unitSteps&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">gridParams</span><span class="o">.</span><span class="n">unitSteps</span><span class="p">,</span> <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ibound</span><span class="p">,</span> <span class="n">bound</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gridParams</span><span class="o">.</span><span class="n">bounds</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bound</span><span class="p">)</span>
                        <span class="n">thisGroup</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;bounds_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ibound</span><span class="p">),</span> <span class="n">data</span><span class="o">=</span><span class="n">bound</span><span class="p">,</span> <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">thisGroup</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;unitStepLimits&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">gridParams</span><span class="o">.</span><span class="n">unitStepLimits</span><span class="p">,</span> <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">offset</span> <span class="o">=</span> <span class="n">gridParams</span><span class="o">.</span><span class="n">offset</span>
                <span class="n">thisGroup</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;offset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">thisGroup</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">thisGroup</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;geomType&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">gridParams</span><span class="o">.</span><span class="n">geomType</span><span class="p">,</span> <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">thisGroup</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;symmetry&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">gridParams</span><span class="o">.</span><span class="n">symmetry</span><span class="p">,</span> <span class="n">track_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failed to create datasets in: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h5group</span><span class="p">))</span>
            <span class="k">raise</span></div>


<div class="viewcode-block" id="Layout.computeAncestors">
<a class="viewcode-back" href="../../../../.apidocs/armi.bookkeeping.db.layout.html#armi.bookkeeping.db.layout.Layout.computeAncestors">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">computeAncestors</span><span class="p">(</span><span class="n">serialNum</span><span class="p">,</span> <span class="n">numChildren</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list containing the serial number of the parent corresponding to each</span>
<span class="sd">        object at the given depth.</span>

<span class="sd">        Depth in this case means how many layers to reach up to find the desired</span>
<span class="sd">        ancestor. A depth of 1 will yield the direct parent of each element, depth of 2</span>
<span class="sd">        would yield the elemen&#39;s parent&#39;s parent, and so on.</span>

<span class="sd">        The zero-th element will always be None, as the first object is the root element</span>
<span class="sd">        and so has no parent. Subsequent depths will result in more Nones.</span>

<span class="sd">        This function is useful for forming a lightweight sense of how the database</span>
<span class="sd">        contents stitch together, without having to go to the trouble of fully unpacking</span>
<span class="sd">        the Reactor model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        serialNum : List of int</span>
<span class="sd">            List of serial numbers for each object/element, as laid out in Layout</span>
<span class="sd">        numChildren : List of int</span>
<span class="sd">            List of numbers of children for each object/element, as laid out in Layout</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This is not using a recursive approach for a couple of reasons. First, the</span>
<span class="sd">        iterative form isn&#39;t so bad; we just need two stacks. Second, the interface of</span>
<span class="sd">        the recursive function would be pretty unwieldy. We are progressively</span>
<span class="sd">        consuming two lists, of which we would need to keep passing down with an</span>
<span class="sd">        index/cursor, or progressively slice them as we go, which would be pretty</span>
<span class="sd">        inefficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ancestors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

        <span class="n">snStack</span> <span class="o">=</span> <span class="p">[</span><span class="n">serialNum</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">ncStack</span> <span class="o">=</span> <span class="p">[</span><span class="n">numChildren</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">nc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">serialNum</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">numChildren</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">ncStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">nc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ancestors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">snStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">snStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sn</span><span class="p">)</span>
                <span class="n">ncStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ancestors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">snStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">while</span> <span class="n">ncStack</span> <span class="ow">and</span> <span class="n">ncStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">snStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">ncStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># handle deeper scenarios. This is a bit tricky. Store the original</span>
            <span class="c1"># ancestors for the first generation, since that ultimately contains all of</span>
            <span class="c1"># the information that we need. Then in a loop, keep hopping one more layer</span>
            <span class="c1"># of indirection, and indexing into the corresponding location in the</span>
            <span class="c1"># original ancestor array</span>
            <span class="n">indexMap</span> <span class="o">=</span> <span class="p">{</span><span class="n">sn</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">serialNum</span><span class="p">)}</span>
            <span class="n">origAncestors</span> <span class="o">=</span> <span class="n">ancestors</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">ancestors</span> <span class="o">=</span> <span class="p">[</span><span class="n">origAncestors</span><span class="p">[</span><span class="n">indexMap</span><span class="p">[</span><span class="n">ia</span><span class="p">]]</span> <span class="k">if</span> <span class="n">ia</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ancestors</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ancestors</span></div>


<div class="viewcode-block" id="Layout.allSubclasses">
<a class="viewcode-back" href="../../../../.apidocs/armi.bookkeeping.db.layout.html#armi.bookkeeping.db.layout.Layout.allSubclasses">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">allSubclasses</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find all subclasses of the given class, in any namespace.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Layout</span><span class="o">.</span><span class="n">allSubclasses</span><span class="p">(</span><span class="n">c</span><span class="p">)])</span></div>
</div>



<span class="k">def</span><span class="w"> </span><span class="nf">_packLocations</span><span class="p">(</span>
    <span class="n">locations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">grids</span><span class="o">.</span><span class="n">LocationBase</span><span class="p">],</span> <span class="n">minorVersion</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">DB_MINOR</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract information from a location needed to write it to this DB.</span>

<span class="sd">    Each locator has one locationType and up to N location-defining datums,</span>
<span class="sd">    where N is the number of entries in a possible multiindex, or just 1</span>
<span class="sd">    for everything else.</span>

<span class="sd">    Shrink grid locator names for storage efficiency.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Contains some conditionals to still load databases made before</span>
<span class="sd">    db version 3.3 which can be removed once no users care about</span>
<span class="sd">    those DBs anymore.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">minorVersion</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">locationTypes</span><span class="p">,</span> <span class="n">locationData</span> <span class="o">=</span> <span class="n">_packLocationsV1</span><span class="p">(</span><span class="n">locations</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">minorVersion</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">locationTypes</span><span class="p">,</span> <span class="n">locationData</span> <span class="o">=</span> <span class="n">_packLocationsV2</span><span class="p">(</span><span class="n">locations</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">minorVersion</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">locationTypes</span><span class="p">,</span> <span class="n">locationData</span> <span class="o">=</span> <span class="n">_packLocationsV3</span><span class="p">(</span><span class="n">locations</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported minor version: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">minorVersion</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">locationTypes</span><span class="p">,</span> <span class="n">locationData</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_packLocationsV1</span><span class="p">(</span>
    <span class="n">locations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">grids</span><span class="o">.</span><span class="n">LocationBase</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Delete when reading v &lt;=3.2 DB&#39;s no longer wanted.&quot;&quot;&quot;</span>
    <span class="n">locTypes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">locData</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">locations</span><span class="p">:</span>
        <span class="n">locationType</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">locationType</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
            <span class="n">locDatum</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">grids</span><span class="o">.</span><span class="n">IndexLocation</span><span class="p">):</span>
            <span class="n">locDatum</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid location type: </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">locTypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locationType</span><span class="p">)</span>
        <span class="n">locData</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">locDatum</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">locTypes</span><span class="p">,</span> <span class="n">locData</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_packLocationsV2</span><span class="p">(</span>
    <span class="n">locations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">grids</span><span class="o">.</span><span class="n">LocationBase</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Location packing implementation for minor version 3. See module docstring above.&quot;&quot;&quot;</span>
    <span class="n">locTypes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">locData</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">locations</span><span class="p">:</span>
        <span class="n">locationType</span> <span class="o">=</span> <span class="n">LOCATION_TYPE_LABELS</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">loc</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">locDatum</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">loc</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">grids</span><span class="o">.</span><span class="n">CoordinateLocation</span><span class="p">:</span>
            <span class="n">locDatum</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">loc</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">grids</span><span class="o">.</span><span class="n">IndexLocation</span><span class="p">:</span>
            <span class="n">locDatum</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">loc</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span><span class="p">:</span>
            <span class="c1"># encode number of sub-locations to allow in-line unpacking.</span>
            <span class="n">locationType</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">locDatum</span> <span class="o">=</span> <span class="p">[</span><span class="n">subloc</span><span class="o">.</span><span class="n">indices</span> <span class="k">for</span> <span class="n">subloc</span> <span class="ow">in</span> <span class="n">loc</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid location type: </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">locTypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locationType</span><span class="p">)</span>
        <span class="n">locData</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">locDatum</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">locTypes</span><span class="p">,</span> <span class="n">locData</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_packLocationsV3</span><span class="p">(</span>
    <span class="n">locations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">grids</span><span class="o">.</span><span class="n">LocationBase</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Location packing implementation for minor version 4. See module docstring above.&quot;&quot;&quot;</span>
    <span class="n">locTypes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">locData</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">locations</span><span class="p">:</span>
        <span class="n">locationType</span> <span class="o">=</span> <span class="n">LOCATION_TYPE_LABELS</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">loc</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">locDatum</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span> <span class="ow">is</span> <span class="n">grids</span><span class="o">.</span><span class="n">IndexLocation</span><span class="p">:</span>
            <span class="n">locDatum</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc</span><span class="o">.</span><span class="n">getCompleteIndices</span><span class="p">()]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span> <span class="ow">is</span> <span class="n">grids</span><span class="o">.</span><span class="n">CoordinateLocation</span><span class="p">:</span>
            <span class="c1"># CoordinateLocations do not implement getCompleteIndices properly, and we</span>
            <span class="c1"># do not really have a motivation to store them as we do with index</span>
            <span class="c1"># locations.</span>
            <span class="n">locDatum</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span> <span class="ow">is</span> <span class="n">grids</span><span class="o">.</span><span class="n">MultiIndexLocation</span><span class="p">:</span>
            <span class="n">locationType</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">locDatum</span> <span class="o">=</span> <span class="p">[</span><span class="n">subloc</span><span class="o">.</span><span class="n">indices</span> <span class="k">for</span> <span class="n">subloc</span> <span class="ow">in</span> <span class="n">loc</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid location type: </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">locTypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locationType</span><span class="p">)</span>
        <span class="n">locData</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">locDatum</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">locTypes</span><span class="p">,</span> <span class="n">locData</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_unpackLocations</span><span class="p">(</span><span class="n">locationTypes</span><span class="p">,</span> <span class="n">locData</span><span class="p">,</span> <span class="n">minorVersion</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">DB_MINOR</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert location data as read from DB back into data structure for building reactor model.</span>

<span class="sd">    location and locationType will only have different lengths when multiindex locations</span>
<span class="sd">    are used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">minorVersion</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_unpackLocationsV1</span><span class="p">(</span><span class="n">locationTypes</span><span class="p">,</span> <span class="n">locData</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_unpackLocationsV2</span><span class="p">(</span><span class="n">locationTypes</span><span class="p">,</span> <span class="n">locData</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_unpackLocationsV1</span><span class="p">(</span><span class="n">locationTypes</span><span class="p">,</span> <span class="n">locData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Delete when reading v &lt;=3.2 DB&#39;s no longer wanted.&quot;&quot;&quot;</span>
    <span class="n">locsIter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">locData</span><span class="p">)</span>
    <span class="n">unpackedLocs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lt</span> <span class="ow">in</span> <span class="n">locationTypes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lt</span> <span class="o">==</span> <span class="s2">&quot;None&quot;</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">locsIter</span><span class="p">)</span>
            <span class="n">unpackedLocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lt</span> <span class="o">==</span> <span class="s2">&quot;IndexLocation&quot;</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">locsIter</span><span class="p">)</span>
            <span class="c1"># the data is stored as float, so cast back to int</span>
            <span class="n">unpackedLocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loc</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">locsIter</span><span class="p">)</span>
            <span class="n">unpackedLocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">loc</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">unpackedLocs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_unpackLocationsV2</span><span class="p">(</span><span class="n">locationTypes</span><span class="p">,</span> <span class="n">locData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Location unpacking implementation for minor version 3+. See module docstring above.&quot;&quot;&quot;</span>
    <span class="n">locsIter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">locData</span><span class="p">)</span>
    <span class="n">unpackedLocs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lt</span> <span class="ow">in</span> <span class="n">locationTypes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lt</span> <span class="o">==</span> <span class="n">LOC_NONE</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">locsIter</span><span class="p">)</span>
            <span class="n">unpackedLocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lt</span> <span class="o">==</span> <span class="n">LOC_INDEX</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">locsIter</span><span class="p">)</span>
            <span class="c1"># the data is stored as float, so cast back to int</span>
            <span class="n">unpackedLocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loc</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">lt</span> <span class="o">==</span> <span class="n">LOC_COORD</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">locsIter</span><span class="p">)</span>
            <span class="n">unpackedLocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">loc</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">lt</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">LOC_MULTI</span><span class="p">):</span>
            <span class="c1"># extract number of sublocations from e.g. &quot;M:345&quot; string.</span>
            <span class="n">numSubLocs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lt</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">multiLocs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numSubLocs</span><span class="p">):</span>
                <span class="n">subLoc</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">locsIter</span><span class="p">)</span>
                <span class="c1"># All multiindexes sublocs are index locs</span>
                <span class="n">multiLocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">subLoc</span><span class="p">))</span>
            <span class="n">unpackedLocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">multiLocs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read unknown location type </span><span class="si">{</span><span class="n">lt</span><span class="si">}</span><span class="s2">. Invalid DB.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">unpackedLocs</span>


<div class="viewcode-block" id="replaceNonesWithNonsense">
<a class="viewcode-back" href="../../../../.apidocs/armi.bookkeeping.db.layout.html#armi.bookkeeping.db.layout.replaceNonesWithNonsense">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">replaceNonesWithNonsense</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">paramName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">nones</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace instances of ``None`` with nonsense values that can be detected/recovered</span>
<span class="sd">    when reading.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data</span>
<span class="sd">        The numpy array containing ``None`` values that need to be replaced.</span>

<span class="sd">    paramName</span>
<span class="sd">        The name of the parameter who&#39;s data we are treating. Only used for diagnostics.</span>

<span class="sd">    nones</span>
<span class="sd">        An array containing the index locations on the ``None`` elements. It is a little</span>
<span class="sd">        strange to pass these, in but we find these indices to determine whether we need</span>
<span class="sd">        to call this function in the first place, so might as well pass it in, so that</span>
<span class="sd">        we don&#39;t need to perform the operation again.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This only supports situations where the data is a straight-up ``None``, or a valid,</span>
<span class="sd">    database-storable numpy array (or easily convertible to one (e.g. tuples/lists with</span>
<span class="sd">    numerical values)). This does not support, for instance, a numpy ndarray with some</span>
<span class="sd">    Nones in it.</span>

<span class="sd">    For example, the following is supported::</span>

<span class="sd">        [[1, 2, 3], None, [7, 8, 9]]</span>

<span class="sd">    However, the following is not::</span>

<span class="sd">        [[1, 2, 3], [4, None, 6], [7, 8, 9]]</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    replaceNonsenseWithNones</span>
<span class="sd">        Reverses this operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nones</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># loop to find what the default value should be. This is the first non-None</span>
        <span class="c1"># value that we can find.</span>
        <span class="n">defaultValue</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">realType</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">val</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># if multi-dimensional, val[0] could still be an array, val.flat is</span>
                <span class="c1"># a flattened iterator, so next(val.flat) gives the first value in</span>
                <span class="c1"># an n-dimensional array</span>
                <span class="n">realType</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">flat</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">realType</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">defaultValue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">NONE_MAP</span><span class="p">[</span><span class="n">realType</span><span class="p">],</span> <span class="n">val</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">realType</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">realType</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">defaultValue</span> <span class="o">=</span> <span class="n">NONE_MAP</span><span class="p">[</span><span class="n">realType</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Couldn&#39;t find any non-None entries, so it really doesn&#39;t matter what type we</span>
            <span class="c1"># use. Using float, because NaN is nice.</span>
            <span class="n">realType</span> <span class="o">=</span> <span class="nb">float</span>
            <span class="n">defaultValue</span> <span class="o">=</span> <span class="n">NONE_MAP</span><span class="p">[</span><span class="n">realType</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">defaultValue</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">nones</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultValue</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ee</span><span class="p">:</span>
        <span class="n">runLog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
            <span class="s2">&quot;Error while attempting to determine default for </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">value: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">Error: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">paramName</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">ee</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Could not determine None replacement for </span><span class="si">{}</span><span class="s2"> with type </span><span class="si">{}</span><span class="s2">, val </span><span class="si">{}</span><span class="s2">, default </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">paramName</span><span class="p">,</span> <span class="n">realType</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">defaultValue</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">realType</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not coerce data for </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">, data:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">paramName</span><span class="p">,</span> <span class="n">realType</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;O&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Failed to convert data to valid HDF5 type </span><span class="si">{}</span><span class="s2">, data:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">paramName</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">data</span></div>



<div class="viewcode-block" id="replaceNonsenseWithNones">
<a class="viewcode-back" href="../../../../.apidocs/armi.bookkeeping.db.layout.html#armi.bookkeeping.db.layout.replaceNonsenseWithNones">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">replaceNonsenseWithNones</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">paramName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace special nonsense values with ``None``.</span>

<span class="sd">    This essentially reverses the operations performed by</span>
<span class="sd">    :py:func:`replaceNonesWithNonsense`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data</span>
<span class="sd">        The array from the database that contains special ``None`` nonsense values.</span>

<span class="sd">    paramName</span>
<span class="sd">        The param name who&#39;s data we are dealing with. Only used for diagnostics.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    replaceNonesWithNonsense</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: This is closely-related to the NONE_MAP.</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="n">isNone</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="n">isNone</span> <span class="o">=</span> <span class="n">data</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">min</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">):</span>
        <span class="n">isNone</span> <span class="o">=</span> <span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;&lt;!None!&gt;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unable to resolve values that should be None for `</span><span class="si">{}</span><span class="s2">`&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">paramName</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">isNone</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">isNone</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># This is the meat of the logic to replace &quot;nonsense&quot; with None.</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">))</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">isNone</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">result</span><span class="p">[</span><span class="n">isNone</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">result</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2009-2025, TerraPower, LLC.
      <span class="lastupdated">Last updated on 2025-09-23.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
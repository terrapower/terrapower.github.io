

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>armi.plugins &mdash; ARMI 0.2.3 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_fixes.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/armiicon_16x16.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="../../_static/assets/jsonview.bundle.js"></script>
        <script src="../../_static/assets/jsonview_loader.js"></script>
        <script src="../../_static/sphinx-needs/libs/html/datatables.min.js"></script>
        <script src="../../_static/sphinx-needs/libs/html/datatables_loader.js"></script>
        <script src="../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >
          

          
            <a href="../../index.html" class="icon icon-home"> ARMI
          

          
            
            <img src="../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../requirements/index.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../.apidocs/modules.html">API Docs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ARMI</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../armi.html">armi</a> &raquo;</li>
        
      <li>armi.plugins</li>
    
    
  <li class="wy-breadcrumbs-aside">
    
  </li>

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for armi.plugins</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Plugins allow various built-in or external functionality to be brought into the ARMI ecosystem.</span>

<span class="sd">This module defines the hooks that may be defined within plugins. Plugins are ultimately</span>
<span class="sd">incorporated into a :py:class:`armi.pluginManager.ArmiPluginManager`, which live inside</span>
<span class="sd">of a :py:class:`armi.apps.App` object.</span>

<span class="sd">The ``ArmiPluginManager`` is derived from the ``PluginManager`` class provided by the</span>
<span class="sd">``pluggy`` package, which provides a registry of known plugins. Rather than create one</span>
<span class="sd">directly, we use the :py:func:`armi.plugins.getNewPluginManager()` function, which</span>
<span class="sd">handles some of the setup for us.</span>

<span class="sd">From a high-altitude perspective, the plugins provide numerous &quot;hooks&quot;, which allow for</span>
<span class="sd">ARMI to be extended in various ways. Some of these extensions are subtle and play a part</span>
<span class="sd">in how certain ARMI components are initialized or defined. As such, it is necessary to</span>
<span class="sd">register most plugins before some parts of ARMI are imported or exercised in a</span>
<span class="sd">meaningful way. These requirements are in flux, and will ultimately constitute part of</span>
<span class="sd">the specification of the ARMI plugin architecture. For now, to be safe, plugins should</span>
<span class="sd">be registered as soon as possible.</span>

<span class="sd">After forming the ``PluginManager``, the plugin hooks can be accessed through the</span>
<span class="sd">``hook`` attribute. E.g.::</span>

<span class="sd">    &gt;&gt;&gt; armi.getPluginManagerOrFail().hook.exposeInterfaces(cs=cs)</span>

<span class="sd">Don&#39;t forget to use the keyword argument form for all arguments to hooks; ``pluggy``</span>
<span class="sd">requires them to enforce hook specifications.</span>

<span class="sd">The :py:class:`armi.apps.App` class serves as the primary storage location of the</span>
<span class="sd">PluginManager, and also provides some methods to get data out of the plugins more</span>
<span class="sd">ergonomically than through the hooks themselves.</span>

<span class="sd">Some things you may want to bring in via a plugin includes:</span>

<span class="sd">- :py:mod:`armi.settings` and their validators</span>
<span class="sd">- :py:mod:`armi.reactor.components` for custom geometry</span>
<span class="sd">- :py:mod:`armi.reactor.flags` for custom reactor components</span>
<span class="sd">- :py:mod:`armi.interfaces` to define new calculation sequences and interactions with</span>
<span class="sd">  new codes</span>
<span class="sd">- :py:mod:`armi.reactor.parameters` to represent new physical state on the reactor</span>
<span class="sd">- :py:mod:`armi.materials` for custom materials</span>
<span class="sd">- Elements of the :py:mod:`armi.gui`</span>
<span class="sd">- :py:mod:`armi.operators` for adding new operations on reactor models</span>
<span class="sd">- :py:mod:`armi.cli` for adding new operations on input files</span>

<span class="sd">Warning</span>
<span class="sd">-------</span>

<span class="sd">The plugin system was developed to support improved collaboration.  It is new and should</span>
<span class="sd">be considered under development. The API is subject to change as the version of the ARMI</span>
<span class="sd">framework approaches 1.0.</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">Due to the nature of some of these components, there are a couple of restrictions on</span>
<span class="sd">the order in which things can be imported (lest we endeavor to redesign them</span>
<span class="sd">considerably). Examples:</span>

<span class="sd">  - Parameters: All parameter definitions must be present before any ``ArmiObject``</span>
<span class="sd">    objects are instantiated. This is mostly by choice, but also makes the most sense,</span>
<span class="sd">    because the ``ParameterCollection`` s are instance attributes of an ``ArmiObject``,</span>
<span class="sd">    which in turn use ``Parameter`` objects as *class* attributes. We should know</span>
<span class="sd">    what class attributes we have before making instances.</span>

<span class="sd">  - Blueprints: Since blueprints should be extendable with new sections, we must also</span>
<span class="sd">    be able to provide new *class* attributes to extend their behavior. This is</span>
<span class="sd">    because blueprints use the yamlize package, which uses class attributes to define</span>
<span class="sd">    much of the class&#39;s behavior through metaclassing. Therefore, we need to be able</span>
<span class="sd">    to import all plugins *before* importing blueprints.</span>

<span class="sd">Plugins are currently stateless. They do not have ``__init__()`` methods, and when they are</span>
<span class="sd">registered with the PluginMagager, the PluginManager gets the Plugin&#39;s class object</span>
<span class="sd">rather than an instance of that class. Also notice that all of the hooks are</span>
<span class="sd">``@staticmethod``\ s. As a result, they can be called directly off of the class object,</span>
<span class="sd">and only have access to the state passed into them to perform their function. This is a</span>
<span class="sd">deliberate design choice to keep the plugin system simple and to preclude a large class</span>
<span class="sd">of potential bugs. At some point it may make sense to revisit this.</span>


<span class="sd">Other customization points</span>
<span class="sd">--------------------------</span>
<span class="sd">While the Plugin API is the main place for ARMI framework customization, there are</span>
<span class="sd">several other areas where ARMI may be extended or customized. These typically pre-dated</span>
<span class="sd">the Plugin-based architecture, and as the need arise may be migrated to here.</span>

<span class="sd"> - Component types: Component types are registered dynamically through some metaclass</span>
<span class="sd">   magic, found in :py:class:`armi.reactor.components.component.ComponentType` and</span>
<span class="sd">   :py:class:`armi.reactor.composites.CompositeModelType`. Simply defining a new</span>
<span class="sd">   Component subclass should register it with the appropriate ARMI systems. While this</span>
<span class="sd">   is convenient, it does lead to potential issues, as the behavior of ARMI becomes</span>
<span class="sd">   sensitive to module import order and the like; the containing module needs to be</span>
<span class="sd">   imported before the registration occurs, which can be surprising.</span>

<span class="sd"> - Interface input files: Interfaces used to be discovered dynamically, rather than</span>
<span class="sd">   explicitly as they are now in the :py:meth:`armi.plugins.ArmiPlugin.exposeInterfaces`</span>
<span class="sd">   plugin hook. Essentially they functioned as ersatz plugins. One of the ways that they</span>
<span class="sd">   would customize ARMI behavior is through the</span>
<span class="sd">   :py:meth:`armi.physics.interface.Interface.specifyInputs` static method, which is</span>
<span class="sd">   still used to determine inter-Case dependencies and support cloning and hashing Case</span>
<span class="sd">   inputs. Going forward, this approach will likely be deprecated in favor of a plugin</span>
<span class="sd">   hook.</span>

<span class="sd"> - Fuel handler logic: The</span>
<span class="sd">   :py:class:`armi.physics.fuelCycle.fuelHandlers.FuelHandlerInterface` supports</span>
<span class="sd">   customization through the dynamic loading of fuel handler logic modules, based on</span>
<span class="sd">   user settings. This also predated the plugin infrastructure, and may one day be</span>
<span class="sd">   replaced with plugin-based fuel handler logic.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span>

<span class="kn">import</span> <span class="nn">pluggy</span>

<span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">pluginManager</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="kn">import</span> <span class="n">flags</span>

<span class="c1"># Not used during runtime so we could have a coverage drop here. Add the</span>
<span class="c1"># pragma line to tell coverage.py to skip this</span>
<span class="c1"># https://coverage.readthedocs.io/en/stable/excluding.html</span>
<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="kn">from</span> <span class="nn">armi.reactor.composites</span> <span class="kn">import</span> <span class="n">Composite</span>


<span class="n">HOOKSPEC</span> <span class="o">=</span> <span class="n">pluggy</span><span class="o">.</span><span class="n">HookspecMarker</span><span class="p">(</span><span class="s2">&quot;armi&quot;</span><span class="p">)</span>
<span class="n">HOOKIMPL</span> <span class="o">=</span> <span class="n">pluggy</span><span class="o">.</span><span class="n">HookimplMarker</span><span class="p">(</span><span class="s2">&quot;armi&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="ArmiPlugin"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin">[docs]</a><span class="k">class</span> <span class="nc">ArmiPlugin</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An ArmiPlugin provides a namespace to collect hook implementations provided by a</span>
<span class="sd">    single &quot;plugin&quot;. This API is incomplete, unstable, and expected to change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ArmiPlugin.exposeInterfaces"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.exposeInterfaces">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">exposeInterfaces</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for exposing interface(s) to other code.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Tuples containing:</span>

<span class="sd">            - The insertion order to use when building an interface stack,</span>
<span class="sd">            - an implementation of the Interface class</span>
<span class="sd">            - a dictionary of kwargs to pass to an Operator when adding an instance of</span>
<span class="sd">              the interface class</span>

<span class="sd">            If no Interfaces should be active given the passed case settings, this should</span>
<span class="sd">            return an empty list.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.defineParameters"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.defineParameters">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineParameters</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for defining additional parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Keys should be subclasses of ArmiObject, values being a</span>
<span class="sd">            ParameterDefinitionCollection should be added to the key&#39;s perameter</span>
<span class="sd">            definitions.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; pluginBlockParams = parameters.ParameterDefinitionCollection()</span>
<span class="sd">        &gt;&gt;&gt; with pluginBlockParams.createBuilder() as pb:</span>
<span class="sd">        ...     pb.defParam(&quot;plugBlkP1&quot;, ...)</span>
<span class="sd">        ...     # ...</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; pluginAssemParams = parameters.ParameterDefinitionCollection()</span>
<span class="sd">        &gt;&gt;&gt; with pluginAssemParams.createBuilder() as pb:</span>
<span class="sd">        ...     pb.defParam(&quot;plugAsmP1&quot;, ...)</span>
<span class="sd">        ...     # ...</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; return {</span>
<span class="sd">        ...     blocks.Block: pluginBlockParams,</span>
<span class="sd">        ...     assemblies.Assembly: pluginAssemParams</span>
<span class="sd">        ... }</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.afterConstructionOfAssemblies"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.afterConstructionOfAssemblies">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">afterConstructionOfAssemblies</span><span class="p">(</span><span class="n">assemblies</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to call after a set of assemblies are constructed.</span>

<span class="sd">        This hook can be used to:</span>

<span class="sd">        - Verify that all assemblies satisfy constraints imposed by active interfaces</span>
<span class="sd">          and plugins</span>
<span class="sd">        - Apply modifications to Assemblies based on modeling options and active</span>
<span class="sd">          interfaces</span>

<span class="sd">        Implementers may alter the state of the passed Assembly objects.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.onProcessCoreLoading"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.onProcessCoreLoading">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">onProcessCoreLoading</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">dbLoad</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to call whenever a Core object is newly built.</span>

<span class="sd">        This is usually used to set initial parameter values from inputs, either after</span>
<span class="sd">        constructing a Core from Blueprints, or after loading it from a database.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.defineFlags"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.defineFlags">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineFlags</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">flags</span><span class="o">.</span><span class="n">auto</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to provide new Flags definitions.</span>

<span class="sd">        This allows a plugin to provide novel values for the Flags system.</span>
<span class="sd">        Implementations should return a dictionary mapping flag names to their desired</span>
<span class="sd">        numerical values. In most cases, no specific value is needed, in which case</span>
<span class="sd">        :py:class:`armi.utils.flags.auto` should be used.</span>

<span class="sd">        Flags should be added to the ARMI system with great care; flag values for each</span>
<span class="sd">        object are stored in a bitfield, so each additional flag increases the width of</span>
<span class="sd">        the data needed to store them. Also, due to the `what things are` interpretation</span>
<span class="sd">        of flags (see :py:mod:`armi.reactor.flags`), new flags should probably refer to</span>
<span class="sd">        novel design elements, rather than novel behaviors.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.flags</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; def defineFlags():</span>
<span class="sd">        ...     return {</span>
<span class="sd">        ...         &quot;FANCY&quot;: armi.utils.flags.auto()</span>
<span class="sd">        ...     }</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.defineBlockTypes"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.defineBlockTypes">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineBlockTypes</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for providing novel Block types from a plugin.</span>

<span class="sd">        This should return a list of tuples containing ``(compType, blockType)``, where</span>
<span class="sd">        ``blockType`` is a new ``Block`` subclass to register, and ``compType`` is the</span>
<span class="sd">        corresponding ``Component`` type that should activate it. For instance a</span>
<span class="sd">        ``HexBlock`` would be created when the largest component is a ``Hexagon``::</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            [(Hexagon, HexBlock)]</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.defineAssemblyTypes"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.defineAssemblyTypes">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineAssemblyTypes</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for providing novel Assembly types from a plugin.</span>

<span class="sd">        This should return a list of tuples containing ``(blockType, assemType)``, where</span>
<span class="sd">        ``assemType`` is a new ``Assembly`` subclass to register, and ``blockType`` is</span>
<span class="sd">        the corresponding ``Block`` subclass that, if present in the assembly, should</span>
<span class="sd">        trigger it to be of the corresponding ``assemType``.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The utility of subclassing Assembly is suspect, and may soon cease to be</span>
<span class="sd">            supported. In practice, Assembly subclasses provide very little</span>
<span class="sd">            functionality beyond that on the base class, and even that functionality can</span>
<span class="sd">            probably be better suited elsewhere. Moving this code around would let us</span>
<span class="sd">            eliminate the specialized Assembly subclasses altogether. In such a case,</span>
<span class="sd">            this API will be removed from the framework.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        [</span>
<span class="sd">            (HexBlock, HexAssembly),</span>
<span class="sd">            (CartesianBlock, CartesianAssembly),</span>
<span class="sd">            (ThRZBlock, ThRZAssembly),</span>
<span class="sd">        ]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of new Block&amp;Assembly types</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.defineBlueprintsSections"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.defineBlueprintsSections">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineBlueprintsSections</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new sections for the blueprints input method.</span>

<span class="sd">        This hook allows plugins to extend the blueprints functionality with their own</span>
<span class="sd">        sections.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            (name, section, resolutionMethod) tuples, where:</span>

<span class="sd">             - name : The name of the attribute to add to the Blueprints class; this</span>
<span class="sd">               should be a valid Python identifier.</span>

<span class="sd">             - section : An instance of ``yaml.Attribute`` defining the data that is</span>
<span class="sd">               described by the Blueprints section.</span>

<span class="sd">             - resolutionMethod : A callable that takes a Blueprints object and case</span>
<span class="sd">               settings as arguments. This will be called like an unbound instance</span>
<span class="sd">               method on the passed Blueprints object to initialize the state of the new</span>
<span class="sd">               Blueprints section.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Most of the sections that a plugin would want to add may be better served as</span>
<span class="sd">        settings, rather than blueprints sections. These sections were added to the</span>
<span class="sd">        blueprints mainly because the schema is more flexible, allowing namespaces and</span>
<span class="sd">        hierarchical collections of settings. Perhaps in the near future it would make</span>
<span class="sd">        sense to enhance the settings system to support these features, moving the</span>
<span class="sd">        blueprints extensions out into settings. This is discussed in more detail in</span>
<span class="sd">        T1671.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.defineEntryPoints"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.defineEntryPoints">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineEntryPoints</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new entry points for the ARMI CLI</span>

<span class="sd">        This hook allows plugins to provide their own ARMI entry points, which each</span>
<span class="sd">        serve as a command in the command-line interface.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            class objects which derive from the base EntryPoint class.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.defineSettings"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.defineSettings">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineSettings</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define configuration settings for this plugin.</span>

<span class="sd">        This hook allows plugins to provide their own configuration settings, which can</span>
<span class="sd">        participate in the :py:class:`armi.settings.caseSettings.CaseSettings`. Plugins</span>
<span class="sd">        may provide entirely new settings to what are already provided by ARMI, as well</span>
<span class="sd">        as new options or default values for existing settings. For instance, the</span>
<span class="sd">        framework provides a ``neutronicsKernel`` setting for selecting which global</span>
<span class="sd">        physics solver to use. Since we wish to enforce that the user specify a valid</span>
<span class="sd">        kernel, the settings validator will check to make sure that the user&#39;s requested</span>
<span class="sd">        kernel is among the available options. If a plugin were to provide a new</span>
<span class="sd">        neutronics kernel (let&#39;s say MCNP), it should also define a new option to tell</span>
<span class="sd">        the settings system that ``&quot;MCNP&quot;`` is a valid option.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            A list of Settings, Options, or Defaults to be registered.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.physics.neutronics.NeutronicsPlugin.defineSettings</span>
<span class="sd">        armi.settings.setting.Setting</span>
<span class="sd">        armi.settings.setting.Option</span>
<span class="sd">        armi.settings.setting.Default</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="ArmiPlugin.defineSettingsValidators"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.defineSettingsValidators">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineSettingsValidators</span><span class="p">(</span><span class="n">inspector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define the high-level settings input validators by adding them to an inspector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inspector : :py:class:`armi.operators.settingsValidation.Inspector` instance</span>
<span class="sd">            The inspector to add queries to. See note below, this is not ideal.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        These are higher-level than the input-level SCHEMA defined</span>
<span class="sd">        in :py:meth:`defineSettings` and are intended to be used for more</span>
<span class="sd">        complex cross-plugin info.</span>

<span class="sd">        We&#39;d prefer to not manipulate objects passed in directly, but</span>
<span class="sd">        rather have the inspection happen in a measureable hook. This</span>
<span class="sd">        would help find misbehaving plugins.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.operators.settingsValidation.Inspector : Runs the queries</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Query objects to attach</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="ArmiPlugin.defineCaseDependencies"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.defineCaseDependencies">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineCaseDependencies</span><span class="p">(</span><span class="n">case</span><span class="p">,</span> <span class="n">suite</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for defining case dependencies.</span>

<span class="sd">        Some Cases depend on the results of other ``Case``\ s in the same ``CaseSuite``.</span>
<span class="sd">        Which dependencies exist, and how they are discovered depends entirely on the</span>
<span class="sd">        type of analysis and active interfaces, etc. This function allows a plugin to</span>
<span class="sd">        inspect settings and declare dependencies between the passed ``case`` and any</span>
<span class="sd">        other cases in the passed ``suite``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        case : Case</span>
<span class="sd">            The specific case for which we want to find dependencies.</span>
<span class="sd">        suite : CaseSuite</span>
<span class="sd">            A CaseSuite object to which the Case and other potential dependencies belong.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dependencies : set of Cases</span>
<span class="sd">            This should return a set containing ``Case`` objects that are considered</span>
<span class="sd">            dependencies of the passed ``case``. They should be members of the passed</span>
<span class="sd">            ``suite``.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.defineGuiWidgets"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.defineGuiWidgets">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineGuiWidgets</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define which settings should go in the GUI.</span>

<span class="sd">        Rather than making widgets here, this simply returns metadata</span>
<span class="sd">        as a nested dictionary saying which tab to put which settings on,</span>
<span class="sd">        and a little bit about how to group them.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        widgetData : list of dict</span>
<span class="sd">            Each dict is nested. First level contains the tab name (e.g. &#39;Global Flux&#39;).</span>
<span class="sd">            Second level contains a box name. Third level contains help and a</span>
<span class="sd">            list of setting names</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.gui.submitter.layout.abstractTab.AbstractTab.addSectionsFromPlugin : uses data structure</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; widgets = {</span>
<span class="sd">        ...     &#39;Global Flux&#39;: {</span>
<span class="sd">        ...         &#39;MCNP Solver Settings&#39;: {</span>
<span class="sd">        ...             &#39;help&#39;: &quot;Help message&quot;</span>
<span class="sd">        ...             &#39;settings&#39;: [</span>
<span class="sd">        ...                 &quot;mcnpAddTallies&quot;,</span>
<span class="sd">        ...                 &quot;useSrctp&quot;,</span>
<span class="sd">        ...             ]</span>
<span class="sd">        ...         }</span>
<span class="sd">        ...     }</span>
<span class="sd">        ... }</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.getOperatorClassFromRunType"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.getOperatorClassFromRunType">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">getOperatorClassFromRunType</span><span class="p">(</span><span class="n">runType</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an Operator subclass if the runType is recognized by this plugin.&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.defineParameterRenames"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.defineParameterRenames">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineParameterRenames</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a mapping from old parameter names to new parameter names.</span>

<span class="sd">        Occasionally, it may become necessary to alter the name of an existing</span>
<span class="sd">        parameter. This can lead to frustration when attempting to load from old</span>
<span class="sd">        database files that use the previous name. This hook allows a plugin to define</span>
<span class="sd">        mappings from the old name to the new name, allowing the old database to be read</span>
<span class="sd">        in and translated to the new parameter name.</span>

<span class="sd">        The following rules are followed when applying these renames:</span>

<span class="sd">        * When state is loaded from a database, if the parameter name in the database</span>
<span class="sd">          file is found in the rename dictionary, it will be mapped to that renamed</span>
<span class="sd">          parameter.</span>
<span class="sd">        * If the renamed parameter is found in the renames, then it will be mapped again</span>
<span class="sd">          to new parameter name. This process is repeated until there are no more</span>
<span class="sd">          renames left. This allows for parameters to be renamed multiple times, and for</span>
<span class="sd">          a database from several generations prior to still be readable, so long as the</span>
<span class="sd">          history of renames is intact.</span>
<span class="sd">        * If at the end of the above process, the parameter name is not a defined</span>
<span class="sd">          parameter for the appropriate ``ArmiObject`` type, an exception is raised.</span>
<span class="sd">        * If any of the ``renames`` keys match any currently-defined parameters, an</span>
<span class="sd">          exception is raised.</span>
<span class="sd">        * If any of the ``renames`` collide with another plugin&#39;s ``renames``, an</span>
<span class="sd">          exception is raised.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renames : dict</span>
<span class="sd">            Keys should be an old parameter name, where the corresponding values are</span>
<span class="sd">            the new parameter name.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        The following would allow databases with values for either ``superOldParam`` or</span>
<span class="sd">        ``oldParam`` to be read into ``currentParam``::</span>

<span class="sd">            return {&quot;superOldParam&quot;: &quot;oldParam&quot;,</span>
<span class="sd">                    &quot;oldParam&quot;: &quot;currentParam&quot;}</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.mpiActionRequiresReset"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.mpiActionRequiresReset">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">mpiActionRequiresReset</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flag indicating when a reactor reset is required.</span>

<span class="sd">        Commands are sent through operators either as strings (old) or as MpiActions (newer).</span>
<span class="sd">        After some are sent, the reactor must be reset. This hook says when to reset. The</span>
<span class="sd">        reset operation is a (arguably suboptimal) response to some memory issues in</span>
<span class="sd">        very large and long-running cases.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmd :  str or MpiAction</span>
<span class="sd">            The ARMI mpi command being sent</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.operators.operatorMPI.OperatorMPI.workerOperate : Handles these flags</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.getReportContents"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.getReportContents">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">getReportContents</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">report</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">blueprint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To generate a report.</span>

<span class="sd">        For more information, see :doc:`/developer/reports`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        r : Reactor</span>

<span class="sd">        cs : Settings</span>

<span class="sd">        report : ReportContent</span>
<span class="sd">            Report object to add contents to</span>

<span class="sd">        stage : ReportStage</span>
<span class="sd">            begin/standard/or end (stage of the report for when inserting BOL vs. EOL</span>
<span class="sd">            content)</span>

<span class="sd">        blueprint : Blueprint, optional</span>
<span class="sd">            for a reactor (if None, only partial contents created)</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="ArmiPlugin.defineSystemBuilders"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.ArmiPlugin.defineSystemBuilders">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineSystemBuilders</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="s2">&quot;Composite&quot;</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a user-string from the systems section into a valid composite builder</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of the system type defined by the user, e.g., ``&quot;core&quot;``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that maps a grid type from the input file (e.g., ``&quot;core&quot;``)</span>
<span class="sd">            to a function responsible for building a grid of that type, e.g.,</span>

<span class="sd">            .. code::</span>

<span class="sd">                {</span>
<span class="sd">                    &quot;core&quot;: armi.reactor.reactors.Core,</span>
<span class="sd">                    &quot;sfp&quot;: armi.reactor.assemblyLists.SpentFuelPool,</span>
<span class="sd">                }</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The default :class:`~armi.reactor.ReactorPlugin` defines a ``&quot;core&quot;`` lookup</span>
<span class="sd">        and a ``&quot;sfp&quot;`` lookup, triggered to run after all other hooks have been run.</span>
<span class="sd">        &quot;&quot;&quot;</span></div></div>


<div class="viewcode-block" id="UserPlugin"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.UserPlugin">[docs]</a><span class="k">class</span> <span class="nc">UserPlugin</span><span class="p">(</span><span class="n">ArmiPlugin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A variation on the ArmiPlugin meant to be created at runtime, from the ``userPlugins`` setting.</span>

<span class="sd">    This is obviously a more limited use-case than the usual ArmiPlugin, as those are meant</span>
<span class="sd">    to be defined at import time, instead of run time. As such, this class has some built-in</span>
<span class="sd">    tooling to limit how these run-time plugins are used. They are meant to be more limited.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The usual ArmiPlugin is much more flexible, if the UserPlugin does not support what</span>
<span class="sd">    you want to do, just use an ArmiPlugin.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">ArmiPlugin</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__enforceLimitations</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__enforceLimitations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method enforces that UserPlugins are more limited than regular ArmiPlugins.</span>

<span class="sd">        UserPlugins are different from regular plugins in that they can be defined during</span>
<span class="sd">        a run, and as such, we want to limit how flexible they are, so we can correctly</span>
<span class="sd">        corral their side effects during a run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">UserPlugin</span><span class="p">):</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">defineParameterRenames</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="p">),</span> <span class="s2">&quot;UserPlugins cannot define parameter renames, consider using an ArmiPlugin.&quot;</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">defineSettings</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="p">),</span> <span class="s2">&quot;UserPlugins cannot define new Settings, consider using an ArmiPlugin.&quot;</span>
            <span class="c1"># NOTE: These are the class methods that we are staunchly _not_ allowing people</span>
            <span class="c1"># to change in this class. If you need these, please use a regular ArmiPlugin.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defineParameterRenames</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defineSettings</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defineSettingsValidators</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[]</span>

<div class="viewcode-block" id="UserPlugin.defineParameterRenames"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.UserPlugin.defineParameterRenames">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineParameterRenames</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prevents parameter renames.</span>

<span class="sd">        .. warning:: This is not overridable.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        It is a designed limitation of user plugins that they not generate parameter renames,</span>
<span class="sd">        so that they are able to be added to the plugin stack during run time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="UserPlugin.defineSettings"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.UserPlugin.defineSettings">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineSettings</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prevents new settings.</span>

<span class="sd">        .. warning:: This is not overridable.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        It is a designed limitation of user plugins that they not define new settings,</span>
<span class="sd">        so that they are able to be added to the plugin stack during run time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="UserPlugin.defineSettingsValidators"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.UserPlugin.defineSettingsValidators">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@HOOKSPEC</span>
    <span class="k">def</span> <span class="nf">defineSettingsValidators</span><span class="p">(</span><span class="n">inspector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prevents new settings validators.</span>

<span class="sd">        .. warning:: This is not overridable.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        It is a designed limitation of user plugins that they not define new settings,</span>
<span class="sd">        so that they are able to be added to the plugin stack during run time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span></div></div>


<div class="viewcode-block" id="getNewPluginManager"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.getNewPluginManager">[docs]</a><span class="k">def</span> <span class="nf">getNewPluginManager</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">pluginManager</span><span class="o">.</span><span class="n">ArmiPluginManager</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return a new plugin manager with all of the hookspecs pre-registered.&quot;&quot;&quot;</span>
    <span class="n">pm</span> <span class="o">=</span> <span class="n">pluginManager</span><span class="o">.</span><span class="n">ArmiPluginManager</span><span class="p">(</span><span class="s2">&quot;armi&quot;</span><span class="p">)</span>
    <span class="n">pm</span><span class="o">.</span><span class="n">add_hookspecs</span><span class="p">(</span><span class="n">ArmiPlugin</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pm</span></div>


<div class="viewcode-block" id="collectInterfaceDescriptions"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.collectInterfaceDescriptions">[docs]</a><span class="k">def</span> <span class="nf">collectInterfaceDescriptions</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adapt old-style describeInterfaces to the new plugin interface</span>

<span class="sd">    Old describeInterfaces implementations would return an interface class and kwargs</span>
<span class="sd">    for adding to an operator. Now we expect an ORDER as well. This takes a module and</span>
<span class="sd">    case settings and staples the module&#39;s ORDER attribute to the tuple and checks to</span>
<span class="sd">    make sure that a None is replaced by an empty list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">armi</span> <span class="kn">import</span> <span class="n">interfaces</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">describeInterfaces</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">interfaces</span><span class="o">.</span><span class="n">InterfaceInfo</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">ORDER</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">klass</span><span class="p">,</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="n">val</span>
        <span class="p">]</span>

    <span class="n">klass</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">interfaces</span><span class="o">.</span><span class="n">InterfaceInfo</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">ORDER</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)]</span></div>


<div class="viewcode-block" id="PluginError"><a class="viewcode-back" href="../../.apidocs/armi.plugins.html#armi.plugins.PluginError">[docs]</a><span class="k">class</span> <span class="nc">PluginError</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Special exception class for use when a plugin appears to be non-conformant.</span>

<span class="sd">    These should always come from some form of programmer error, and indicates</span>
<span class="sd">    conditions such as:</span>

<span class="sd">     - A plugin improperly implementing a hook, when possible to detect.</span>
<span class="sd">     - A collision between components provided by plugins (e.g. two plugins providing</span>
<span class="sd">       the same Blueprints section)</span>
<span class="sd">    &quot;&quot;&quot;</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2009-2022, TerraPower, LLC.
      <span class="lastupdated">
        Last updated on 2022-09-20.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>